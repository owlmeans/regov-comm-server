exports.id = "vendors-node_modules_ky-universal_index_js";
exports.ids = ["vendors-node_modules_ky-universal_index_js"];
exports.modules = {

/***/ "./node_modules/abort-controller/dist/abort-controller.js":
/*!****************************************************************!*\
  !*** ./node_modules/abort-controller/dist/abort-controller.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var eventTargetShim = __webpack_require__(/*! event-target-shim */ "./node_modules/event-target-shim/dist/event-target-shim.js");

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
class AbortSignal extends eventTargetShim.EventTarget {
  /**
   * AbortSignal cannot be constructed directly.
   */
  constructor() {
    super();
    throw new TypeError("AbortSignal cannot be constructed directly");
  }
  /**
   * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
   */
  get aborted() {
    const aborted = abortedFlags.get(this);
    if (typeof aborted !== "boolean") {
      throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
    }
    return aborted;
  }
}
eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
  const signal = Object.create(AbortSignal.prototype);
  eventTargetShim.EventTarget.call(signal);
  abortedFlags.set(signal, false);
  return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
  if (abortedFlags.get(signal) !== false) {
    return;
  }
  abortedFlags.set(signal, true);
  signal.dispatchEvent({
    type: "abort"
  });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal.prototype, {
  aborted: {
    enumerable: true
  }
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortSignal"
  });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
class AbortController {
  /**
   * Initialize this controller.
   */
  constructor() {
    signals.set(this, createAbortSignal());
  }
  /**
   * Returns the `AbortSignal` object associated with this object.
   */
  get signal() {
    return getSignal(this);
  }
  /**
   * Abort and signal to any observers that the associated activity is to be aborted.
   */
  abort() {
    abortSignal(getSignal(this));
  }
}
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
  const signal = signals.get(controller);
  if (signal == null) {
    throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
  }
  return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController.prototype, {
  signal: {
    enumerable: true
  },
  abort: {
    enumerable: true
  }
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortController"
  });
}
exports.AbortController = AbortController;
exports.AbortSignal = AbortSignal;
exports["default"] = AbortController;
module.exports = AbortController;
module.exports.AbortController = module.exports["default"] = AbortController;
module.exports.AbortSignal = AbortSignal;

/***/ }),

/***/ "./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
  const retv = privateData.get(event);
  console.assert(retv != null, "'this' is expected an Event object, but got", event);
  return retv;
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
  if (data.passiveListener != null) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
    }
    return;
  }
  if (!data.event.cancelable) {
    return;
  }
  data.canceled = true;
  if (typeof data.event.preventDefault === "function") {
    data.event.preventDefault();
  }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
  privateData.set(this, {
    eventTarget,
    event,
    eventPhase: 2,
    currentTarget: eventTarget,
    canceled: false,
    stopped: false,
    immediateStopped: false,
    passiveListener: null,
    timeStamp: event.timeStamp || Date.now()
  });

  // https://heycam.github.io/webidl/#Unforgeable
  Object.defineProperty(this, "isTrusted", {
    value: false,
    enumerable: true
  });

  // Define accessors
  const keys = Object.keys(event);
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in this)) {
      Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return pd(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return pd(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return pd(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const currentTarget = pd(this).currentTarget;
    if (currentTarget == null) {
      return [];
    }
    return [currentTarget];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return pd(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.stopPropagation === "function") {
      data.event.stopPropagation();
    }
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const data = pd(this);
    data.stopped = true;
    data.immediateStopped = true;
    if (typeof data.event.stopImmediatePropagation === "function") {
      data.event.stopImmediatePropagation();
    }
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return Boolean(pd(this).event.bubbles);
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return Boolean(pd(this).event.cancelable);
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    setCancelFlag(pd(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return pd(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return Boolean(pd(this).event.composed);
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return pd(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return pd(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return pd(this).stopped;
  },
  set cancelBubble(value) {
    if (!value) {
      return;
    }
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.cancelBubble === "boolean") {
      data.event.cancelBubble = true;
    }
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !pd(this).canceled;
  },
  set returnValue(value) {
    if (!value) {
      setCancelFlag(pd(this));
    }
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
    // Do nothing.
  }
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
  value: Event,
  configurable: true,
  writable: true
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
  Object.setPrototypeOf(Event.prototype, window.Event.prototype);

  // Make association for wrappers.
  wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
  return {
    get() {
      return pd(this).event[key];
    },
    set(value) {
      pd(this).event[key] = value;
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
  return {
    value() {
      const event = pd(this).event;
      return event[key].apply(event, arguments);
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
  const keys = Object.keys(proto);
  if (keys.length === 0) {
    return BaseEvent;
  }

  /** CustomEvent */
  function CustomEvent(eventTarget, event) {
    BaseEvent.call(this, eventTarget, event);
  }
  CustomEvent.prototype = Object.create(BaseEvent.prototype, {
    constructor: {
      value: CustomEvent,
      configurable: true,
      writable: true
    }
  });

  // Define accessors.
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in BaseEvent.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      const isFunc = typeof descriptor.value === "function";
      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
    }
  }
  return CustomEvent;
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
  if (proto == null || proto === Object.prototype) {
    return Event;
  }
  let wrapper = wrappers.get(proto);
  if (wrapper == null) {
    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
    wrappers.set(proto, wrapper);
  }
  return wrapper;
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
  const Wrapper = getWrapper(Object.getPrototypeOf(event));
  return new Wrapper(eventTarget, event);
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
  return pd(event).immediateStopped;
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
  pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
  pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
  pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
  return x !== null && typeof x === "object"; //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
  const listeners = listenersMap.get(eventTarget);
  if (listeners == null) {
    throw new TypeError("'this' is expected an EventTarget object, but got another value.");
  }
  return listeners;
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
  return {
    get() {
      const listeners = getListeners(this);
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          return node.listener;
        }
        node = node.next;
      }
      return null;
    },
    set(listener) {
      if (typeof listener !== "function" && !isObject(listener)) {
        listener = null; // eslint-disable-line no-param-reassign
      }
      const listeners = getListeners(this);

      // Traverse to the tail while removing old value.
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          // Remove old value.
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        node = node.next;
      }

      // Add new value.
      if (listener !== null) {
        const newNode = {
          listener,
          listenerType: ATTRIBUTE,
          passive: false,
          once: false,
          next: null
        };
        if (prev === null) {
          listeners.set(eventName, newNode);
        } else {
          prev.next = newNode;
        }
      }
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
  /** CustomEventTarget */
  function CustomEventTarget() {
    EventTarget.call(this);
  }
  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
    constructor: {
      value: CustomEventTarget,
      configurable: true,
      writable: true
    }
  });
  for (let i = 0; i < eventNames.length; ++i) {
    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  }
  return CustomEventTarget;
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
  /*eslint-disable consistent-return */
  if (this instanceof EventTarget) {
    listenersMap.set(this, new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return defineCustomEventTarget(arguments[0]);
  }
  if (arguments.length > 0) {
    const types = new Array(arguments.length);
    for (let i = 0; i < arguments.length; ++i) {
      types[i] = arguments[i];
    }
    return defineCustomEventTarget(types);
  }
  throw new TypeError("Cannot call a class as a function");
  /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    if (typeof listener !== "function" && !isObject(listener)) {
      throw new TypeError("'listener' should be a function or an object.");
    }
    const listeners = getListeners(this);
    const optionsIsObj = isObject(options);
    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    const newNode = {
      listener,
      listenerType,
      passive: optionsIsObj && Boolean(options.passive),
      once: optionsIsObj && Boolean(options.once),
      next: null
    };

    // Set it as the first node if the first node is null.
    let node = listeners.get(eventName);
    if (node === undefined) {
      listeners.set(eventName, newNode);
      return;
    }

    // Traverse to the tail while checking duplication..
    let prev = null;
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        // Should ignore duplication.
        return;
      }
      prev = node;
      node = node.next;
    }

    // Add it.
    prev.next = newNode;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    const listeners = getListeners(this);
    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    let prev = null;
    let node = listeners.get(eventName);
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
        return;
      }
      prev = node;
      node = node.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(event) {
    if (event == null || typeof event.type !== "string") {
      throw new TypeError('"event.type" should be a string.');
    }

    // If listeners aren't registered, terminate.
    const listeners = getListeners(this);
    const eventName = event.type;
    let node = listeners.get(eventName);
    if (node == null) {
      return true;
    }

    // Since we cannot rewrite several properties, so wrap object.
    const wrappedEvent = wrapEvent(this, event);

    // This doesn't process capturing phase and bubbling phase.
    // This isn't participating in a tree.
    let prev = null;
    while (node != null) {
      // Remove this listener if it's once
      if (node.once) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
      } else {
        prev = node;
      }

      // Call this listener
      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
      if (typeof node.listener === "function") {
        try {
          node.listener.call(this, wrappedEvent);
        } catch (err) {
          if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(err);
          }
        }
      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
        node.listener.handleEvent(wrappedEvent);
      }

      // Break if `event.stopImmediatePropagation` was called.
      if (isStopped(wrappedEvent)) {
        break;
      }
      node = node.next;
    }
    setPassiveListener(wrappedEvent, null);
    setEventPhase(wrappedEvent, 0);
    setCurrentTarget(wrappedEvent, null);
    return !wrappedEvent.defaultPrevented;
  }
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
  value: EventTarget,
  configurable: true,
  writable: true
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}
exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports["default"] = EventTarget;
module.exports = EventTarget;
module.exports.EventTarget = module.exports["default"] = EventTarget;
module.exports.defineEventAttribute = defineEventAttribute;

/***/ }),

/***/ "./node_modules/node-domexception/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-domexception/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */

if (!globalThis.DOMException) {
  try {
    const {
        MessageChannel
      } = __webpack_require__(/*! worker_threads */ "worker_threads"),
      port = new MessageChannel().port1,
      ab = new ArrayBuffer();
    port.postMessage(ab, [ab, ab]);
  } catch (err) {
    err.constructor.name === 'DOMException' && (globalThis.DOMException = err.constructor);
  }
}
module.exports = globalThis.DOMException;

/***/ }),

/***/ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * web-streams-polyfill v3.2.1
 */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  /// <reference lib="es2015.symbol" />
  const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : description => `Symbol(${description})`;

  /// <reference lib="dom" />
  function noop() {
    return undefined;
  }
  function getGlobals() {
    if (typeof self !== 'undefined') {
      return self;
    } else if (typeof window !== 'undefined') {
      return window;
    } else if (typeof global !== 'undefined') {
      return global;
    }
    return undefined;
  }
  const globals = getGlobals();
  function typeIsObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }
  const rethrowAssertionErrorRejection = noop;
  const originalPromise = Promise;
  const originalPromiseThen = Promise.prototype.then;
  const originalPromiseResolve = Promise.resolve.bind(originalPromise);
  const originalPromiseReject = Promise.reject.bind(originalPromise);
  function newPromise(executor) {
    return new originalPromise(executor);
  }
  function promiseResolvedWith(value) {
    return originalPromiseResolve(value);
  }
  function promiseRejectedWith(reason) {
    return originalPromiseReject(reason);
  }
  function PerformPromiseThen(promise, onFulfilled, onRejected) {
    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
    // approximation.
    return originalPromiseThen.call(promise, onFulfilled, onRejected);
  }
  function uponPromise(promise, onFulfilled, onRejected) {
    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
  }
  function uponFulfillment(promise, onFulfilled) {
    uponPromise(promise, onFulfilled);
  }
  function uponRejection(promise, onRejected) {
    uponPromise(promise, undefined, onRejected);
  }
  function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
  }
  function setPromiseIsHandledToTrue(promise) {
    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
  }
  const queueMicrotask = (() => {
    const globalQueueMicrotask = globals && globals.queueMicrotask;
    if (typeof globalQueueMicrotask === 'function') {
      return globalQueueMicrotask;
    }
    const resolvedPromise = promiseResolvedWith(undefined);
    return fn => PerformPromiseThen(resolvedPromise, fn);
  })();
  function reflectCall(F, V, args) {
    if (typeof F !== 'function') {
      throw new TypeError('Argument is not a function');
    }
    return Function.prototype.apply.call(F, V, args);
  }
  function promiseCall(F, V, args) {
    try {
      return promiseResolvedWith(reflectCall(F, V, args));
    } catch (value) {
      return promiseRejectedWith(value);
    }
  }

  // Original from Chromium
  // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
  const QUEUE_MAX_ARRAY_SIZE = 16384;
  /**
   * Simple queue structure.
   *
   * Avoids scalability issues with using a packed array directly by using
   * multiple arrays in a linked list and keeping the array size bounded.
   */
  class SimpleQueue {
    constructor() {
      this._cursor = 0;
      this._size = 0;
      // _front and _back are always defined.
      this._front = {
        _elements: [],
        _next: undefined
      };
      this._back = this._front;
      // The cursor is used to avoid calling Array.shift().
      // It contains the index of the front element of the array inside the
      // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
      this._cursor = 0;
      // When there is only one node, size === elements.length - cursor.
      this._size = 0;
    }
    get length() {
      return this._size;
    }
    // For exception safety, this method is structured in order:
    // 1. Read state
    // 2. Calculate required state mutations
    // 3. Perform state mutations
    push(element) {
      const oldBack = this._back;
      let newBack = oldBack;
      if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
        newBack = {
          _elements: [],
          _next: undefined
        };
      }
      // push() is the mutation most likely to throw an exception, so it
      // goes first.
      oldBack._elements.push(element);
      if (newBack !== oldBack) {
        this._back = newBack;
        oldBack._next = newBack;
      }
      ++this._size;
    }
    // Like push(), shift() follows the read -> calculate -> mutate pattern for
    // exception safety.
    shift() {
      // must not be called on an empty queue
      const oldFront = this._front;
      let newFront = oldFront;
      const oldCursor = this._cursor;
      let newCursor = oldCursor + 1;
      const elements = oldFront._elements;
      const element = elements[oldCursor];
      if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
        newFront = oldFront._next;
        newCursor = 0;
      }
      // No mutations before this point.
      --this._size;
      this._cursor = newCursor;
      if (oldFront !== newFront) {
        this._front = newFront;
      }
      // Permit shifted element to be garbage collected.
      elements[oldCursor] = undefined;
      return element;
    }
    // The tricky thing about forEach() is that it can be called
    // re-entrantly. The queue may be mutated inside the callback. It is easy to
    // see that push() within the callback has no negative effects since the end
    // of the queue is checked for on every iteration. If shift() is called
    // repeatedly within the callback then the next iteration may return an
    // element that has been removed. In this case the callback will be called
    // with undefined values until we either "catch up" with elements that still
    // exist or reach the back of the queue.
    forEach(callback) {
      let i = this._cursor;
      let node = this._front;
      let elements = node._elements;
      while (i !== elements.length || node._next !== undefined) {
        if (i === elements.length) {
          node = node._next;
          elements = node._elements;
          i = 0;
          if (elements.length === 0) {
            break;
          }
        }
        callback(elements[i]);
        ++i;
      }
    }
    // Return the element that would be returned if shift() was called now,
    // without modifying the queue.
    peek() {
      // must not be called on an empty queue
      const front = this._front;
      const cursor = this._cursor;
      return front._elements[cursor];
    }
  }
  function ReadableStreamReaderGenericInitialize(reader, stream) {
    reader._ownerReadableStream = stream;
    stream._reader = reader;
    if (stream._state === 'readable') {
      defaultReaderClosedPromiseInitialize(reader);
    } else if (stream._state === 'closed') {
      defaultReaderClosedPromiseInitializeAsResolved(reader);
    } else {
      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
    }
  }
  // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
  // check.
  function ReadableStreamReaderGenericCancel(reader, reason) {
    const stream = reader._ownerReadableStream;
    return ReadableStreamCancel(stream, reason);
  }
  function ReadableStreamReaderGenericRelease(reader) {
    if (reader._ownerReadableStream._state === 'readable') {
      defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
    } else {
      defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
    }
    reader._ownerReadableStream._reader = undefined;
    reader._ownerReadableStream = undefined;
  }
  // Helper functions for the readers.
  function readerLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released reader');
  }
  // Helper functions for the ReadableStreamDefaultReader.
  function defaultReaderClosedPromiseInitialize(reader) {
    reader._closedPromise = newPromise((resolve, reject) => {
      reader._closedPromise_resolve = resolve;
      reader._closedPromise_reject = reject;
    });
  }
  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseReject(reader, reason);
  }
  function defaultReaderClosedPromiseInitializeAsResolved(reader) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseResolve(reader);
  }
  function defaultReaderClosedPromiseReject(reader, reason) {
    if (reader._closedPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(reader._closedPromise);
    reader._closedPromise_reject(reason);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }
  function defaultReaderClosedPromiseResetToRejected(reader, reason) {
    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
  }
  function defaultReaderClosedPromiseResolve(reader) {
    if (reader._closedPromise_resolve === undefined) {
      return;
    }
    reader._closedPromise_resolve(undefined);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }
  const AbortSteps = SymbolPolyfill('[[AbortSteps]]');
  const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
  const CancelSteps = SymbolPolyfill('[[CancelSteps]]');
  const PullSteps = SymbolPolyfill('[[PullSteps]]');

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
  const NumberIsFinite = Number.isFinite || function (x) {
    return typeof x === 'number' && isFinite(x);
  };

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
  const MathTrunc = Math.trunc || function (v) {
    return v < 0 ? Math.ceil(v) : Math.floor(v);
  };

  // https://heycam.github.io/webidl/#idl-dictionaries
  function isDictionary(x) {
    return typeof x === 'object' || typeof x === 'function';
  }
  function assertDictionary(obj, context) {
    if (obj !== undefined && !isDictionary(obj)) {
      throw new TypeError(`${context} is not an object.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-callback-functions
  function assertFunction(x, context) {
    if (typeof x !== 'function') {
      throw new TypeError(`${context} is not a function.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-object
  function isObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }
  function assertObject(x, context) {
    if (!isObject(x)) {
      throw new TypeError(`${context} is not an object.`);
    }
  }
  function assertRequiredArgument(x, position, context) {
    if (x === undefined) {
      throw new TypeError(`Parameter ${position} is required in '${context}'.`);
    }
  }
  function assertRequiredField(x, field, context) {
    if (x === undefined) {
      throw new TypeError(`${field} is required in '${context}'.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-unrestricted-double
  function convertUnrestrictedDouble(value) {
    return Number(value);
  }
  function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
  }
  function integerPart(x) {
    return censorNegativeZero(MathTrunc(x));
  }
  // https://heycam.github.io/webidl/#idl-unsigned-long-long
  function convertUnsignedLongLongWithEnforceRange(value, context) {
    const lowerBound = 0;
    const upperBound = Number.MAX_SAFE_INTEGER;
    let x = Number(value);
    x = censorNegativeZero(x);
    if (!NumberIsFinite(x)) {
      throw new TypeError(`${context} is not a finite number`);
    }
    x = integerPart(x);
    if (x < lowerBound || x > upperBound) {
      throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
    }
    if (!NumberIsFinite(x) || x === 0) {
      return 0;
    }
    // TODO Use BigInt if supported?
    // let xBigInt = BigInt(integerPart(x));
    // xBigInt = BigInt.asUintN(64, xBigInt);
    // return Number(xBigInt);
    return x;
  }
  function assertReadableStream(x, context) {
    if (!IsReadableStream(x)) {
      throw new TypeError(`${context} is not a ReadableStream.`);
    }
  }

  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamDefaultReader(stream) {
    return new ReadableStreamDefaultReader(stream);
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamAddReadRequest(stream, readRequest) {
    stream._reader._readRequests.push(readRequest);
  }
  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
    const reader = stream._reader;
    const readRequest = reader._readRequests.shift();
    if (done) {
      readRequest._closeSteps();
    } else {
      readRequest._chunkSteps(chunk);
    }
  }
  function ReadableStreamGetNumReadRequests(stream) {
    return stream._reader._readRequests.length;
  }
  function ReadableStreamHasDefaultReader(stream) {
    const reader = stream._reader;
    if (reader === undefined) {
      return false;
    }
    if (!IsReadableStreamDefaultReader(reader)) {
      return false;
    }
    return true;
  }
  /**
   * A default reader vended by a {@link ReadableStream}.
   *
   * @public
   */
  class ReadableStreamDefaultReader {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
      assertReadableStream(stream, 'First parameter');
      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }
      ReadableStreamReaderGenericInitialize(this, stream);
      this._readRequests = new SimpleQueue();
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed,
     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */
    cancel(reason = undefined) {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }
      return ReadableStreamReaderGenericCancel(this, reason);
    }
    /**
     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */
    read() {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('read'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readRequest = {
        _chunkSteps: chunk => resolvePromise({
          value: chunk,
          done: false
        }),
        _closeSteps: () => resolvePromise({
          value: undefined,
          done: true
        }),
        _errorSteps: e => rejectPromise(e)
      };
      ReadableStreamDefaultReaderRead(this, readRequest);
      return promise;
    }
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */
    releaseLock() {
      if (!IsReadableStreamDefaultReader(this)) {
        throw defaultReaderBrandCheckException('releaseLock');
      }
      if (this._ownerReadableStream === undefined) {
        return;
      }
      if (this._readRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }
      ReadableStreamReaderGenericRelease(this);
    }
  }
  Object.defineProperties(ReadableStreamDefaultReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultReader',
      configurable: true
    });
  }
  // Abstract operations for the readers.
  function IsReadableStreamDefaultReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
      return false;
    }
    return x instanceof ReadableStreamDefaultReader;
  }
  function ReadableStreamDefaultReaderRead(reader, readRequest) {
    const stream = reader._ownerReadableStream;
    stream._disturbed = true;
    if (stream._state === 'closed') {
      readRequest._closeSteps();
    } else if (stream._state === 'errored') {
      readRequest._errorSteps(stream._storedError);
    } else {
      stream._readableStreamController[PullSteps](readRequest);
    }
  }
  // Helper functions for the ReadableStreamDefaultReader.
  function defaultReaderBrandCheckException(name) {
    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
  }

  /// <reference lib="es2018.asynciterable" />
  /* eslint-disable @typescript-eslint/no-empty-function */
  const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);

  /// <reference lib="es2018.asynciterable" />
  class ReadableStreamAsyncIteratorImpl {
    constructor(reader, preventCancel) {
      this._ongoingPromise = undefined;
      this._isFinished = false;
      this._reader = reader;
      this._preventCancel = preventCancel;
    }
    next() {
      const nextSteps = () => this._nextSteps();
      this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
      return this._ongoingPromise;
    }
    return(value) {
      const returnSteps = () => this._returnSteps(value);
      return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
    }
    _nextSteps() {
      if (this._isFinished) {
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }
      const reader = this._reader;
      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('iterate'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readRequest = {
        _chunkSteps: chunk => {
          this._ongoingPromise = undefined;
          // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
          // FIXME Is this a bug in the specification, or in the test?
          queueMicrotask(() => resolvePromise({
            value: chunk,
            done: false
          }));
        },
        _closeSteps: () => {
          this._ongoingPromise = undefined;
          this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          resolvePromise({
            value: undefined,
            done: true
          });
        },
        _errorSteps: reason => {
          this._ongoingPromise = undefined;
          this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          rejectPromise(reason);
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promise;
    }
    _returnSteps(value) {
      if (this._isFinished) {
        return Promise.resolve({
          value,
          done: true
        });
      }
      this._isFinished = true;
      const reader = this._reader;
      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('finish iterating'));
      }
      if (!this._preventCancel) {
        const result = ReadableStreamReaderGenericCancel(reader, value);
        ReadableStreamReaderGenericRelease(reader);
        return transformPromiseWith(result, () => ({
          value,
          done: true
        }));
      }
      ReadableStreamReaderGenericRelease(reader);
      return promiseResolvedWith({
        value,
        done: true
      });
    }
  }
  const ReadableStreamAsyncIteratorPrototype = {
    next() {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
      }
      return this._asyncIteratorImpl.next();
    },
    return(value) {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
      }
      return this._asyncIteratorImpl.return(value);
    }
  };
  if (AsyncIteratorPrototype !== undefined) {
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
  }
  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
    const reader = AcquireReadableStreamDefaultReader(stream);
    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
    iterator._asyncIteratorImpl = impl;
    return iterator;
  }
  function IsReadableStreamAsyncIterator(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
      return false;
    }
    try {
      // noinspection SuspiciousTypeOfGuard
      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
    } catch (_a) {
      return false;
    }
  }
  // Helper functions for the ReadableStream.
  function streamAsyncIteratorBrandCheckException(name) {
    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
  }

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
  const NumberIsNaN = Number.isNaN || function (x) {
    // eslint-disable-next-line no-self-compare
    return x !== x;
  };
  function CreateArrayFromList(elements) {
    // We use arrays to represent lists, so this is basically a no-op.
    // Do a slice though just in case we happen to depend on the unique-ness.
    return elements.slice();
  }
  function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  }
  // Not implemented correctly
  function TransferArrayBuffer(O) {
    return O;
  }
  // Not implemented correctly
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function IsDetachedBuffer(O) {
    return false;
  }
  function ArrayBufferSlice(buffer, begin, end) {
    // ArrayBuffer.prototype.slice is not available on IE10
    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
    if (buffer.slice) {
      return buffer.slice(begin, end);
    }
    const length = end - begin;
    const slice = new ArrayBuffer(length);
    CopyDataBlockBytes(slice, 0, buffer, begin, length);
    return slice;
  }
  function IsNonNegativeNumber(v) {
    if (typeof v !== 'number') {
      return false;
    }
    if (NumberIsNaN(v)) {
      return false;
    }
    if (v < 0) {
      return false;
    }
    return true;
  }
  function CloneAsUint8Array(O) {
    const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
    return new Uint8Array(buffer);
  }
  function DequeueValue(container) {
    const pair = container._queue.shift();
    container._queueTotalSize -= pair.size;
    if (container._queueTotalSize < 0) {
      container._queueTotalSize = 0;
    }
    return pair.value;
  }
  function EnqueueValueWithSize(container, value, size) {
    if (!IsNonNegativeNumber(size) || size === Infinity) {
      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
    }
    container._queue.push({
      value,
      size
    });
    container._queueTotalSize += size;
  }
  function PeekQueueValue(container) {
    const pair = container._queue.peek();
    return pair.value;
  }
  function ResetQueue(container) {
    container._queue = new SimpleQueue();
    container._queueTotalSize = 0;
  }

  /**
   * A pull-into request in a {@link ReadableByteStreamController}.
   *
   * @public
   */
  class ReadableStreamBYOBRequest {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
     */
    get view() {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('view');
      }
      return this._view;
    }
    respond(bytesWritten) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respond');
      }
      assertRequiredArgument(bytesWritten, 1, 'respond');
      bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }
      if (IsDetachedBuffer(this._view.buffer)) ;
      ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
    }
    respondWithNewView(view) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respondWithNewView');
      }
      assertRequiredArgument(view, 1, 'respondWithNewView');
      if (!ArrayBuffer.isView(view)) {
        throw new TypeError('You can only respond with array buffer views');
      }
      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }
      if (IsDetachedBuffer(view.buffer)) ;
      ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
    }
  }
  Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
    respond: {
      enumerable: true
    },
    respondWithNewView: {
      enumerable: true
    },
    view: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBRequest',
      configurable: true
    });
  }
  /**
   * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
   *
   * @public
   */
  class ReadableByteStreamController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the current BYOB pull request, or `null` if there isn't one.
     */
    get byobRequest() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('byobRequest');
      }
      return ReadableByteStreamControllerGetBYOBRequest(this);
    }
    /**
     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
     */
    get desiredSize() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('desiredSize');
      }
      return ReadableByteStreamControllerGetDesiredSize(this);
    }
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */
    close() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('close');
      }
      if (this._closeRequested) {
        throw new TypeError('The stream has already been closed; do not close it again!');
      }
      const state = this._controlledReadableByteStream._state;
      if (state !== 'readable') {
        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
      }
      ReadableByteStreamControllerClose(this);
    }
    enqueue(chunk) {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('enqueue');
      }
      assertRequiredArgument(chunk, 1, 'enqueue');
      if (!ArrayBuffer.isView(chunk)) {
        throw new TypeError('chunk must be an array buffer view');
      }
      if (chunk.byteLength === 0) {
        throw new TypeError('chunk must have non-zero byteLength');
      }
      if (chunk.buffer.byteLength === 0) {
        throw new TypeError(`chunk's buffer must have non-zero byteLength`);
      }
      if (this._closeRequested) {
        throw new TypeError('stream is closed or draining');
      }
      const state = this._controlledReadableByteStream._state;
      if (state !== 'readable') {
        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
      }
      ReadableByteStreamControllerEnqueue(this, chunk);
    }
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */
    error(e = undefined) {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('error');
      }
      ReadableByteStreamControllerError(this, e);
    }
    /** @internal */
    [CancelSteps](reason) {
      ReadableByteStreamControllerClearPendingPullIntos(this);
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      ReadableByteStreamControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [PullSteps](readRequest) {
      const stream = this._controlledReadableByteStream;
      if (this._queueTotalSize > 0) {
        const entry = this._queue.shift();
        this._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(this);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
        return;
      }
      const autoAllocateChunkSize = this._autoAllocateChunkSize;
      if (autoAllocateChunkSize !== undefined) {
        let buffer;
        try {
          buffer = new ArrayBuffer(autoAllocateChunkSize);
        } catch (bufferE) {
          readRequest._errorSteps(bufferE);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: autoAllocateChunkSize,
          byteOffset: 0,
          byteLength: autoAllocateChunkSize,
          bytesFilled: 0,
          elementSize: 1,
          viewConstructor: Uint8Array,
          readerType: 'default'
        };
        this._pendingPullIntos.push(pullIntoDescriptor);
      }
      ReadableStreamAddReadRequest(stream, readRequest);
      ReadableByteStreamControllerCallPullIfNeeded(this);
    }
  }
  Object.defineProperties(ReadableByteStreamController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    byobRequest: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableByteStreamController',
      configurable: true
    });
  }
  // Abstract operations for the ReadableByteStreamController.
  function IsReadableByteStreamController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
      return false;
    }
    return x instanceof ReadableByteStreamController;
  }
  function IsReadableStreamBYOBRequest(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
      return false;
    }
    return x instanceof ReadableStreamBYOBRequest;
  }
  function ReadableByteStreamControllerCallPullIfNeeded(controller) {
    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
    if (!shouldPull) {
      return;
    }
    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }
    controller._pulling = true;
    // TODO: Test controller argument
    const pullPromise = controller._pullAlgorithm();
    uponPromise(pullPromise, () => {
      controller._pulling = false;
      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }, e => {
      ReadableByteStreamControllerError(controller, e);
    });
  }
  function ReadableByteStreamControllerClearPendingPullIntos(controller) {
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    controller._pendingPullIntos = new SimpleQueue();
  }
  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
    let done = false;
    if (stream._state === 'closed') {
      done = true;
    }
    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
    if (pullIntoDescriptor.readerType === 'default') {
      ReadableStreamFulfillReadRequest(stream, filledView, done);
    } else {
      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
    }
  }
  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
    const bytesFilled = pullIntoDescriptor.bytesFilled;
    const elementSize = pullIntoDescriptor.elementSize;
    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
  }
  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
    controller._queue.push({
      buffer,
      byteOffset,
      byteLength
    });
    controller._queueTotalSize += byteLength;
  }
  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
    const elementSize = pullIntoDescriptor.elementSize;
    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
    let totalBytesToCopyRemaining = maxBytesToCopy;
    let ready = false;
    if (maxAlignedBytes > currentAlignedBytes) {
      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
      ready = true;
    }
    const queue = controller._queue;
    while (totalBytesToCopyRemaining > 0) {
      const headOfQueue = queue.peek();
      const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
      const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
      if (headOfQueue.byteLength === bytesToCopy) {
        queue.shift();
      } else {
        headOfQueue.byteOffset += bytesToCopy;
        headOfQueue.byteLength -= bytesToCopy;
      }
      controller._queueTotalSize -= bytesToCopy;
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
      totalBytesToCopyRemaining -= bytesToCopy;
    }
    return ready;
  }
  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
    pullIntoDescriptor.bytesFilled += size;
  }
  function ReadableByteStreamControllerHandleQueueDrain(controller) {
    if (controller._queueTotalSize === 0 && controller._closeRequested) {
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(controller._controlledReadableByteStream);
    } else {
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }
  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
    if (controller._byobRequest === null) {
      return;
    }
    controller._byobRequest._associatedReadableByteStreamController = undefined;
    controller._byobRequest._view = null;
    controller._byobRequest = null;
  }
  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
    while (controller._pendingPullIntos.length > 0) {
      if (controller._queueTotalSize === 0) {
        return;
      }
      const pullIntoDescriptor = controller._pendingPullIntos.peek();
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      }
    }
  }
  function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
    const stream = controller._controlledReadableByteStream;
    let elementSize = 1;
    if (view.constructor !== DataView) {
      elementSize = view.constructor.BYTES_PER_ELEMENT;
    }
    const ctor = view.constructor;
    // try {
    const buffer = TransferArrayBuffer(view.buffer);
    // } catch (e) {
    //   readIntoRequest._errorSteps(e);
    //   return;
    // }
    const pullIntoDescriptor = {
      buffer,
      bufferByteLength: buffer.byteLength,
      byteOffset: view.byteOffset,
      byteLength: view.byteLength,
      bytesFilled: 0,
      elementSize,
      viewConstructor: ctor,
      readerType: 'byob'
    };
    if (controller._pendingPullIntos.length > 0) {
      controller._pendingPullIntos.push(pullIntoDescriptor);
      // No ReadableByteStreamControllerCallPullIfNeeded() call since:
      // - No change happens on desiredSize
      // - The source has already been notified of that there's at least 1 pending read(view)
      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      return;
    }
    if (stream._state === 'closed') {
      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
      readIntoRequest._closeSteps(emptyView);
      return;
    }
    if (controller._queueTotalSize > 0) {
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        ReadableByteStreamControllerHandleQueueDrain(controller);
        readIntoRequest._chunkSteps(filledView);
        return;
      }
      if (controller._closeRequested) {
        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        readIntoRequest._errorSteps(e);
        return;
      }
    }
    controller._pendingPullIntos.push(pullIntoDescriptor);
    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
    const stream = controller._controlledReadableByteStream;
    if (ReadableStreamHasBYOBReader(stream)) {
      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
      }
    }
  }
  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
      return;
    }
    ReadableByteStreamControllerShiftPendingPullInto(controller);
    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
    if (remainderSize > 0) {
      const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
    }
    pullIntoDescriptor.bytesFilled -= remainderSize;
    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  }
  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      ReadableByteStreamControllerRespondInClosedState(controller);
    } else {
      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
    }
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerShiftPendingPullInto(controller) {
    const descriptor = controller._pendingPullIntos.shift();
    return descriptor;
  }
  function ReadableByteStreamControllerShouldCallPull(controller) {
    const stream = controller._controlledReadableByteStream;
    if (stream._state !== 'readable') {
      return false;
    }
    if (controller._closeRequested) {
      return false;
    }
    if (!controller._started) {
      return false;
    }
    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }
    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      return true;
    }
    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
    if (desiredSize > 0) {
      return true;
    }
    return false;
  }
  function ReadableByteStreamControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
  }
  // A client of ReadableByteStreamController may use these functions directly to bypass state check.
  function ReadableByteStreamControllerClose(controller) {
    const stream = controller._controlledReadableByteStream;
    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }
    if (controller._queueTotalSize > 0) {
      controller._closeRequested = true;
      return;
    }
    if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      if (firstPendingPullInto.bytesFilled > 0) {
        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        throw e;
      }
    }
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }
  function ReadableByteStreamControllerEnqueue(controller, chunk) {
    const stream = controller._controlledReadableByteStream;
    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }
    const buffer = chunk.buffer;
    const byteOffset = chunk.byteOffset;
    const byteLength = chunk.byteLength;
    const transferredBuffer = TransferArrayBuffer(buffer);
    if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
    }
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    if (ReadableStreamHasDefaultReader(stream)) {
      if (ReadableStreamGetNumReadRequests(stream) === 0) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      } else {
        if (controller._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
        ReadableStreamFulfillReadRequest(stream, transferredView, false);
      }
    } else if (ReadableStreamHasBYOBReader(stream)) {
      // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    } else {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    }
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerError(controller, e) {
    const stream = controller._controlledReadableByteStream;
    if (stream._state !== 'readable') {
      return;
    }
    ReadableByteStreamControllerClearPendingPullIntos(controller);
    ResetQueue(controller);
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }
  function ReadableByteStreamControllerGetBYOBRequest(controller) {
    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
      SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
      controller._byobRequest = byobRequest;
    }
    return controller._byobRequest;
  }
  function ReadableByteStreamControllerGetDesiredSize(controller) {
    const state = controller._controlledReadableByteStream._state;
    if (state === 'errored') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return controller._strategyHWM - controller._queueTotalSize;
  }
  function ReadableByteStreamControllerRespond(controller, bytesWritten) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      if (bytesWritten !== 0) {
        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
      }
    } else {
      if (bytesWritten === 0) {
        throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
      }
      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
        throw new RangeError('bytesWritten out of range');
      }
    }
    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
  }
  function ReadableByteStreamControllerRespondWithNewView(controller, view) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      if (view.byteLength !== 0) {
        throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
      }
    } else {
      if (view.byteLength === 0) {
        throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
      }
    }
    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
      throw new RangeError('The region specified by view does not match byobRequest');
    }
    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
      throw new RangeError('The buffer of view has different capacity than byobRequest');
    }
    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
      throw new RangeError('The region specified by view is larger than byobRequest');
    }
    const viewByteLength = view.byteLength;
    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
  }
  function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
    controller._controlledReadableByteStream = stream;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._byobRequest = null;
    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
    controller._queue = controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._closeRequested = false;
    controller._started = false;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    controller._autoAllocateChunkSize = autoAllocateChunkSize;
    controller._pendingPullIntos = new SimpleQueue();
    stream._readableStreamController = controller;
    const startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), () => {
      controller._started = true;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }, r => {
      ReadableByteStreamControllerError(controller, r);
    });
  }
  function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
    const controller = Object.create(ReadableByteStreamController.prototype);
    let startAlgorithm = () => undefined;
    let pullAlgorithm = () => promiseResolvedWith(undefined);
    let cancelAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingByteSource.start !== undefined) {
      startAlgorithm = () => underlyingByteSource.start(controller);
    }
    if (underlyingByteSource.pull !== undefined) {
      pullAlgorithm = () => underlyingByteSource.pull(controller);
    }
    if (underlyingByteSource.cancel !== undefined) {
      cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
    }
    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
    if (autoAllocateChunkSize === 0) {
      throw new TypeError('autoAllocateChunkSize must be greater than 0');
    }
    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
  }
  function SetUpReadableStreamBYOBRequest(request, controller, view) {
    request._associatedReadableByteStreamController = controller;
    request._view = view;
  }
  // Helper functions for the ReadableStreamBYOBRequest.
  function byobRequestBrandCheckException(name) {
    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
  }
  // Helper functions for the ReadableByteStreamController.
  function byteStreamControllerBrandCheckException(name) {
    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
  }

  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamBYOBReader(stream) {
    return new ReadableStreamBYOBReader(stream);
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
    stream._reader._readIntoRequests.push(readIntoRequest);
  }
  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
    const reader = stream._reader;
    const readIntoRequest = reader._readIntoRequests.shift();
    if (done) {
      readIntoRequest._closeSteps(chunk);
    } else {
      readIntoRequest._chunkSteps(chunk);
    }
  }
  function ReadableStreamGetNumReadIntoRequests(stream) {
    return stream._reader._readIntoRequests.length;
  }
  function ReadableStreamHasBYOBReader(stream) {
    const reader = stream._reader;
    if (reader === undefined) {
      return false;
    }
    if (!IsReadableStreamBYOBReader(reader)) {
      return false;
    }
    return true;
  }
  /**
   * A BYOB reader vended by a {@link ReadableStream}.
   *
   * @public
   */
  class ReadableStreamBYOBReader {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
      assertReadableStream(stream, 'First parameter');
      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }
      if (!IsReadableByteStreamController(stream._readableStreamController)) {
        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
      }
      ReadableStreamReaderGenericInitialize(this, stream);
      this._readIntoRequests = new SimpleQueue();
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
     * the reader's lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */
    cancel(reason = undefined) {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }
      return ReadableStreamReaderGenericCancel(this, reason);
    }
    /**
     * Attempts to reads bytes into view, and returns a promise resolved with the result.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */
    read(view) {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('read'));
      }
      if (!ArrayBuffer.isView(view)) {
        return promiseRejectedWith(new TypeError('view must be an array buffer view'));
      }
      if (view.byteLength === 0) {
        return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
      }
      if (view.buffer.byteLength === 0) {
        return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
      }
      if (IsDetachedBuffer(view.buffer)) ;
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readIntoRequest = {
        _chunkSteps: chunk => resolvePromise({
          value: chunk,
          done: false
        }),
        _closeSteps: chunk => resolvePromise({
          value: chunk,
          done: true
        }),
        _errorSteps: e => rejectPromise(e)
      };
      ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
      return promise;
    }
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */
    releaseLock() {
      if (!IsReadableStreamBYOBReader(this)) {
        throw byobReaderBrandCheckException('releaseLock');
      }
      if (this._ownerReadableStream === undefined) {
        return;
      }
      if (this._readIntoRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }
      ReadableStreamReaderGenericRelease(this);
    }
  }
  Object.defineProperties(ReadableStreamBYOBReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBReader',
      configurable: true
    });
  }
  // Abstract operations for the readers.
  function IsReadableStreamBYOBReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
      return false;
    }
    return x instanceof ReadableStreamBYOBReader;
  }
  function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
    const stream = reader._ownerReadableStream;
    stream._disturbed = true;
    if (stream._state === 'errored') {
      readIntoRequest._errorSteps(stream._storedError);
    } else {
      ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
    }
  }
  // Helper functions for the ReadableStreamBYOBReader.
  function byobReaderBrandCheckException(name) {
    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
  }
  function ExtractHighWaterMark(strategy, defaultHWM) {
    const {
      highWaterMark
    } = strategy;
    if (highWaterMark === undefined) {
      return defaultHWM;
    }
    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
      throw new RangeError('Invalid highWaterMark');
    }
    return highWaterMark;
  }
  function ExtractSizeAlgorithm(strategy) {
    const {
      size
    } = strategy;
    if (!size) {
      return () => 1;
    }
    return size;
  }
  function convertQueuingStrategy(init, context) {
    assertDictionary(init, context);
    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    const size = init === null || init === void 0 ? void 0 : init.size;
    return {
      highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
      size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
    };
  }
  function convertQueuingStrategySize(fn, context) {
    assertFunction(fn, context);
    return chunk => convertUnrestrictedDouble(fn(chunk));
  }
  function convertUnderlyingSink(original, context) {
    assertDictionary(original, context);
    const abort = original === null || original === void 0 ? void 0 : original.abort;
    const close = original === null || original === void 0 ? void 0 : original.close;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const type = original === null || original === void 0 ? void 0 : original.type;
    const write = original === null || original === void 0 ? void 0 : original.write;
    return {
      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
      write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
      type
    };
  }
  function convertUnderlyingSinkAbortCallback(fn, original, context) {
    assertFunction(fn, context);
    return reason => promiseCall(fn, original, [reason]);
  }
  function convertUnderlyingSinkCloseCallback(fn, original, context) {
    assertFunction(fn, context);
    return () => promiseCall(fn, original, []);
  }
  function convertUnderlyingSinkStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertUnderlyingSinkWriteCallback(fn, original, context) {
    assertFunction(fn, context);
    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  }
  function assertWritableStream(x, context) {
    if (!IsWritableStream(x)) {
      throw new TypeError(`${context} is not a WritableStream.`);
    }
  }
  function isAbortSignal(value) {
    if (typeof value !== 'object' || value === null) {
      return false;
    }
    try {
      return typeof value.aborted === 'boolean';
    } catch (_a) {
      // AbortSignal.prototype.aborted throws if its brand check fails
      return false;
    }
  }
  const supportsAbortController = typeof AbortController === 'function';
  /**
   * Construct a new AbortController, if supported by the platform.
   *
   * @internal
   */
  function createAbortController() {
    if (supportsAbortController) {
      return new AbortController();
    }
    return undefined;
  }

  /**
   * A writable stream represents a destination for data, into which you can write.
   *
   * @public
   */
  class WritableStream {
    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
      if (rawUnderlyingSink === undefined) {
        rawUnderlyingSink = null;
      } else {
        assertObject(rawUnderlyingSink, 'First parameter');
      }
      const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
      InitializeWritableStream(this);
      const type = underlyingSink.type;
      if (type !== undefined) {
        throw new RangeError('Invalid type is specified');
      }
      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
      const highWaterMark = ExtractHighWaterMark(strategy, 1);
      SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
    }
    /**
     * Returns whether or not the writable stream is locked to a writer.
     */
    get locked() {
      if (!IsWritableStream(this)) {
        throw streamBrandCheckException$2('locked');
      }
      return IsWritableStreamLocked(this);
    }
    /**
     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
     * mechanism of the underlying sink.
     *
     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
     * the stream) if the stream is currently locked.
     */
    abort(reason = undefined) {
      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('abort'));
      }
      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
      }
      return WritableStreamAbort(this, reason);
    }
    /**
     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
     * close behavior. During this time any further attempts to write will fail (without erroring the stream).
     *
     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
     */
    close() {
      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('close'));
      }
      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
      }
      if (WritableStreamCloseQueuedOrInFlight(this)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }
      return WritableStreamClose(this);
    }
    /**
     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
     * is locked, no other writer can be acquired until this one is released.
     *
     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
     * the same time, which would cause the resulting written data to be unpredictable and probably useless.
     */
    getWriter() {
      if (!IsWritableStream(this)) {
        throw streamBrandCheckException$2('getWriter');
      }
      return AcquireWritableStreamDefaultWriter(this);
    }
  }
  Object.defineProperties(WritableStream.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    getWriter: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStream',
      configurable: true
    });
  }
  // Abstract operations for the WritableStream.
  function AcquireWritableStreamDefaultWriter(stream) {
    return new WritableStreamDefaultWriter(stream);
  }
  // Throws if and only if startAlgorithm throws.
  function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
    const stream = Object.create(WritableStream.prototype);
    InitializeWritableStream(stream);
    const controller = Object.create(WritableStreamDefaultController.prototype);
    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  }
  function InitializeWritableStream(stream) {
    stream._state = 'writable';
    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
    // 'erroring' or 'errored'. May be set to an undefined value.
    stream._storedError = undefined;
    stream._writer = undefined;
    // Initialize to undefined first because the constructor of the controller checks this
    // variable to validate the caller.
    stream._writableStreamController = undefined;
    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
    // producer without waiting for the queued writes to finish.
    stream._writeRequests = new SimpleQueue();
    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
    stream._inFlightWriteRequest = undefined;
    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
    // has been detached.
    stream._closeRequest = undefined;
    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
    stream._inFlightCloseRequest = undefined;
    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
    stream._pendingAbortRequest = undefined;
    // The backpressure signal set by the controller.
    stream._backpressure = false;
  }
  function IsWritableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
      return false;
    }
    return x instanceof WritableStream;
  }
  function IsWritableStreamLocked(stream) {
    if (stream._writer === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamAbort(stream, reason) {
    var _a;
    if (stream._state === 'closed' || stream._state === 'errored') {
      return promiseResolvedWith(undefined);
    }
    stream._writableStreamController._abortReason = reason;
    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
    // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
    // but it doesn't know that signaling abort runs author code that might have changed the state.
    // Widen the type again by casting to WritableStreamState.
    const state = stream._state;
    if (state === 'closed' || state === 'errored') {
      return promiseResolvedWith(undefined);
    }
    if (stream._pendingAbortRequest !== undefined) {
      return stream._pendingAbortRequest._promise;
    }
    let wasAlreadyErroring = false;
    if (state === 'erroring') {
      wasAlreadyErroring = true;
      // reason will not be used, so don't keep a reference to it.
      reason = undefined;
    }
    const promise = newPromise((resolve, reject) => {
      stream._pendingAbortRequest = {
        _promise: undefined,
        _resolve: resolve,
        _reject: reject,
        _reason: reason,
        _wasAlreadyErroring: wasAlreadyErroring
      };
    });
    stream._pendingAbortRequest._promise = promise;
    if (!wasAlreadyErroring) {
      WritableStreamStartErroring(stream, reason);
    }
    return promise;
  }
  function WritableStreamClose(stream) {
    const state = stream._state;
    if (state === 'closed' || state === 'errored') {
      return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
    }
    const promise = newPromise((resolve, reject) => {
      const closeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._closeRequest = closeRequest;
    });
    const writer = stream._writer;
    if (writer !== undefined && stream._backpressure && state === 'writable') {
      defaultWriterReadyPromiseResolve(writer);
    }
    WritableStreamDefaultControllerClose(stream._writableStreamController);
    return promise;
  }
  // WritableStream API exposed for controllers.
  function WritableStreamAddWriteRequest(stream) {
    const promise = newPromise((resolve, reject) => {
      const writeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._writeRequests.push(writeRequest);
    });
    return promise;
  }
  function WritableStreamDealWithRejection(stream, error) {
    const state = stream._state;
    if (state === 'writable') {
      WritableStreamStartErroring(stream, error);
      return;
    }
    WritableStreamFinishErroring(stream);
  }
  function WritableStreamStartErroring(stream, reason) {
    const controller = stream._writableStreamController;
    stream._state = 'erroring';
    stream._storedError = reason;
    const writer = stream._writer;
    if (writer !== undefined) {
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
    }
    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
      WritableStreamFinishErroring(stream);
    }
  }
  function WritableStreamFinishErroring(stream) {
    stream._state = 'errored';
    stream._writableStreamController[ErrorSteps]();
    const storedError = stream._storedError;
    stream._writeRequests.forEach(writeRequest => {
      writeRequest._reject(storedError);
    });
    stream._writeRequests = new SimpleQueue();
    if (stream._pendingAbortRequest === undefined) {
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const abortRequest = stream._pendingAbortRequest;
    stream._pendingAbortRequest = undefined;
    if (abortRequest._wasAlreadyErroring) {
      abortRequest._reject(storedError);
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
    uponPromise(promise, () => {
      abortRequest._resolve();
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    }, reason => {
      abortRequest._reject(reason);
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    });
  }
  function WritableStreamFinishInFlightWrite(stream) {
    stream._inFlightWriteRequest._resolve(undefined);
    stream._inFlightWriteRequest = undefined;
  }
  function WritableStreamFinishInFlightWriteWithError(stream, error) {
    stream._inFlightWriteRequest._reject(error);
    stream._inFlightWriteRequest = undefined;
    WritableStreamDealWithRejection(stream, error);
  }
  function WritableStreamFinishInFlightClose(stream) {
    stream._inFlightCloseRequest._resolve(undefined);
    stream._inFlightCloseRequest = undefined;
    const state = stream._state;
    if (state === 'erroring') {
      // The error was too late to do anything, so it is ignored.
      stream._storedError = undefined;
      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._resolve();
        stream._pendingAbortRequest = undefined;
      }
    }
    stream._state = 'closed';
    const writer = stream._writer;
    if (writer !== undefined) {
      defaultWriterClosedPromiseResolve(writer);
    }
  }
  function WritableStreamFinishInFlightCloseWithError(stream, error) {
    stream._inFlightCloseRequest._reject(error);
    stream._inFlightCloseRequest = undefined;
    // Never execute sink abort() after sink close().
    if (stream._pendingAbortRequest !== undefined) {
      stream._pendingAbortRequest._reject(error);
      stream._pendingAbortRequest = undefined;
    }
    WritableStreamDealWithRejection(stream, error);
  }
  // TODO(ricea): Fix alphabetical order.
  function WritableStreamCloseQueuedOrInFlight(stream) {
    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamHasOperationMarkedInFlight(stream) {
    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamMarkCloseRequestInFlight(stream) {
    stream._inFlightCloseRequest = stream._closeRequest;
    stream._closeRequest = undefined;
  }
  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
    stream._inFlightWriteRequest = stream._writeRequests.shift();
  }
  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
    if (stream._closeRequest !== undefined) {
      stream._closeRequest._reject(stream._storedError);
      stream._closeRequest = undefined;
    }
    const writer = stream._writer;
    if (writer !== undefined) {
      defaultWriterClosedPromiseReject(writer, stream._storedError);
    }
  }
  function WritableStreamUpdateBackpressure(stream, backpressure) {
    const writer = stream._writer;
    if (writer !== undefined && backpressure !== stream._backpressure) {
      if (backpressure) {
        defaultWriterReadyPromiseReset(writer);
      } else {
        defaultWriterReadyPromiseResolve(writer);
      }
    }
    stream._backpressure = backpressure;
  }
  /**
   * A default writer vended by a {@link WritableStream}.
   *
   * @public
   */
  class WritableStreamDefaultWriter {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
      assertWritableStream(stream, 'First parameter');
      if (IsWritableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive writing by another writer');
      }
      this._ownerWritableStream = stream;
      stream._writer = this;
      const state = stream._state;
      if (state === 'writable') {
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
          defaultWriterReadyPromiseInitialize(this);
        } else {
          defaultWriterReadyPromiseInitializeAsResolved(this);
        }
        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'erroring') {
        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'closed') {
        defaultWriterReadyPromiseInitializeAsResolved(this);
        defaultWriterClosedPromiseInitializeAsResolved(this);
      } else {
        const storedError = stream._storedError;
        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
      }
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
     * the writerâs lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * Returns the desired size to fill the streamâs internal queue. It can be negative, if the queue is over-full.
     * A producer can use this information to determine the right amount of data to write.
     *
     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
     * the writerâs lock is released.
     */
    get desiredSize() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw defaultWriterBrandCheckException('desiredSize');
      }
      if (this._ownerWritableStream === undefined) {
        throw defaultWriterLockException('desiredSize');
      }
      return WritableStreamDefaultWriterGetDesiredSize(this);
    }
    /**
     * Returns a promise that will be fulfilled when the desired size to fill the streamâs internal queue transitions
     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
     * back to zero or below, the getter will return a new promise that stays pending until the next transition.
     *
     * If the stream becomes errored or aborted, or the writerâs lock is released, the returned promise will become
     * rejected.
     */
    get ready() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
      }
      return this._readyPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
     */
    abort(reason = undefined) {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
      }
      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('abort'));
      }
      return WritableStreamDefaultWriterAbort(this, reason);
    }
    /**
     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
     */
    close() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('close'));
      }
      const stream = this._ownerWritableStream;
      if (stream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('close'));
      }
      if (WritableStreamCloseQueuedOrInFlight(stream)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }
      return WritableStreamDefaultWriterClose(this);
    }
    /**
     * Releases the writerâs lock on the corresponding stream. After the lock is released, the writer is no longer active.
     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
     * now on; otherwise, the writer will appear closed.
     *
     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
     * Itâs not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
     * other producers from writing in an interleaved manner.
     */
    releaseLock() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw defaultWriterBrandCheckException('releaseLock');
      }
      const stream = this._ownerWritableStream;
      if (stream === undefined) {
        return;
      }
      WritableStreamDefaultWriterRelease(this);
    }
    write(chunk = undefined) {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('write'));
      }
      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('write to'));
      }
      return WritableStreamDefaultWriterWrite(this, chunk);
    }
  }
  Object.defineProperties(WritableStreamDefaultWriter.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    write: {
      enumerable: true
    },
    closed: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    },
    ready: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultWriter',
      configurable: true
    });
  }
  // Abstract operations for the WritableStreamDefaultWriter.
  function IsWritableStreamDefaultWriter(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
      return false;
    }
    return x instanceof WritableStreamDefaultWriter;
  }
  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
  function WritableStreamDefaultWriterAbort(writer, reason) {
    const stream = writer._ownerWritableStream;
    return WritableStreamAbort(stream, reason);
  }
  function WritableStreamDefaultWriterClose(writer) {
    const stream = writer._ownerWritableStream;
    return WritableStreamClose(stream);
  }
  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
    const stream = writer._ownerWritableStream;
    const state = stream._state;
    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseResolvedWith(undefined);
    }
    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    return WritableStreamDefaultWriterClose(writer);
  }
  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
    if (writer._closedPromiseState === 'pending') {
      defaultWriterClosedPromiseReject(writer, error);
    } else {
      defaultWriterClosedPromiseResetToRejected(writer, error);
    }
  }
  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
    if (writer._readyPromiseState === 'pending') {
      defaultWriterReadyPromiseReject(writer, error);
    } else {
      defaultWriterReadyPromiseResetToRejected(writer, error);
    }
  }
  function WritableStreamDefaultWriterGetDesiredSize(writer) {
    const stream = writer._ownerWritableStream;
    const state = stream._state;
    if (state === 'errored' || state === 'erroring') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
  }
  function WritableStreamDefaultWriterRelease(writer) {
    const stream = writer._ownerWritableStream;
    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
    // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
    // rejected until afterwards. This means that simply testing state will not work.
    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
    stream._writer = undefined;
    writer._ownerWritableStream = undefined;
  }
  function WritableStreamDefaultWriterWrite(writer, chunk) {
    const stream = writer._ownerWritableStream;
    const controller = stream._writableStreamController;
    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
    if (stream !== writer._ownerWritableStream) {
      return promiseRejectedWith(defaultWriterLockException('write to'));
    }
    const state = stream._state;
    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
    }
    if (state === 'erroring') {
      return promiseRejectedWith(stream._storedError);
    }
    const promise = WritableStreamAddWriteRequest(stream);
    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
    return promise;
  }
  const closeSentinel = {};
  /**
   * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
   *
   * @public
   */
  class WritableStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
     *
     * @deprecated
     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
     */
    get abortReason() {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('abortReason');
      }
      return this._abortReason;
    }
    /**
     * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
     */
    get signal() {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('signal');
      }
      if (this._abortController === undefined) {
        // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
        // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
        // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
        throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
      }
      return this._abortController.signal;
    }
    /**
     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
     *
     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
     * normal lifecycle of interactions with the underlying sink.
     */
    error(e = undefined) {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('error');
      }
      const state = this._controlledWritableStream._state;
      if (state !== 'writable') {
        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
        // just treat it as a no-op.
        return;
      }
      WritableStreamDefaultControllerError(this, e);
    }
    /** @internal */
    [AbortSteps](reason) {
      const result = this._abortAlgorithm(reason);
      WritableStreamDefaultControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [ErrorSteps]() {
      ResetQueue(this);
    }
  }
  Object.defineProperties(WritableStreamDefaultController.prototype, {
    abortReason: {
      enumerable: true
    },
    signal: {
      enumerable: true
    },
    error: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultController',
      configurable: true
    });
  }
  // Abstract operations implementing interface required by the WritableStream.
  function IsWritableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
      return false;
    }
    return x instanceof WritableStreamDefaultController;
  }
  function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledWritableStream = stream;
    stream._writableStreamController = controller;
    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._abortReason = undefined;
    controller._abortController = createAbortController();
    controller._started = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._writeAlgorithm = writeAlgorithm;
    controller._closeAlgorithm = closeAlgorithm;
    controller._abortAlgorithm = abortAlgorithm;
    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
    const startResult = startAlgorithm();
    const startPromise = promiseResolvedWith(startResult);
    uponPromise(startPromise, () => {
      controller._started = true;
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, r => {
      controller._started = true;
      WritableStreamDealWithRejection(stream, r);
    });
  }
  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
    const controller = Object.create(WritableStreamDefaultController.prototype);
    let startAlgorithm = () => undefined;
    let writeAlgorithm = () => promiseResolvedWith(undefined);
    let closeAlgorithm = () => promiseResolvedWith(undefined);
    let abortAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingSink.start !== undefined) {
      startAlgorithm = () => underlyingSink.start(controller);
    }
    if (underlyingSink.write !== undefined) {
      writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
    }
    if (underlyingSink.close !== undefined) {
      closeAlgorithm = () => underlyingSink.close();
    }
    if (underlyingSink.abort !== undefined) {
      abortAlgorithm = reason => underlyingSink.abort(reason);
    }
    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  }
  // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
  function WritableStreamDefaultControllerClearAlgorithms(controller) {
    controller._writeAlgorithm = undefined;
    controller._closeAlgorithm = undefined;
    controller._abortAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  }
  function WritableStreamDefaultControllerClose(controller) {
    EnqueueValueWithSize(controller, closeSentinel, 0);
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
    try {
      return controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
      return 1;
    }
  }
  function WritableStreamDefaultControllerGetDesiredSize(controller) {
    return controller._strategyHWM - controller._queueTotalSize;
  }
  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
    try {
      EnqueueValueWithSize(controller, chunk, chunkSize);
    } catch (enqueueE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      return;
    }
    const stream = controller._controlledWritableStream;
    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
      const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  // Abstract operations for the WritableStreamDefaultController.
  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
    const stream = controller._controlledWritableStream;
    if (!controller._started) {
      return;
    }
    if (stream._inFlightWriteRequest !== undefined) {
      return;
    }
    const state = stream._state;
    if (state === 'erroring') {
      WritableStreamFinishErroring(stream);
      return;
    }
    if (controller._queue.length === 0) {
      return;
    }
    const value = PeekQueueValue(controller);
    if (value === closeSentinel) {
      WritableStreamDefaultControllerProcessClose(controller);
    } else {
      WritableStreamDefaultControllerProcessWrite(controller, value);
    }
  }
  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
    if (controller._controlledWritableStream._state === 'writable') {
      WritableStreamDefaultControllerError(controller, error);
    }
  }
  function WritableStreamDefaultControllerProcessClose(controller) {
    const stream = controller._controlledWritableStream;
    WritableStreamMarkCloseRequestInFlight(stream);
    DequeueValue(controller);
    const sinkClosePromise = controller._closeAlgorithm();
    WritableStreamDefaultControllerClearAlgorithms(controller);
    uponPromise(sinkClosePromise, () => {
      WritableStreamFinishInFlightClose(stream);
    }, reason => {
      WritableStreamFinishInFlightCloseWithError(stream, reason);
    });
  }
  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
    const stream = controller._controlledWritableStream;
    WritableStreamMarkFirstWriteRequestInFlight(stream);
    const sinkWritePromise = controller._writeAlgorithm(chunk);
    uponPromise(sinkWritePromise, () => {
      WritableStreamFinishInFlightWrite(stream);
      const state = stream._state;
      DequeueValue(controller);
      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, reason => {
      if (stream._state === 'writable') {
        WritableStreamDefaultControllerClearAlgorithms(controller);
      }
      WritableStreamFinishInFlightWriteWithError(stream, reason);
    });
  }
  function WritableStreamDefaultControllerGetBackpressure(controller) {
    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
    return desiredSize <= 0;
  }
  // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
  function WritableStreamDefaultControllerError(controller, error) {
    const stream = controller._controlledWritableStream;
    WritableStreamDefaultControllerClearAlgorithms(controller);
    WritableStreamStartErroring(stream, error);
  }
  // Helper functions for the WritableStream.
  function streamBrandCheckException$2(name) {
    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
  }
  // Helper functions for the WritableStreamDefaultController.
  function defaultControllerBrandCheckException$2(name) {
    return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
  }
  // Helper functions for the WritableStreamDefaultWriter.
  function defaultWriterBrandCheckException(name) {
    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
  }
  function defaultWriterLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released writer');
  }
  function defaultWriterClosedPromiseInitialize(writer) {
    writer._closedPromise = newPromise((resolve, reject) => {
      writer._closedPromise_resolve = resolve;
      writer._closedPromise_reject = reject;
      writer._closedPromiseState = 'pending';
    });
  }
  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseReject(writer, reason);
  }
  function defaultWriterClosedPromiseInitializeAsResolved(writer) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseResolve(writer);
  }
  function defaultWriterClosedPromiseReject(writer, reason) {
    if (writer._closedPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(writer._closedPromise);
    writer._closedPromise_reject(reason);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'rejected';
  }
  function defaultWriterClosedPromiseResetToRejected(writer, reason) {
    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
  }
  function defaultWriterClosedPromiseResolve(writer) {
    if (writer._closedPromise_resolve === undefined) {
      return;
    }
    writer._closedPromise_resolve(undefined);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'resolved';
  }
  function defaultWriterReadyPromiseInitialize(writer) {
    writer._readyPromise = newPromise((resolve, reject) => {
      writer._readyPromise_resolve = resolve;
      writer._readyPromise_reject = reject;
    });
    writer._readyPromiseState = 'pending';
  }
  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseReject(writer, reason);
  }
  function defaultWriterReadyPromiseInitializeAsResolved(writer) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseResolve(writer);
  }
  function defaultWriterReadyPromiseReject(writer, reason) {
    if (writer._readyPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(writer._readyPromise);
    writer._readyPromise_reject(reason);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'rejected';
  }
  function defaultWriterReadyPromiseReset(writer) {
    defaultWriterReadyPromiseInitialize(writer);
  }
  function defaultWriterReadyPromiseResetToRejected(writer, reason) {
    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
  }
  function defaultWriterReadyPromiseResolve(writer) {
    if (writer._readyPromise_resolve === undefined) {
      return;
    }
    writer._readyPromise_resolve(undefined);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'fulfilled';
  }

  /// <reference lib="dom" />
  const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;

  /// <reference types="node" />
  function isDOMExceptionConstructor(ctor) {
    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
      return false;
    }
    try {
      new ctor();
      return true;
    } catch (_a) {
      return false;
    }
  }
  function createDOMExceptionPolyfill() {
    // eslint-disable-next-line no-shadow
    const ctor = function DOMException(message, name) {
      this.message = message || '';
      this.name = name || 'Error';
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    };
    ctor.prototype = Object.create(Error.prototype);
    Object.defineProperty(ctor.prototype, 'constructor', {
      value: ctor,
      writable: true,
      configurable: true
    });
    return ctor;
  }
  // eslint-disable-next-line no-redeclare
  const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
    const reader = AcquireReadableStreamDefaultReader(source);
    const writer = AcquireWritableStreamDefaultWriter(dest);
    source._disturbed = true;
    let shuttingDown = false;
    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
    let currentWrite = promiseResolvedWith(undefined);
    return newPromise((resolve, reject) => {
      let abortAlgorithm;
      if (signal !== undefined) {
        abortAlgorithm = () => {
          const error = new DOMException$1('Aborted', 'AbortError');
          const actions = [];
          if (!preventAbort) {
            actions.push(() => {
              if (dest._state === 'writable') {
                return WritableStreamAbort(dest, error);
              }
              return promiseResolvedWith(undefined);
            });
          }
          if (!preventCancel) {
            actions.push(() => {
              if (source._state === 'readable') {
                return ReadableStreamCancel(source, error);
              }
              return promiseResolvedWith(undefined);
            });
          }
          shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
        };
        if (signal.aborted) {
          abortAlgorithm();
          return;
        }
        signal.addEventListener('abort', abortAlgorithm);
      }
      // Using reader and writer, read all chunks from this and write them to dest
      // - Backpressure must be enforced
      // - Shutdown must stop all activity
      function pipeLoop() {
        return newPromise((resolveLoop, rejectLoop) => {
          function next(done) {
            if (done) {
              resolveLoop();
            } else {
              // Use `PerformPromiseThen` instead of `uponPromise` to avoid
              // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
              PerformPromiseThen(pipeStep(), next, rejectLoop);
            }
          }
          next(false);
        });
      }
      function pipeStep() {
        if (shuttingDown) {
          return promiseResolvedWith(true);
        }
        return PerformPromiseThen(writer._readyPromise, () => {
          return newPromise((resolveRead, rejectRead) => {
            ReadableStreamDefaultReaderRead(reader, {
              _chunkSteps: chunk => {
                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                resolveRead(false);
              },
              _closeSteps: () => resolveRead(true),
              _errorSteps: rejectRead
            });
          });
        });
      }
      // Errors must be propagated forward
      isOrBecomesErrored(source, reader._closedPromise, storedError => {
        if (!preventAbort) {
          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
        } else {
          shutdown(true, storedError);
        }
      });
      // Errors must be propagated backward
      isOrBecomesErrored(dest, writer._closedPromise, storedError => {
        if (!preventCancel) {
          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
        } else {
          shutdown(true, storedError);
        }
      });
      // Closing must be propagated forward
      isOrBecomesClosed(source, reader._closedPromise, () => {
        if (!preventClose) {
          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
        } else {
          shutdown();
        }
      });
      // Closing must be propagated backward
      if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
        if (!preventCancel) {
          shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
        } else {
          shutdown(true, destClosed);
        }
      }
      setPromiseIsHandledToTrue(pipeLoop());
      function waitForWritesToFinish() {
        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
        // for that too.
        const oldCurrentWrite = currentWrite;
        return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
      }
      function isOrBecomesErrored(stream, promise, action) {
        if (stream._state === 'errored') {
          action(stream._storedError);
        } else {
          uponRejection(promise, action);
        }
      }
      function isOrBecomesClosed(stream, promise, action) {
        if (stream._state === 'closed') {
          action();
        } else {
          uponFulfillment(promise, action);
        }
      }
      function shutdownWithAction(action, originalIsError, originalError) {
        if (shuttingDown) {
          return;
        }
        shuttingDown = true;
        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), doTheRest);
        } else {
          doTheRest();
        }
        function doTheRest() {
          uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
        }
      }
      function shutdown(isError, error) {
        if (shuttingDown) {
          return;
        }
        shuttingDown = true;
        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
        } else {
          finalize(isError, error);
        }
      }
      function finalize(isError, error) {
        WritableStreamDefaultWriterRelease(writer);
        ReadableStreamReaderGenericRelease(reader);
        if (signal !== undefined) {
          signal.removeEventListener('abort', abortAlgorithm);
        }
        if (isError) {
          reject(error);
        } else {
          resolve(undefined);
        }
      }
    });
  }

  /**
   * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
   *
   * @public
   */
  class ReadableStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
     */
    get desiredSize() {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('desiredSize');
      }
      return ReadableStreamDefaultControllerGetDesiredSize(this);
    }
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */
    close() {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('close');
      }
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits close');
      }
      ReadableStreamDefaultControllerClose(this);
    }
    enqueue(chunk = undefined) {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('enqueue');
      }
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits enqueue');
      }
      return ReadableStreamDefaultControllerEnqueue(this, chunk);
    }
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */
    error(e = undefined) {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('error');
      }
      ReadableStreamDefaultControllerError(this, e);
    }
    /** @internal */
    [CancelSteps](reason) {
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      ReadableStreamDefaultControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [PullSteps](readRequest) {
      const stream = this._controlledReadableStream;
      if (this._queue.length > 0) {
        const chunk = DequeueValue(this);
        if (this._closeRequested && this._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(this);
          ReadableStreamClose(stream);
        } else {
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
        readRequest._chunkSteps(chunk);
      } else {
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableStreamDefaultControllerCallPullIfNeeded(this);
      }
    }
  }
  Object.defineProperties(ReadableStreamDefaultController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultController',
      configurable: true
    });
  }
  // Abstract operations for the ReadableStreamDefaultController.
  function IsReadableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
      return false;
    }
    return x instanceof ReadableStreamDefaultController;
  }
  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
    if (!shouldPull) {
      return;
    }
    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }
    controller._pulling = true;
    const pullPromise = controller._pullAlgorithm();
    uponPromise(pullPromise, () => {
      controller._pulling = false;
      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
    }, e => {
      ReadableStreamDefaultControllerError(controller, e);
    });
  }
  function ReadableStreamDefaultControllerShouldCallPull(controller) {
    const stream = controller._controlledReadableStream;
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return false;
    }
    if (!controller._started) {
      return false;
    }
    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }
    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
    if (desiredSize > 0) {
      return true;
    }
    return false;
  }
  function ReadableStreamDefaultControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  }
  // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
  function ReadableStreamDefaultControllerClose(controller) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }
    const stream = controller._controlledReadableStream;
    controller._closeRequested = true;
    if (controller._queue.length === 0) {
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
  }
  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }
    const stream = controller._controlledReadableStream;
    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      ReadableStreamFulfillReadRequest(stream, chunk, false);
    } else {
      let chunkSize;
      try {
        chunkSize = controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        ReadableStreamDefaultControllerError(controller, chunkSizeE);
        throw chunkSizeE;
      }
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        ReadableStreamDefaultControllerError(controller, enqueueE);
        throw enqueueE;
      }
    }
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }
  function ReadableStreamDefaultControllerError(controller, e) {
    const stream = controller._controlledReadableStream;
    if (stream._state !== 'readable') {
      return;
    }
    ResetQueue(controller);
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }
  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
    const state = controller._controlledReadableStream._state;
    if (state === 'errored') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return controller._strategyHWM - controller._queueTotalSize;
  }
  // This is used in the implementation of TransformStream.
  function ReadableStreamDefaultControllerHasBackpressure(controller) {
    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
      return false;
    }
    return true;
  }
  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
    const state = controller._controlledReadableStream._state;
    if (!controller._closeRequested && state === 'readable') {
      return true;
    }
    return false;
  }
  function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledReadableStream = stream;
    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._started = false;
    controller._closeRequested = false;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    stream._readableStreamController = controller;
    const startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), () => {
      controller._started = true;
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }, r => {
      ReadableStreamDefaultControllerError(controller, r);
    });
  }
  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
    const controller = Object.create(ReadableStreamDefaultController.prototype);
    let startAlgorithm = () => undefined;
    let pullAlgorithm = () => promiseResolvedWith(undefined);
    let cancelAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingSource.start !== undefined) {
      startAlgorithm = () => underlyingSource.start(controller);
    }
    if (underlyingSource.pull !== undefined) {
      pullAlgorithm = () => underlyingSource.pull(controller);
    }
    if (underlyingSource.cancel !== undefined) {
      cancelAlgorithm = reason => underlyingSource.cancel(reason);
    }
    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  }
  // Helper functions for the ReadableStreamDefaultController.
  function defaultControllerBrandCheckException$1(name) {
    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
  }
  function ReadableStreamTee(stream, cloneForBranch2) {
    if (IsReadableByteStreamController(stream._readableStreamController)) {
      return ReadableByteStreamTee(stream);
    }
    return ReadableStreamDefaultTee(stream);
  }
  function ReadableStreamDefaultTee(stream, cloneForBranch2) {
    const reader = AcquireReadableStreamDefaultReader(stream);
    let reading = false;
    let readAgain = false;
    let canceled1 = false;
    let canceled2 = false;
    let reason1;
    let reason2;
    let branch1;
    let branch2;
    let resolveCancelPromise;
    const cancelPromise = newPromise(resolve => {
      resolveCancelPromise = resolve;
    });
    function pullAlgorithm() {
      if (reading) {
        readAgain = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const readRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgain = false;
            const chunk1 = chunk;
            const chunk2 = chunk;
            // There is no way to access the cloning code right now in the reference implementation.
            // If we add one then we'll need an implementation for serializable objects.
            // if (!canceled2 && cloneForBranch2) {
            //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
            // }
            if (!canceled1) {
              ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
            }
            if (!canceled2) {
              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
            }
            reading = false;
            if (readAgain) {
              pullAlgorithm();
            }
          });
        },
        _closeSteps: () => {
          reading = false;
          if (!canceled1) {
            ReadableStreamDefaultControllerClose(branch1._readableStreamController);
          }
          if (!canceled2) {
            ReadableStreamDefaultControllerClose(branch2._readableStreamController);
          }
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promiseResolvedWith(undefined);
    }
    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;
      if (canceled2) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;
      if (canceled1) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function startAlgorithm() {
      // do nothing
    }
    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
    uponRejection(reader._closedPromise, r => {
      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
      if (!canceled1 || !canceled2) {
        resolveCancelPromise(undefined);
      }
    });
    return [branch1, branch2];
  }
  function ReadableByteStreamTee(stream) {
    let reader = AcquireReadableStreamDefaultReader(stream);
    let reading = false;
    let readAgainForBranch1 = false;
    let readAgainForBranch2 = false;
    let canceled1 = false;
    let canceled2 = false;
    let reason1;
    let reason2;
    let branch1;
    let branch2;
    let resolveCancelPromise;
    const cancelPromise = newPromise(resolve => {
      resolveCancelPromise = resolve;
    });
    function forwardReaderError(thisReader) {
      uponRejection(thisReader._closedPromise, r => {
        if (thisReader !== reader) {
          return;
        }
        ReadableByteStreamControllerError(branch1._readableStreamController, r);
        ReadableByteStreamControllerError(branch2._readableStreamController, r);
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
      });
    }
    function pullWithDefaultReader() {
      if (IsReadableStreamBYOBReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamDefaultReader(stream);
        forwardReaderError(reader);
      }
      const readRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            const chunk1 = chunk;
            let chunk2 = chunk;
            if (!canceled1 && !canceled2) {
              try {
                chunk2 = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }
            }
            if (!canceled1) {
              ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
            }
            if (!canceled2) {
              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
            }
            reading = false;
            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: () => {
          reading = false;
          if (!canceled1) {
            ReadableByteStreamControllerClose(branch1._readableStreamController);
          }
          if (!canceled2) {
            ReadableByteStreamControllerClose(branch2._readableStreamController);
          }
          if (branch1._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
          }
          if (branch2._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
          }
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
    }
    function pullWithBYOBReader(view, forBranch2) {
      if (IsReadableStreamDefaultReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamBYOBReader(stream);
        forwardReaderError(reader);
      }
      const byobBranch = forBranch2 ? branch2 : branch1;
      const otherBranch = forBranch2 ? branch1 : branch2;
      const readIntoRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            const byobCanceled = forBranch2 ? canceled2 : canceled1;
            const otherCanceled = forBranch2 ? canceled1 : canceled2;
            if (!otherCanceled) {
              let clonedChunk;
              try {
                clonedChunk = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }
              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
            } else if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            reading = false;
            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: chunk => {
          reading = false;
          const byobCanceled = forBranch2 ? canceled2 : canceled1;
          const otherCanceled = forBranch2 ? canceled1 : canceled2;
          if (!byobCanceled) {
            ReadableByteStreamControllerClose(byobBranch._readableStreamController);
          }
          if (!otherCanceled) {
            ReadableByteStreamControllerClose(otherBranch._readableStreamController);
          }
          if (chunk !== undefined) {
            if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
            }
          }
          if (!byobCanceled || !otherCanceled) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
    }
    function pull1Algorithm() {
      if (reading) {
        readAgainForBranch1 = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, false);
      }
      return promiseResolvedWith(undefined);
    }
    function pull2Algorithm() {
      if (reading) {
        readAgainForBranch2 = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, true);
      }
      return promiseResolvedWith(undefined);
    }
    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;
      if (canceled2) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;
      if (canceled1) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function startAlgorithm() {
      return;
    }
    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
    forwardReaderError(reader);
    return [branch1, branch2];
  }
  function convertUnderlyingDefaultOrByteSource(source, context) {
    assertDictionary(source, context);
    const original = source;
    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
    const cancel = original === null || original === void 0 ? void 0 : original.cancel;
    const pull = original === null || original === void 0 ? void 0 : original.pull;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const type = original === null || original === void 0 ? void 0 : original.type;
    return {
      autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
      cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
      pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
      start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
      type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
    };
  }
  function convertUnderlyingSourceCancelCallback(fn, original, context) {
    assertFunction(fn, context);
    return reason => promiseCall(fn, original, [reason]);
  }
  function convertUnderlyingSourcePullCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => promiseCall(fn, original, [controller]);
  }
  function convertUnderlyingSourceStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertReadableStreamType(type, context) {
    type = `${type}`;
    if (type !== 'bytes') {
      throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
    }
    return type;
  }
  function convertReaderOptions(options, context) {
    assertDictionary(options, context);
    const mode = options === null || options === void 0 ? void 0 : options.mode;
    return {
      mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
    };
  }
  function convertReadableStreamReaderMode(mode, context) {
    mode = `${mode}`;
    if (mode !== 'byob') {
      throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
    }
    return mode;
  }
  function convertIteratorOptions(options, context) {
    assertDictionary(options, context);
    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    return {
      preventCancel: Boolean(preventCancel)
    };
  }
  function convertPipeOptions(options, context) {
    assertDictionary(options, context);
    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
    const signal = options === null || options === void 0 ? void 0 : options.signal;
    if (signal !== undefined) {
      assertAbortSignal(signal, `${context} has member 'signal' that`);
    }
    return {
      preventAbort: Boolean(preventAbort),
      preventCancel: Boolean(preventCancel),
      preventClose: Boolean(preventClose),
      signal
    };
  }
  function assertAbortSignal(signal, context) {
    if (!isAbortSignal(signal)) {
      throw new TypeError(`${context} is not an AbortSignal.`);
    }
  }
  function convertReadableWritablePair(pair, context) {
    assertDictionary(pair, context);
    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
    assertRequiredField(readable, 'readable', 'ReadableWritablePair');
    assertReadableStream(readable, `${context} has member 'readable' that`);
    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
    assertRequiredField(writable, 'writable', 'ReadableWritablePair');
    assertWritableStream(writable, `${context} has member 'writable' that`);
    return {
      readable,
      writable
    };
  }

  /**
   * A readable stream represents a source of data, from which you can read.
   *
   * @public
   */
  class ReadableStream {
    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
      if (rawUnderlyingSource === undefined) {
        rawUnderlyingSource = null;
      } else {
        assertObject(rawUnderlyingSource, 'First parameter');
      }
      const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
      InitializeReadableStream(this);
      if (underlyingSource.type === 'bytes') {
        if (strategy.size !== undefined) {
          throw new RangeError('The strategy for a byte stream cannot have a size function');
        }
        const highWaterMark = ExtractHighWaterMark(strategy, 0);
        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
      } else {
        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        const highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
      }
    }
    /**
     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
     */
    get locked() {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('locked');
      }
      return IsReadableStreamLocked(this);
    }
    /**
     * Cancels the stream, signaling a loss of interest in the stream by a consumer.
     *
     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
     * method, which might or might not use it.
     */
    cancel(reason = undefined) {
      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('cancel'));
      }
      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
      }
      return ReadableStreamCancel(this, reason);
    }
    getReader(rawOptions = undefined) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('getReader');
      }
      const options = convertReaderOptions(rawOptions, 'First parameter');
      if (options.mode === undefined) {
        return AcquireReadableStreamDefaultReader(this);
      }
      return AcquireReadableStreamBYOBReader(this);
    }
    pipeThrough(rawTransform, rawOptions = {}) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('pipeThrough');
      }
      assertRequiredArgument(rawTransform, 1, 'pipeThrough');
      const transform = convertReadableWritablePair(rawTransform, 'First parameter');
      const options = convertPipeOptions(rawOptions, 'Second parameter');
      if (IsReadableStreamLocked(this)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
      }
      if (IsWritableStreamLocked(transform.writable)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
      }
      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      setPromiseIsHandledToTrue(promise);
      return transform.readable;
    }
    pipeTo(destination, rawOptions = {}) {
      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
      }
      if (destination === undefined) {
        return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
      }
      if (!IsWritableStream(destination)) {
        return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
      }
      let options;
      try {
        options = convertPipeOptions(rawOptions, 'Second parameter');
      } catch (e) {
        return promiseRejectedWith(e);
      }
      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
      }
      if (IsWritableStreamLocked(destination)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
      }
      return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
    }
    /**
     * Tees this readable stream, returning a two-element array containing the two resulting branches as
     * new {@link ReadableStream} instances.
     *
     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
     * propagated to the stream's underlying source.
     *
     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
     * this could allow interference between the two branches.
     */
    tee() {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('tee');
      }
      const branches = ReadableStreamTee(this);
      return CreateArrayFromList(branches);
    }
    values(rawOptions = undefined) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('values');
      }
      const options = convertIteratorOptions(rawOptions, 'First parameter');
      return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
    }
  }
  Object.defineProperties(ReadableStream.prototype, {
    cancel: {
      enumerable: true
    },
    getReader: {
      enumerable: true
    },
    pipeThrough: {
      enumerable: true
    },
    pipeTo: {
      enumerable: true
    },
    tee: {
      enumerable: true
    },
    values: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStream',
      configurable: true
    });
  }
  if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
      value: ReadableStream.prototype.values,
      writable: true,
      configurable: true
    });
  }
  // Abstract operations for the ReadableStream.
  // Throws if and only if startAlgorithm throws.
  function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
    const stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    const controller = Object.create(ReadableStreamDefaultController.prototype);
    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  }
  // Throws if and only if startAlgorithm throws.
  function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
    const stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    const controller = Object.create(ReadableByteStreamController.prototype);
    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
    return stream;
  }
  function InitializeReadableStream(stream) {
    stream._state = 'readable';
    stream._reader = undefined;
    stream._storedError = undefined;
    stream._disturbed = false;
  }
  function IsReadableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
      return false;
    }
    return x instanceof ReadableStream;
  }
  function IsReadableStreamLocked(stream) {
    if (stream._reader === undefined) {
      return false;
    }
    return true;
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamCancel(stream, reason) {
    stream._disturbed = true;
    if (stream._state === 'closed') {
      return promiseResolvedWith(undefined);
    }
    if (stream._state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    ReadableStreamClose(stream);
    const reader = stream._reader;
    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
      reader._readIntoRequests.forEach(readIntoRequest => {
        readIntoRequest._closeSteps(undefined);
      });
      reader._readIntoRequests = new SimpleQueue();
    }
    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
    return transformPromiseWith(sourceCancelPromise, noop);
  }
  function ReadableStreamClose(stream) {
    stream._state = 'closed';
    const reader = stream._reader;
    if (reader === undefined) {
      return;
    }
    defaultReaderClosedPromiseResolve(reader);
    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(readRequest => {
        readRequest._closeSteps();
      });
      reader._readRequests = new SimpleQueue();
    }
  }
  function ReadableStreamError(stream, e) {
    stream._state = 'errored';
    stream._storedError = e;
    const reader = stream._reader;
    if (reader === undefined) {
      return;
    }
    defaultReaderClosedPromiseReject(reader, e);
    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(readRequest => {
        readRequest._errorSteps(e);
      });
      reader._readRequests = new SimpleQueue();
    } else {
      reader._readIntoRequests.forEach(readIntoRequest => {
        readIntoRequest._errorSteps(e);
      });
      reader._readIntoRequests = new SimpleQueue();
    }
  }
  // Helper functions for the ReadableStream.
  function streamBrandCheckException$1(name) {
    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
  }
  function convertQueuingStrategyInit(init, context) {
    assertDictionary(init, context);
    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
    return {
      highWaterMark: convertUnrestrictedDouble(highWaterMark)
    };
  }

  // The size function must not have a prototype property nor be a constructor
  const byteLengthSizeFunction = chunk => {
    return chunk.byteLength;
  };
  try {
    Object.defineProperty(byteLengthSizeFunction, 'name', {
      value: 'size',
      configurable: true
    });
  } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  }
  /**
   * A queuing strategy that counts the number of bytes in each chunk.
   *
   * @public
   */
  class ByteLengthQueuingStrategy {
    constructor(options) {
      assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
    }
    /**
     * Returns the high water mark provided to the constructor.
     */
    get highWaterMark() {
      if (!IsByteLengthQueuingStrategy(this)) {
        throw byteLengthBrandCheckException('highWaterMark');
      }
      return this._byteLengthQueuingStrategyHighWaterMark;
    }
    /**
     * Measures the size of `chunk` by returning the value of its `byteLength` property.
     */
    get size() {
      if (!IsByteLengthQueuingStrategy(this)) {
        throw byteLengthBrandCheckException('size');
      }
      return byteLengthSizeFunction;
    }
  }
  Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'ByteLengthQueuingStrategy',
      configurable: true
    });
  }
  // Helper functions for the ByteLengthQueuingStrategy.
  function byteLengthBrandCheckException(name) {
    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
  }
  function IsByteLengthQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
      return false;
    }
    return x instanceof ByteLengthQueuingStrategy;
  }

  // The size function must not have a prototype property nor be a constructor
  const countSizeFunction = () => {
    return 1;
  };
  try {
    Object.defineProperty(countSizeFunction, 'name', {
      value: 'size',
      configurable: true
    });
  } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  }
  /**
   * A queuing strategy that counts the number of chunks.
   *
   * @public
   */
  class CountQueuingStrategy {
    constructor(options) {
      assertRequiredArgument(options, 1, 'CountQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._countQueuingStrategyHighWaterMark = options.highWaterMark;
    }
    /**
     * Returns the high water mark provided to the constructor.
     */
    get highWaterMark() {
      if (!IsCountQueuingStrategy(this)) {
        throw countBrandCheckException('highWaterMark');
      }
      return this._countQueuingStrategyHighWaterMark;
    }
    /**
     * Measures the size of `chunk` by always returning 1.
     * This ensures that the total queue size is a count of the number of chunks in the queue.
     */
    get size() {
      if (!IsCountQueuingStrategy(this)) {
        throw countBrandCheckException('size');
      }
      return countSizeFunction;
    }
  }
  Object.defineProperties(CountQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'CountQueuingStrategy',
      configurable: true
    });
  }
  // Helper functions for the CountQueuingStrategy.
  function countBrandCheckException(name) {
    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
  }
  function IsCountQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
      return false;
    }
    return x instanceof CountQueuingStrategy;
  }
  function convertTransformer(original, context) {
    assertDictionary(original, context);
    const flush = original === null || original === void 0 ? void 0 : original.flush;
    const readableType = original === null || original === void 0 ? void 0 : original.readableType;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const transform = original === null || original === void 0 ? void 0 : original.transform;
    const writableType = original === null || original === void 0 ? void 0 : original.writableType;
    return {
      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
      readableType,
      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
      writableType
    };
  }
  function convertTransformerFlushCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => promiseCall(fn, original, [controller]);
  }
  function convertTransformerStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertTransformerTransformCallback(fn, original, context) {
    assertFunction(fn, context);
    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  }

  // Class TransformStream
  /**
   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
   * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
   * In a manner specific to the transform stream in question, writes to the writable side result in new data being
   * made available for reading from the readable side.
   *
   * @public
   */
  class TransformStream {
    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
      if (rawTransformer === undefined) {
        rawTransformer = null;
      }
      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
      const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
      const transformer = convertTransformer(rawTransformer, 'First parameter');
      if (transformer.readableType !== undefined) {
        throw new RangeError('Invalid readableType specified');
      }
      if (transformer.writableType !== undefined) {
        throw new RangeError('Invalid writableType specified');
      }
      const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
      const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
      let startPromise_resolve;
      const startPromise = newPromise(resolve => {
        startPromise_resolve = resolve;
      });
      InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
      if (transformer.start !== undefined) {
        startPromise_resolve(transformer.start(this._transformStreamController));
      } else {
        startPromise_resolve(undefined);
      }
    }
    /**
     * The readable side of the transform stream.
     */
    get readable() {
      if (!IsTransformStream(this)) {
        throw streamBrandCheckException('readable');
      }
      return this._readable;
    }
    /**
     * The writable side of the transform stream.
     */
    get writable() {
      if (!IsTransformStream(this)) {
        throw streamBrandCheckException('writable');
      }
      return this._writable;
    }
  }
  Object.defineProperties(TransformStream.prototype, {
    readable: {
      enumerable: true
    },
    writable: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStream',
      configurable: true
    });
  }
  function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
    function startAlgorithm() {
      return startPromise;
    }
    function writeAlgorithm(chunk) {
      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
    }
    function abortAlgorithm(reason) {
      return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
    }
    function closeAlgorithm() {
      return TransformStreamDefaultSinkCloseAlgorithm(stream);
    }
    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
    function pullAlgorithm() {
      return TransformStreamDefaultSourcePullAlgorithm(stream);
    }
    function cancelAlgorithm(reason) {
      TransformStreamErrorWritableAndUnblockWrite(stream, reason);
      return promiseResolvedWith(undefined);
    }
    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
    stream._backpressure = undefined;
    stream._backpressureChangePromise = undefined;
    stream._backpressureChangePromise_resolve = undefined;
    TransformStreamSetBackpressure(stream, true);
    stream._transformStreamController = undefined;
  }
  function IsTransformStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
      return false;
    }
    return x instanceof TransformStream;
  }
  // This is a no-op if both sides are already errored.
  function TransformStreamError(stream, e) {
    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
  }
  function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
    if (stream._backpressure) {
      // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
      // _backpressure is set.
      TransformStreamSetBackpressure(stream, false);
    }
  }
  function TransformStreamSetBackpressure(stream, backpressure) {
    // Passes also when called during construction.
    if (stream._backpressureChangePromise !== undefined) {
      stream._backpressureChangePromise_resolve();
    }
    stream._backpressureChangePromise = newPromise(resolve => {
      stream._backpressureChangePromise_resolve = resolve;
    });
    stream._backpressure = backpressure;
  }
  // Class TransformStreamDefaultController
  /**
   * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
   *
   * @public
   */
  class TransformStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the desired size to fill the readable sideâs internal queue. It can be negative, if the queue is over-full.
     */
    get desiredSize() {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('desiredSize');
      }
      const readableController = this._controlledTransformStream._readable._readableStreamController;
      return ReadableStreamDefaultControllerGetDesiredSize(readableController);
    }
    enqueue(chunk = undefined) {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('enqueue');
      }
      TransformStreamDefaultControllerEnqueue(this, chunk);
    }
    /**
     * Errors both the readable side and the writable side of the controlled transform stream, making all future
     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
     */
    error(reason = undefined) {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('error');
      }
      TransformStreamDefaultControllerError(this, reason);
    }
    /**
     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
     * transformer only needs to consume a portion of the chunks written to the writable side.
     */
    terminate() {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('terminate');
      }
      TransformStreamDefaultControllerTerminate(this);
    }
  }
  Object.defineProperties(TransformStreamDefaultController.prototype, {
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    terminate: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStreamDefaultController',
      configurable: true
    });
  }
  // Transform Stream Default Controller Abstract Operations
  function IsTransformStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
      return false;
    }
    return x instanceof TransformStreamDefaultController;
  }
  function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
    controller._controlledTransformStream = stream;
    stream._transformStreamController = controller;
    controller._transformAlgorithm = transformAlgorithm;
    controller._flushAlgorithm = flushAlgorithm;
  }
  function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
    const controller = Object.create(TransformStreamDefaultController.prototype);
    let transformAlgorithm = chunk => {
      try {
        TransformStreamDefaultControllerEnqueue(controller, chunk);
        return promiseResolvedWith(undefined);
      } catch (transformResultE) {
        return promiseRejectedWith(transformResultE);
      }
    };
    let flushAlgorithm = () => promiseResolvedWith(undefined);
    if (transformer.transform !== undefined) {
      transformAlgorithm = chunk => transformer.transform(chunk, controller);
    }
    if (transformer.flush !== undefined) {
      flushAlgorithm = () => transformer.flush(controller);
    }
    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
  }
  function TransformStreamDefaultControllerClearAlgorithms(controller) {
    controller._transformAlgorithm = undefined;
    controller._flushAlgorithm = undefined;
  }
  function TransformStreamDefaultControllerEnqueue(controller, chunk) {
    const stream = controller._controlledTransformStream;
    const readableController = stream._readable._readableStreamController;
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
      throw new TypeError('Readable side is not in a state that permits enqueue');
    }
    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
    // accept TransformStreamDefaultControllerEnqueue() calls.
    try {
      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
    } catch (e) {
      // This happens when readableStrategy.size() throws.
      TransformStreamErrorWritableAndUnblockWrite(stream, e);
      throw stream._readable._storedError;
    }
    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
    if (backpressure !== stream._backpressure) {
      TransformStreamSetBackpressure(stream, true);
    }
  }
  function TransformStreamDefaultControllerError(controller, e) {
    TransformStreamError(controller._controlledTransformStream, e);
  }
  function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
    const transformPromise = controller._transformAlgorithm(chunk);
    return transformPromiseWith(transformPromise, undefined, r => {
      TransformStreamError(controller._controlledTransformStream, r);
      throw r;
    });
  }
  function TransformStreamDefaultControllerTerminate(controller) {
    const stream = controller._controlledTransformStream;
    const readableController = stream._readable._readableStreamController;
    ReadableStreamDefaultControllerClose(readableController);
    const error = new TypeError('TransformStream terminated');
    TransformStreamErrorWritableAndUnblockWrite(stream, error);
  }
  // TransformStreamDefaultSink Algorithms
  function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
    const controller = stream._transformStreamController;
    if (stream._backpressure) {
      const backpressureChangePromise = stream._backpressureChangePromise;
      return transformPromiseWith(backpressureChangePromise, () => {
        const writable = stream._writable;
        const state = writable._state;
        if (state === 'erroring') {
          throw writable._storedError;
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      });
    }
    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
  }
  function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
    // errored.
    TransformStreamError(stream, reason);
    return promiseResolvedWith(undefined);
  }
  function TransformStreamDefaultSinkCloseAlgorithm(stream) {
    // stream._readable cannot change after construction, so caching it across a call to user code is safe.
    const readable = stream._readable;
    const controller = stream._transformStreamController;
    const flushPromise = controller._flushAlgorithm();
    TransformStreamDefaultControllerClearAlgorithms(controller);
    // Return a promise that is fulfilled with undefined on success.
    return transformPromiseWith(flushPromise, () => {
      if (readable._state === 'errored') {
        throw readable._storedError;
      }
      ReadableStreamDefaultControllerClose(readable._readableStreamController);
    }, r => {
      TransformStreamError(stream, r);
      throw readable._storedError;
    });
  }
  // TransformStreamDefaultSource Algorithms
  function TransformStreamDefaultSourcePullAlgorithm(stream) {
    // Invariant. Enforced by the promises returned by start() and pull().
    TransformStreamSetBackpressure(stream, false);
    // Prevent the next pull() call until there is backpressure.
    return stream._backpressureChangePromise;
  }
  // Helper functions for the TransformStreamDefaultController.
  function defaultControllerBrandCheckException(name) {
    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
  }
  // Helper functions for the TransformStream.
  function streamBrandCheckException(name) {
    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
  }
  exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
  exports.CountQueuingStrategy = CountQueuingStrategy;
  exports.ReadableByteStreamController = ReadableByteStreamController;
  exports.ReadableStream = ReadableStream;
  exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
  exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
  exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
  exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
  exports.TransformStream = TransformStream;
  exports.TransformStreamDefaultController = TransformStreamDefaultController;
  exports.WritableStream = WritableStream;
  exports.WritableStreamDefaultController = WritableStreamDefaultController;
  exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/fetch-blob/streams.cjs":
/*!*********************************************!*\
  !*** ./node_modules/fetch-blob/streams.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = __webpack_require__(/*! node:process */ "node:process")
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ "node:stream/web"))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
    Object.assign(globalThis, __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.es2018.js */ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"))
  }
}

try {
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = __webpack_require__(/*! buffer */ "buffer")
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
} catch (error) {}
/* c8 ignore end */


/***/ }),

/***/ "./node_modules/data-uri-to-buffer/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/data-uri-to-buffer/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataUriToBuffer: () => (/* binding */ dataUriToBuffer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  // strip newlines
  uri = uri.replace(/\r?\n/g, '');
  // split the URI up into the "metadata" and the "data" portions
  const firstComma = uri.indexOf(',');
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError('malformed data: URI');
  }
  // remove the "data:" scheme and parse the metadata
  const meta = uri.substring(5, firstComma).split(';');
  let charset = '';
  let base64 = false;
  const type = meta[0] || 'text/plain';
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === 'base64') {
      base64 = true;
    } else if (meta[i]) {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf('charset=') === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  // defaults to US-ASCII only if type is not provided
  if (!meta[0] && !charset.length) {
    typeFull += ';charset=US-ASCII';
    charset = 'US-ASCII';
  }
  // get the encoded data portion and decode URI-encoded chars
  const encoding = base64 ? 'base64' : 'ascii';
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  // set `.type` and `.typeFull` properties to MIME type
  buffer.type = type;
  buffer.typeFull = typeFull;
  // set the `.charset` property
  buffer.charset = charset;
  return buffer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataUriToBuffer);

/***/ }),

/***/ "./node_modules/fetch-blob/file.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/file.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");

const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #lastModified = 0;
  #name = '';

  /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */ // @ts-ignore
  constructor(fileBits, fileName, options = {}) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
    }
    super(fileBits, options);
    if (options === null) options = {};

    // Simulate WebIDL type casting for NaN value in lastModified option.
    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
    if (!Number.isNaN(lastModified)) {
      this.#lastModified = lastModified;
    }
    this.#name = String(fileName);
  }
  get name() {
    return this.#name;
  }
  get lastModified() {
    return this.#lastModified;
  }
  get [Symbol.toStringTag]() {
    return 'File';
  }
  static [Symbol.hasInstance](object) {
    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] && /^(File)$/.test(object[Symbol.toStringTag]);
  }
};

/** @type {typeof globalThis.File} */ // @ts-ignore
const File = _File;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);

/***/ }),

/***/ "./node_modules/fetch-blob/from.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/from.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   blobFrom: () => (/* binding */ blobFrom),
/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fileFrom: () => (/* binding */ fileFrom),
/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-domexception */ "./node_modules/node-domexception/index.js");
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ "./node_modules/fetch-blob/file.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");





const {
  stat
} = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises;

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const blobFromSync = (path, type) => fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<Blob>}
 */
const blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<File>}
 */
const fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const fileFromSync = (path, type) => fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);

// @ts-ignore
const fromBlob = (stat, path, type = '') => new _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], {
  type
});

// @ts-ignore
const fromFile = (stat, path, type = '') => new _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), {
  type,
  lastModified: stat.mtimeMs
});

/**
 * This is a blob backed up by a file on the disk
 * with minium requirement. Its wrapped around a Blob as a blobPart
 * so you have no direct access to this.
 *
 * @private
 */
class BlobDataItem {
  #path;
  #start;
  constructor(options) {
    this.#path = options.path;
    this.#start = options.start;
    this.size = options.size;
    this.lastModified = options.lastModified;
  }

  /**
   * Slicing arguments is first validated and formatted
   * to not be out of range by Blob.prototype.slice
   */
  slice(start, end) {
    return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
    });
  }
  async *stream() {
    const {
      mtimeMs
    } = await stat(this.#path);
    if (mtimeMs > this.lastModified) {
      throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');
    }
    yield* (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
    });
  }
  get [Symbol.toStringTag]() {
    return 'Blob';
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);


/***/ }),

/***/ "./node_modules/fetch-blob/index.js":
/*!******************************************!*\
  !*** ./node_modules/fetch-blob/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* binding */ Blob),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streams.cjs */ "./node_modules/fetch-blob/streams.cjs");
/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */

// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core



// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536;

/** @param {(Blob | Uint8Array)[]} parts */
async function* toIterator(parts, clone = true) {
  for (const part of parts) {
    if ('stream' in part) {
      yield* ( /** @type {AsyncIterableIterator<Uint8Array>} */part.stream());
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
      /* c8 ignore next 10 */
    } else {
      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
      let position = 0,
        b = /** @type {Blob} */part;
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
const _Blob = class Blob {
  /** @type {Array.<(Blob|Uint8Array)>} */
  #parts = [];
  #type = '';
  #size = 0;
  #endings = 'transparent';

  /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */
  constructor(blobParts = [], options = {}) {
    if (typeof blobParts !== 'object' || blobParts === null) {
      throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.');
    }
    if (typeof blobParts[Symbol.iterator] !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.');
    }
    if (typeof options !== 'object' && typeof options !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.');
    }
    if (options === null) options = {};
    const encoder = new TextEncoder();
    for (const element of blobParts) {
      let part;
      if (ArrayBuffer.isView(element)) {
        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
      } else if (element instanceof ArrayBuffer) {
        part = new Uint8Array(element.slice(0));
      } else if (element instanceof Blob) {
        part = element;
      } else {
        part = encoder.encode(`${element}`);
      }
      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
      this.#parts.push(part);
    }
    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`;
    const type = options.type === undefined ? '' : String(options.type);
    this.#type = /^[\x20-\x7E]*$/.test(type) ? type : '';
  }

  /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */
  get size() {
    return this.#size;
  }

  /**
   * The type property of a Blob object returns the MIME type of the file.
   */
  get type() {
    return this.#type;
  }

  /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */
  async text() {
    // More optimized than using this.arrayBuffer()
    // that requires twice as much ram
    const decoder = new TextDecoder();
    let str = '';
    for await (const part of toIterator(this.#parts, false)) {
      str += decoder.decode(part, {
        stream: true
      });
    }
    // Remaining
    str += decoder.decode();
    return str;
  }

  /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */
  async arrayBuffer() {
    // Easier way... Just a unnecessary overhead
    // const view = new Uint8Array(this.size);
    // await this.stream().getReader({mode: 'byob'}).read(view);
    // return view.buffer;

    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of toIterator(this.#parts, false)) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    const it = toIterator(this.#parts, true);
    return new globalThis.ReadableStream({
      // @ts-ignore
      type: 'bytes',
      async pull(ctrl) {
        const chunk = await it.next();
        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
      },
      async cancel() {
        await it.return();
      }
    });
  }

  /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */
  slice(start = 0, end = this.size, type = '') {
    const {
      size
    } = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = this.#parts;
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      // don't add the overflow to new blobParts
      if (added >= span) {
        break;
      }
      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size <= relativeStart) {
        // Skip the beginning and change the relative
        // start & end position as we skip the unwanted parts
        relativeStart -= size;
        relativeEnd -= size;
      } else {
        let chunk;
        if (ArrayBuffer.isView(part)) {
          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));
          added += chunk.byteLength;
        } else {
          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));
          added += chunk.size;
        }
        relativeEnd -= size;
        blobParts.push(chunk);
        relativeStart = 0; // All next sequential parts should start at 0
      }
    }
    const blob = new Blob([], {
      type: String(type).toLowerCase()
    });
    blob.#size = span;
    blob.#parts = blobParts;
    return blob;
  }
  get [Symbol.toStringTag]() {
    return 'Blob';
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(_Blob.prototype, {
  size: {
    enumerable: true
  },
  type: {
    enumerable: true
  },
  slice: {
    enumerable: true
  }
});

/** @type {typeof globalThis.Blob} */
const Blob = _Blob;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);

/***/ }),

/***/ "./node_modules/formdata-polyfill/esm.min.js":
/*!***************************************************!*\
  !*** ./node_modules/formdata-polyfill/esm.min.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   FormData: () => (/* binding */ FormData),
/* harmony export */   formDataToBlob: () => (/* binding */ formDataToBlob)
/* harmony export */ });
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fetch-blob/file.js */ "./node_modules/fetch-blob/file.js");
/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */



var {
    toStringTag: t,
    iterator: i,
    hasInstance: h
  } = Symbol,
  r = Math.random,
  m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
  f = (a, b, c) => (a += '', /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob', a), b.name !== c || b[t] == 'blob' ? new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]([b], c, b) : b] : [a, b + '']),
  e = (c, f) => (f ? c : c.replace(/\r?\n|\r/g, '\r\n')).replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22'),
  x = (n, a, e) => {
    if (a.length < e) {
      throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);
    }
  };
const File = fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/** @type {typeof globalThis.FormData} */
const FormData = class FormData {
  #d = [];
  constructor(...a) {
    if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
  }
  get [t]() {
    return 'FormData';
  }
  [i]() {
    return this.entries();
  }
  static [h](o) {
    return o && typeof o === 'object' && o[t] === 'FormData' && !m.some(m => typeof o[m] != 'function');
  }
  append(...a) {
    x('append', arguments, 2);
    this.#d.push(f(...a));
  }
  delete(a) {
    x('delete', arguments, 1);
    a += '';
    this.#d = this.#d.filter(([b]) => b !== a);
  }
  get(a) {
    x('get', arguments, 1);
    a += '';
    for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
    return null;
  }
  getAll(a, b) {
    x('getAll', arguments, 1);
    b = [];
    a += '';
    this.#d.forEach(c => c[0] === a && b.push(c[1]));
    return b;
  }
  has(a) {
    x('has', arguments, 1);
    a += '';
    return this.#d.some(b => b[0] === a);
  }
  forEach(a, b) {
    x('forEach', arguments, 1);
    for (var [c, d] of this) a.call(b, d, c, this);
  }
  set(...a) {
    x('set', arguments, 2);
    var b = [],
      c = !0;
    a = f(...a);
    this.#d.forEach(d => {
      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
    });
    c && b.push(a);
    this.#d = b;
  }
  *entries() {
    yield* this.#d;
  }
  *keys() {
    for (var [a] of this) yield a;
  }
  *values() {
    for (var [, a] of this) yield a;
  }
};

/** @param {FormData} F */
function formDataToBlob(F, B = fetch_blob__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  var b = `${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),
    c = [],
    p = `--${b}\r\nContent-Disposition: form-data; name="`;
  F.forEach((v, n) => typeof v == 'string' ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, '\r\n'));
  c.push(`--${b}--`);
  return new B(c, {
    type: "multipart/form-data; boundary=" + b
  });
}

/***/ }),

/***/ "./node_modules/ky-universal/index.js":
/*!********************************************!*\
  !*** ./node_modules/ky-universal/index.js ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTTPError: () => (/* binding */ HTTPError),
/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/index.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/request.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/response.js");
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abort-controller */ "./node_modules/abort-controller/dist/abort-controller.js");


const TEN_MEGABYTES = 1000 * 1000 * 10;
if (!globalThis.fetch) {
  globalThis.fetch = (url, options) => (0,node_fetch__WEBPACK_IMPORTED_MODULE_1__["default"])(url, {
    highWaterMark: TEN_MEGABYTES,
    ...options
  });
}
if (!globalThis.Headers) {
  globalThis.Headers = node_fetch__WEBPACK_IMPORTED_MODULE_2__["default"];
}
if (!globalThis.Request) {
  globalThis.Request = node_fetch__WEBPACK_IMPORTED_MODULE_3__["default"];
}
if (!globalThis.Response) {
  globalThis.Response = node_fetch__WEBPACK_IMPORTED_MODULE_4__["default"];
}
if (!globalThis.AbortController) {
  globalThis.AbortController = abort_controller__WEBPACK_IMPORTED_MODULE_0__;
}
if (!globalThis.ReadableStream) {
  try {
    globalThis.ReadableStream = await __webpack_require__.e(/*! import() */ "vendors-node_modules_web-streams-polyfill_dist_polyfill_es2018_min_js").then(__webpack_require__.t.bind(__webpack_require__, /*! web-streams-polyfill/ponyfill/es2018 */ "./node_modules/web-streams-polyfill/dist/polyfill.es2018.min.js", 19));
  } catch {}
}
const {
  default: ky,
  HTTPError,
  TimeoutError
} = await __webpack_require__.e(/*! import() */ "vendors-node_modules_ky_distribution_index_js").then(__webpack_require__.bind(__webpack_require__, /*! ky */ "./node_modules/ky/distribution/index.js"));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ky);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./node_modules/node-fetch/src/body.js":
/*!*********************************************!*\
  !*** ./node_modules/node-fetch/src/body.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   "default": () => (/* binding */ Body),
/* harmony export */   extractContentType: () => (/* binding */ extractContentType),
/* harmony export */   getTotalBytes: () => (/* binding */ getTotalBytes),
/* harmony export */   writeToStream: () => (/* binding */ writeToStream)
/* harmony export */ });
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors/base.js */ "./node_modules/node-fetch/src/errors/base.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */









const pipeline = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_0__.pipeline);
const INTERNALS = Symbol('Body internals');

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Body {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      // Body is undefined or null
      body = null;
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
      // Body is a URLSearchParams
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.toString());
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
      // Body is blob
    } else if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
      // Body is Buffer
    } else if (node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body)) {
      // Body is ArrayBuffer
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      // Body is ArrayBufferView
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
      // Body is stream
    } else if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
      // Body is FormData
      body = (0,formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.formDataToBlob)(body);
      boundary = body.type.split('=')[1];
    } else {
      // None of the above
      // coerce to string then buffer
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(String(body));
    }
    let stream = body;
    if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
      stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body);
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
      stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
      body.on('error', error_ => {
        const error = error_ instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error_ : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }

  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const {
      buffer,
      byteOffset,
      byteLength
    } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get('content-type');
    if (ct.startsWith('application/x-www-form-urlencoded')) {
      const formData = new formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const {
      toFormData
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_node-fetch_src_utils_multipart-parser_js").then(__webpack_require__.bind(__webpack_require__, /*! ./utils/multipart-parser.js */ "./node_modules/node-fetch/src/utils/multipart-parser.js"));
    return toFormData(this.body, ct);
  }

  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';
    const buf = await this.arrayBuffer();
    return new fetch_blob__WEBPACK_IMPORTED_MODULE_3__["default"]([buf], {
      type: ct
    });
  }

  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }

  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }

  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
}
Body.prototype.buffer = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
  body: {
    enumerable: true
  },
  bodyUsed: {
    enumerable: true
  },
  arrayBuffer: {
    enumerable: true
  },
  blob: {
    enumerable: true
  },
  json: {
    enumerable: true
  },
  text: {
    enumerable: true
  },
  data: {
    get: (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {}, 'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')
  }
});

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const {
    body
  } = data;

  // Body is null
  if (body === null) {
    return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
  }

  /* c8 ignore next 3 */
  if (!(body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__)) {
    return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
  }

  // Body is stream
  // get ready to actually consume the body
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every(c => typeof c === 'string')) {
        return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(accum.join(''));
      }
      return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
    }
  } else {
    throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed   instance       Response or Request instance
 * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
 * @return  Mixed
 */
const clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let {
    body
  } = instance[INTERNALS];

  // Don't allow cloning a used body
  if (instance.bodyUsed) {
    throw new Error('cannot clone body after it is used');
  }

  // Check that body is a stream and not form-data object
  // note: we can't clone the form-data object without having it as a dependency
  if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {
    // Tee instance body
    p1 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({
      highWaterMark
    });
    p2 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({
      highWaterMark
    });
    body.pipe(p1);
    body.pipe(p2);
    // Set instance body to teed body and return the other teed body
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
const getNonSpecFormDataBoundary = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(body => body.getBoundary(), 'form-data doesn\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param {any} body Any options.body input
 * @returns {string | null}
 */
const extractContentType = (body, request) => {
  // Body is null or undefined
  if (body === null) {
    return null;
  }

  // Body is string
  if (typeof body === 'string') {
    return 'text/plain;charset=UTF-8';
  }

  // Body is a URLSearchParams
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
    return 'application/x-www-form-urlencoded;charset=UTF-8';
  }

  // Body is blob
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
    return body.type || null;
  }

  // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
  if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body) || node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }

  // Detect form data input from form-data module
  if (body && typeof body.getBoundary === 'function') {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }

  // Body is stream - can't really do much about this
  if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
    return null;
  }

  // Body constructor defaults other things to string
  return 'text/plain;charset=UTF-8';
};

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param {any} obj.body Body object from the Body instance.
 * @returns {number | null}
 */
const getTotalBytes = request => {
  const {
    body
  } = request[INTERNALS];

  // Body is null or undefined
  if (body === null) {
    return 0;
  }

  // Body is Blob
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
    return body.size;
  }

  // Body is Buffer
  if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
    return body.length;
  }

  // Detect form data input from form-data module
  if (body && typeof body.getLengthSync === 'function') {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }

  // Body is stream
  return null;
};

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param {Stream.Writable} dest The stream to write to.
 * @param obj.body Body object from the Body instance.
 * @returns {Promise<void>}
 */
const writeToStream = async (dest, {
  body
}) => {
  if (body === null) {
    // Body is null
    dest.end();
  } else {
    // Body is stream
    await pipeline(body, dest);
  }
};

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/abort-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/abort-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");


/**
 * AbortError interface for cancelled requests
 */
class AbortError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
  constructor(message, type = 'aborted') {
    super(message, type);
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/base.js":
/*!****************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/base.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBaseError: () => (/* binding */ FetchBaseError)
/* harmony export */ });
class FetchBaseError extends Error {
  constructor(message, type) {
    super(message);
    // Hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/fetch-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/fetch-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchError: () => (/* binding */ FetchError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");


/**
 * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/

/**
 * FetchError interface for operational errors
 */
class FetchError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
    if (systemError) {
      // eslint-disable-next-line no-multi-assign
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/headers.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/headers.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Headers),
/* harmony export */   fromRawHeaders: () => (/* binding */ fromRawHeaders)
/* harmony export */ });
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:http */ "node:http");
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */




/* c8 ignore next 9 */
const validateHeaderName = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName === 'function' ? node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName : name => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_HTTP_TOKEN'
    });
    throw error;
  }
};

/* c8 ignore next 9 */
const validateHeaderValue = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue === 'function' ? node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_CHAR'
    });
    throw error;
  }
};

/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */
class Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    // Validate and normalize init object in [name, value(s)][]
    /** @type {string[][]} */
    let result = [];
    if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map(value => [name, value]));
      }
    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq
      // No op
    } else if (typeof init === 'object' && !node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      // eslint-disable-next-line no-eq-null, eqeqeq
      if (method == null) {
        // Record<ByteString, ByteString>
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== 'function') {
          throw new TypeError('Header pairs must be iterable');
        }

        // Sequence<sequence<ByteString>>
        // Note: per spec we have to first exhaust the lists then process them
        result = [...init].map(pair => {
          if (typeof pair !== 'object' || node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(pair)) {
            throw new TypeError('Each header pair must be an iterable object');
          }
          return [...pair];
        }).map(pair => {
          if (pair.length !== 2) {
            throw new TypeError('Each header pair must be a name/value tuple');
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
    }

    // Validate and lowercase
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : undefined;
    super(result);

    // Returning a Proxy that will lowercase key names, validate parameters and sort keys
    // eslint-disable-next-line no-constructor-return
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case 'append':
          case 'set':
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
            };
          case 'delete':
          case 'has':
          case 'getAll':
            return name => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
            };
          case 'keys':
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
    /* c8 ignore next */
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(', ');
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = undefined) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }

  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }

  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }

  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      // Http.request() only supports string as Host header.
      // This hack makes specifying custom Host header possible.
      if (key === 'host') {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
}

/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */
Object.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
  result[property] = {
    enumerable: true
  };
  return result;
}, {}));

/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */
function fromRawHeaders(headers = []) {
  return new Headers(headers
  // Split into pairs
  .reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}

/***/ }),

/***/ "./node_modules/node-fetch/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-fetch/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* reexport safe */ _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError),
/* harmony export */   Blob: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.Blob),
/* harmony export */   FetchError: () => (/* reexport safe */ _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError),
/* harmony export */   File: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.File),
/* harmony export */   FormData: () => (/* reexport safe */ formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__.FormData),
/* harmony export */   Headers: () => (/* reexport safe */ _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Request: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Response: () => (/* reexport safe */ _response_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   blobFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFrom),
/* harmony export */   blobFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFromSync),
/* harmony export */   "default": () => (/* binding */ fetch),
/* harmony export */   fileFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFrom),
/* harmony export */   fileFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFromSync),
/* harmony export */   isRedirect: () => (/* reexport safe */ _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)
/* harmony export */ });
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ "node:https");
/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:zlib */ "node:zlib");
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! data-uri-to-buffer */ "./node_modules/data-uri-to-buffer/dist/index.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./response.js */ "./node_modules/node-fetch/src/response.js");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./request.js */ "./node_modules/node-fetch/src/request.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors/abort-error.js */ "./node_modules/node-fetch/src/errors/abort-error.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/* harmony import */ var fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fetch-blob/from.js */ "./node_modules/fetch-blob/from.js");
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */




















const supportedSchemas = new Set(['data:', 'http:', 'https:']);

/**
 * Fetch function
 *
 * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
 * @param   {*} [options_] - Fetch options
 * @return  {Promise<import('./response').default>}
 */
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    // Build request object
    const request = new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](url, options_);
    const {
      parsedURL,
      options
    } = (0,_request_js__WEBPACK_IMPORTED_MODULE_9__.getNodeRequestOptions)(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
    }
    if (parsedURL.protocol === 'data:') {
      const data = (0,data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__["default"])(request.url);
      const response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](data, {
        headers: {
          'Content-Type': data.typeFull
        }
      });
      resolve(response);
      return;
    }

    // Wrap http.request into fetch
    const send = (parsedURL.protocol === 'https:' ? node_https__WEBPACK_IMPORTED_MODULE_1__ : node_http__WEBPACK_IMPORTED_MODULE_0__).request;
    const {
      signal
    } = request;
    let response = null;
    const abort = () => {
      const error = new _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError('The operation was aborted.');
      reject(error);
      if (request.body && request.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit('error', error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };

    // Send request
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener('abort', abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener('abort', abortAndFinalize);
      }
    };
    request_.on('error', error => {
      reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, error => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });

    /* c8 ignore next 18 */
    if (process.version < 'v14') {
      // Before Node.js 14, pipeline() does not fully support async iterators and does not always
      // properly handle when the socket close/end events are out of order.
      request_.on('socket', s => {
        let endedWithEventsCount;
        s.prependListener('end', () => {
          endedWithEventsCount = s._eventsCount;
        });
        s.prependListener('close', hadError => {
          // if end happened before close but the socket didn't emit an error, do it now
          if (response && endedWithEventsCount < s._eventsCount && !hadError) {
            const error = new Error('Premature close');
            error.code = 'ERR_STREAM_PREMATURE_CLOSE';
            response.body.emit('error', error);
          }
        });
      });
    }
    request_.on('response', response_ => {
      request_.setTimeout(0);
      const headers = (0,_headers_js__WEBPACK_IMPORTED_MODULE_8__.fromRawHeaders)(response_.rawHeaders);

      // HTTP fetch step 5
      if ((0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)(response_.statusCode)) {
        // HTTP fetch step 5.2
        const location = headers.get('Location');

        // HTTP fetch step 5.3
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          // error here can only be invalid URL in Location: header
          // do not throw when options.redirect == manual
          // let the user extract the errorneous redirect URL
          if (request.redirect !== 'manual') {
            reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
            finalize();
            return;
          }
        }

        // HTTP fetch step 5.5
        switch (request.redirect) {
          case 'error':
            reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
            finalize();
            return;
          case 'manual':
            // Nothing to do
            break;
          case 'follow':
            {
              // HTTP-redirect fetch step 2
              if (locationURL === null) {
                break;
              }

              // HTTP-redirect fetch step 5
              if (request.counter >= request.follow) {
                reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                finalize();
                return;
              }

              // HTTP-redirect fetch step 6 (counter increment)
              // Create a new Request object.
              const requestOptions = {
                headers: new _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"](request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: (0,_body_js__WEBPACK_IMPORTED_MODULE_14__.clone)(request),
                signal: request.signal,
                size: request.size,
                referrer: request.referrer,
                referrerPolicy: request.referrerPolicy
              };

              // when forwarding sensitive headers like "Authorization",
              // "WWW-Authenticate", and "Cookie" to untrusted targets,
              // headers will be ignored when following a redirect to a domain
              // that is not a subdomain match or exact match of the initial domain.
              // For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
              // will forward the sensitive headers, but a redirect to "bar.com" will not.
              // headers will also be ignored when following a redirect to a domain using
              // a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
              // will not forward the sensitive headers
              if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isDomainOrSubdomain)(request.url, locationURL) || !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isSameProtocol)(request.url, locationURL)) {
                for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
                  requestOptions.headers.delete(name);
                }
              }

              // HTTP-redirect fetch step 9
              if (response_.statusCode !== 303 && request.body && options_.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
                reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                finalize();
                return;
              }

              // HTTP-redirect fetch step 11
              if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST') {
                requestOptions.method = 'GET';
                requestOptions.body = undefined;
                requestOptions.headers.delete('content-length');
              }

              // HTTP-redirect fetch step 14
              const responseReferrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__.parseReferrerPolicyFromHeader)(headers);
              if (responseReferrerPolicy) {
                requestOptions.referrerPolicy = responseReferrerPolicy;
              }

              // HTTP-redirect fetch step 15
              resolve(fetch(new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](locationURL, requestOptions)));
              finalize();
              return;
            }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }

      // Prepare response
      if (signal) {
        response_.once('end', () => {
          signal.removeEventListener('abort', abortAndFinalize);
        });
      }
      let body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
        if (error) {
          reject(error);
        }
      });
      // see https://github.com/nodejs/node/pull/29376
      /* c8 ignore next 3 */
      if (process.version < 'v12.10') {
        response_.on('aborted', abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };

      // HTTP-network fetch step 12.1.1.3
      const codings = headers.get('Content-Encoding');

      // HTTP-network fetch step 12.1.1.4: handle content codings

      // in following scenarios we ignore compression support
      // 1. compression support is disabled
      // 2. HEAD request
      // 3. no Content-Encoding header
      // 4. no content response (204)
      // 5. content not modified response (304)
      if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // For Node v6+
      // Be less strict when decoding compressed responses, since sometimes
      // servers send slightly invalid responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      const zlibOptions = {
        flush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH,
        finishFlush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH
      };

      // For gzip
      if (codings === 'gzip' || codings === 'x-gzip') {
        body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip(zlibOptions), error => {
          if (error) {
            reject(error);
          }
        });
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // For deflate
      if (codings === 'deflate' || codings === 'x-deflate') {
        // Handle the infamous raw deflate response from old servers
        // a hack for old IIS and Apache servers
        const raw = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
          if (error) {
            reject(error);
          }
        });
        raw.once('data', chunk => {
          // See http://stackoverflow.com/questions/37519828
          if ((chunk[0] & 0x0F) === 0x08) {
            body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate(), error => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflateRaw(), error => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
          resolve(response);
        });
        raw.once('end', () => {
          // Some old IIS servers return zero-length OK deflate responses, so
          // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
          if (!response) {
            response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
            resolve(response);
          }
        });
        return;
      }

      // For br
      if (codings === 'br') {
        body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createBrotliDecompress(), error => {
          if (error) {
            reject(error);
          }
        });
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // Otherwise, use response as-is
      response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
      resolve(response);
    });

    // eslint-disable-next-line promise/prefer-await-to-then
    (0,_body_js__WEBPACK_IMPORTED_MODULE_14__.writeToStream)(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from('0\r\n\r\n');
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on('response', response => {
    const {
      headers
    } = response;
    isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
  });
  request.on('socket', socket => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error('Premature close');
        error.code = 'ERR_STREAM_PREMATURE_CLOSE';
        errorCallback(error);
      }
    };
    const onData = buf => {
      properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

      // Sometimes final 0-length chunk and end of message code are in separate packets
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener('close', onSocketClose);
    socket.on('data', onData);
    request.on('close', () => {
      socket.removeListener('close', onSocketClose);
      socket.removeListener('data', onData);
    });
  });
}

/***/ }),

/***/ "./node_modules/node-fetch/src/request.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/request.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request),
/* harmony export */   getNodeRequestOptions: () => (/* binding */ getNodeRequestOptions)
/* harmony export */ });
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/get-search.js */ "./node_modules/node-fetch/src/utils/get-search.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */








const INTERNALS = Symbol('Request internals');

/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */
const isRequest = object => {
  return typeof object === 'object' && typeof object[INTERNALS] === 'object';
};
const doBadDataWarn = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {}, '.data is not a valid RequestInit property, use .body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

/**
 * Request class
 *
 * Ref: https://fetch.spec.whatwg.org/#request-class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request extends _body_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(input, init = {}) {
    let parsedURL;

    // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== '' || parsedURL.password !== '') {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || 'GET';
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && 'data' in init) {
      doBadDataWarn();
    }

    // eslint-disable-next-line no-eq-null, eqeqeq
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
      throw new TypeError('Request with GET/HEAD method cannot have body');
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.clone)(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](init.headers || input.headers || {});
    if (inputBody !== null && !headers.has('Content-Type')) {
      const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.extractContentType)(inputBody, this);
      if (contentType) {
        headers.set('Content-Type', contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ('signal' in init) {
      signal = init.signal;
    }

    // eslint-disable-next-line no-eq-null, eqeqeq
    if (signal != null && !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_4__.isAbortSignal)(signal)) {
      throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
    }

    // Â§5.4, Request constructor steps, step 15.1
    // eslint-disable-next-line no-eq-null, eqeqeq
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === '') {
      // Â§5.4, Request constructor steps, step 15.2
      referrer = 'no-referrer';
    } else if (referrer) {
      // Â§5.4, Request constructor steps, step 15.3.1, 15.3.2
      const parsedReferrer = new URL(referrer);
      // Â§5.4, Request constructor steps, step 15.3.3, 15.3.4
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
    } else {
      referrer = undefined;
    }
    this[INTERNALS] = {
      method,
      redirect: init.redirect || input.redirect || 'follow',
      headers,
      parsedURL,
      signal,
      referrer
    };

    // Node-fetch-only options
    this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;
    this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

    // Â§5.4, Request constructor steps, step 16.
    // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
  }

  /** @returns {string} */
  get method() {
    return this[INTERNALS].method;
  }

  /** @returns {string} */
  get url() {
    return (0,node_url__WEBPACK_IMPORTED_MODULE_0__.format)(this[INTERNALS].parsedURL);
  }

  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }

  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS].signal;
  }

  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS].referrer === 'no-referrer') {
      return '';
    }
    if (this[INTERNALS].referrer === 'client') {
      return 'about:client';
    }
    if (this[INTERNALS].referrer) {
      return this[INTERNALS].referrer.toString();
    }
    return undefined;
  }
  get referrerPolicy() {
    return this[INTERNALS].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS].referrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.validateReferrerPolicy)(referrerPolicy);
  }

  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return 'Request';
  }
}
Object.defineProperties(Request.prototype, {
  method: {
    enumerable: true
  },
  url: {
    enumerable: true
  },
  headers: {
    enumerable: true
  },
  redirect: {
    enumerable: true
  },
  clone: {
    enumerable: true
  },
  signal: {
    enumerable: true
  },
  referrer: {
    enumerable: true
  },
  referrerPolicy: {
    enumerable: true
  }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param {Request} request - A Request instance
 * @return The options object to be passed to http.request
 */
const getNodeRequestOptions = request => {
  const {
    parsedURL
  } = request[INTERNALS];
  const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](request[INTERNALS].headers);

  // Fetch step 1.3
  if (!headers.has('Accept')) {
    headers.set('Accept', '*/*');
  }

  // HTTP-network-or-cache fetch steps 2.4-2.7
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = '0';
  }
  if (request.body !== null) {
    const totalBytes = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.getTotalBytes)(request);
    // Set Content-Length if totalBytes is a number (that is not NaN)
    if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set('Content-Length', contentLengthValue);
  }

  // 4.1. Main fetch, step 2.6
  // > If request's referrer policy is the empty string, then set request's referrer policy to the
  // > default referrer policy.
  if (request.referrerPolicy === '') {
    request.referrerPolicy = _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_REFERRER_POLICY;
  }

  // 4.1. Main fetch, step 2.7
  // > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
  // > determine request's referrer.
  if (request.referrer && request.referrer !== 'no-referrer') {
    request[INTERNALS].referrer = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.determineRequestsReferrer)(request);
  } else {
    request[INTERNALS].referrer = 'no-referrer';
  }

  // 4.5. HTTP-network-or-cache fetch, step 6.9
  // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
  // >  and isomorphic encoded, to httpRequest's header list.
  if (request[INTERNALS].referrer instanceof URL) {
    headers.set('Referer', request.referrer);
  }

  // HTTP-network-or-cache fetch step 2.11
  if (!headers.has('User-Agent')) {
    headers.set('User-Agent', 'node-fetch');
  }

  // HTTP-network-or-cache fetch step 2.15
  if (request.compress && !headers.has('Accept-Encoding')) {
    headers.set('Accept-Encoding', 'gzip, deflate, br');
  }
  let {
    agent
  } = request;
  if (typeof agent === 'function') {
    agent = agent(parsedURL);
  }

  // HTTP-network fetch step 4.2
  // chunked encoding is handled by Node.js

  const search = (0,_utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__.getSearch)(parsedURL);

  // Pass the full URL directly to request(), but overwrite the following
  // options:
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

/***/ }),

/***/ "./node_modules/node-fetch/src/response.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/response.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Response)
/* harmony export */ });
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/**
 * Response.js
 *
 * Response class provides content decoding
 */




const INTERNALS = Symbol('Response internals');

/**
 * Response class
 *
 * Ref: https://fetch.spec.whatwg.org/#response-class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response extends _body_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(body = null, options = {}) {
    super(body, options);

    // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
    const status = options.status != null ? options.status : 200;
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.headers);
    if (body !== null && !headers.has('Content-Type')) {
      const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_0__.extractContentType)(body, this);
      if (contentType) {
        headers.append('Content-Type', contentType);
      }
    }
    this[INTERNALS] = {
      type: 'default',
      url: options.url,
      status,
      statusText: options.statusText || '',
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS].type;
  }
  get url() {
    return this[INTERNALS].url || '';
  }
  get status() {
    return this[INTERNALS].status;
  }

  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
  }
  get redirected() {
    return this[INTERNALS].counter > 0;
  }
  get statusText() {
    return this[INTERNALS].statusText;
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get highWaterMark() {
    return this[INTERNALS].highWaterMark;
  }

  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response((0,_body_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }

  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!(0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__.isRedirect)(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response(null, {
      status: 0,
      statusText: ''
    });
    response[INTERNALS].type = 'error';
    return response;
  }
  static json(data = undefined, init = {}) {
    const body = JSON.stringify(data);
    if (body === undefined) {
      throw new TypeError('data is not JSON serializable');
    }
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](init && init.headers);
    if (!headers.has('content-type')) {
      headers.set('content-type', 'application/json');
    }
    return new Response(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return 'Response';
  }
}
Object.defineProperties(Response.prototype, {
  type: {
    enumerable: true
  },
  url: {
    enumerable: true
  },
  status: {
    enumerable: true
  },
  ok: {
    enumerable: true
  },
  redirected: {
    enumerable: true
  },
  statusText: {
    enumerable: true
  },
  headers: {
    enumerable: true
  },
  clone: {
    enumerable: true
  }
});

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/get-search.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/get-search.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSearch: () => (/* binding */ getSearch)
/* harmony export */ });
const getSearch = parsedURL => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
  return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is-redirect.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is-redirect.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRedirect: () => (/* binding */ isRedirect)
/* harmony export */ });
const redirectStatus = new Set([301, 302, 303, 307, 308]);

/**
 * Redirect code matching
 *
 * @param {number} code - Status code
 * @return {boolean}
 */
const isRedirect = code => {
  return redirectStatus.has(code);
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAbortSignal: () => (/* binding */ isAbortSignal),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isDomainOrSubdomain: () => (/* binding */ isDomainOrSubdomain),
/* harmony export */   isSameProtocol: () => (/* binding */ isSameProtocol),
/* harmony export */   isURLSearchParameters: () => (/* binding */ isURLSearchParameters)
/* harmony export */ });
/**
 * Is.js
 *
 * Object type checks.
 */

const NAME = Symbol.toStringTag;

/**
 * Check if `obj` is a URLSearchParams object
 * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isURLSearchParameters = object => {
  return typeof object === 'object' && typeof object.append === 'function' && typeof object.delete === 'function' && typeof object.get === 'function' && typeof object.getAll === 'function' && typeof object.has === 'function' && typeof object.set === 'function' && typeof object.sort === 'function' && object[NAME] === 'URLSearchParams';
};

/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isBlob = object => {
  return object && typeof object === 'object' && typeof object.arrayBuffer === 'function' && typeof object.type === 'string' && typeof object.stream === 'function' && typeof object.constructor === 'function' && /^(Blob|File)$/.test(object[NAME]);
};

/**
 * Check if `obj` is an instance of AbortSignal.
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isAbortSignal = object => {
  return typeof object === 'object' && (object[NAME] === 'AbortSignal' || object[NAME] === 'EventTarget');
};

/**
 * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
 * the parent domain.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/referrer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/referrer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_REFERRER_POLICY: () => (/* binding */ DEFAULT_REFERRER_POLICY),
/* harmony export */   ReferrerPolicy: () => (/* binding */ ReferrerPolicy),
/* harmony export */   determineRequestsReferrer: () => (/* binding */ determineRequestsReferrer),
/* harmony export */   isOriginPotentiallyTrustworthy: () => (/* binding */ isOriginPotentiallyTrustworthy),
/* harmony export */   isUrlPotentiallyTrustworthy: () => (/* binding */ isUrlPotentiallyTrustworthy),
/* harmony export */   parseReferrerPolicyFromHeader: () => (/* binding */ parseReferrerPolicyFromHeader),
/* harmony export */   stripURLForUseAsAReferrer: () => (/* binding */ stripURLForUseAsAReferrer),
/* harmony export */   validateReferrerPolicy: () => (/* binding */ validateReferrerPolicy)
/* harmony export */ });
/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:net */ "node:net");


/**
 * @external URL
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
 */

/**
 * @module utils/referrer
 * @private
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy Â§8.4. Strip url for use as a referrer}
 * @param {string} URL
 * @param {boolean} [originOnly=false]
 */
function stripURLForUseAsAReferrer(url, originOnly = false) {
  // 1. If url is null, return no referrer.
  if (url == null) {
    // eslint-disable-line no-eq-null, eqeqeq
    return 'no-referrer';
  }
  url = new URL(url);

  // 2. If url's scheme is a local scheme, then return no referrer.
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return 'no-referrer';
  }

  // 3. Set url's username to the empty string.
  url.username = '';

  // 4. Set url's password to null.
  // Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
  url.password = '';

  // 5. Set url's fragment to null.
  // Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
  url.hash = '';

  // 6. If the origin-only flag is true, then:
  if (originOnly) {
    // 6.1. Set url's path to null.
    // Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
    url.pathname = '';

    // 6.2. Set url's query to null.
    // Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
    url.search = '';
  }

  // 7. Return url.
  return url;
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
 */
const ReferrerPolicy = new Set(['', 'no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url']);

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
 */
const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy Â§3. Referrer Policies}
 * @param {string} referrerPolicy
 * @returns {string} referrerPolicy
 */
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy Â§3.2. Is origin potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isOriginPotentiallyTrustworthy(url) {
  // 1. If origin is an opaque origin, return "Not Trustworthy".
  // Not applicable

  // 2. Assert: origin is a tuple origin.
  // Not for implementations

  // 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }

  // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
  const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
  const hostIPVersion = (0,node_net__WEBPACK_IMPORTED_MODULE_0__.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }

  // 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
  // We are returning FALSE here because we cannot ensure conformance to
  // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
  if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
    return false;
  }

  // 6. If origin's scheme component is file, return "Potentially Trustworthy".
  if (url.protocol === 'file:') {
    return true;
  }

  // 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
  // Not supported

  // 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
  // Not supported

  // 9. Return "Not Trustworthy".
  return false;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy Â§3.3. Is url potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isUrlPotentiallyTrustworthy(url) {
  // 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }

  // 2. If url's scheme is "data", return "Potentially Trustworthy".
  if (url.protocol === 'data:') {
    return true;
  }

  // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
  // created. Therefore, blobs created in a trustworthy origin will themselves be potentially
  // trustworthy.
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }

  // 3. Return the result of executing Â§3.2 Is origin potentially trustworthy? on url's origin.
  return isOriginPotentiallyTrustworthy(url);
}

/**
 * Modifies the referrerURL to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy Â§8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerURLCallback
 * @param {external:URL} referrerURL
 * @returns {external:URL} modified referrerURL
 */

/**
 * Modifies the referrerOrigin to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy Â§8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerOriginCallback
 * @param {external:URL} referrerOrigin
 * @returns {external:URL} modified referrerOrigin
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy Â§8.3. Determine request's Referrer}
 * @param {Request} request
 * @param {object} o
 * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
 * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
 * @returns {external:URL} Request's referrer
 */
function determineRequestsReferrer(request, {
  referrerURLCallback,
  referrerOriginCallback
} = {}) {
  // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
  // these cases:
  // > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
  // > Note: If request's referrer policy is the empty string, Fetch will not call into this
  // > algorithm.
  if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
    return null;
  }

  // 1. Let policy be request's associated referrer policy.
  const policy = request.referrerPolicy;

  // 2. Let environment be request's client.
  // not applicable to node.js

  // 3. Switch on request's referrer:
  if (request.referrer === 'about:client') {
    return 'no-referrer';
  }

  // "a URL": Let referrerSource be request's referrer.
  const referrerSource = request.referrer;

  // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);

  // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
  //    origin-only flag set to true.
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

  // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
  //    referrerURL to referrerOrigin.
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }

  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
  //    policy considerations in the interests of minimizing data leakage. For example, the user
  //    agent could strip the URL down to an origin, modify its host, replace it with an empty
  //    string, etc.
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }

  // 8.Execute the statements corresponding to the value of policy:
  const currentURL = new URL(request.url);
  switch (policy) {
    case 'no-referrer':
      return 'no-referrer';
    case 'origin':
      return referrerOrigin;
    case 'unsafe-url':
      return referrerURL;
    case 'strict-origin':
      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 2. Return referrerOrigin.
      return referrerOrigin.toString();
    case 'strict-origin-when-cross-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 3. Return referrerOrigin.
      return referrerOrigin;
    case 'same-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // 2. Return no referrer.
      return 'no-referrer';
    case 'origin-when-cross-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // Return referrerOrigin.
      return referrerOrigin;
    case 'no-referrer-when-downgrade':
      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 2. Return referrerURL.
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy Â§8.1. Parse a referrer policy from a Referrer-Policy header}
 * @param {Headers} headers Response headers
 * @returns {string} policy
 */
function parseReferrerPolicyFromHeader(headers) {
  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
  //    and responseâs header list.
  const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

  // 2. Let policy be the empty string.
  let policy = '';

  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
  //    string, then set policy to token.
  // Note: This algorithm loops over multiple policy values to allow deployment of new policy
  // values with fallbacks for older user agents, as described in Â§ 11.1 Unknown Policy Values.
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }

  // 4. Return policy.
  return policy;
}

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfa3ktdW5pdmVyc2FsX2luZGV4X2pzLmNvbW0tc2Vydi1kZXYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7OztBQUlBLE1BQXFCQSxXQUFZLFNBQVFDLGVBQUEsQ0FBQUMsV0FBb0M7Ozs7RUFJekVDLFlBQUE7SUFDSSxLQUFLLEVBQUU7SUFDUCxNQUFNLElBQUlDLFNBQVMsQ0FBQyw0Q0FBNEMsQ0FBQzs7Ozs7RUFNckUsSUFBV0MsT0FBT0EsQ0FBQTtJQUNkLE1BQU1BLE9BQU8sR0FBR0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQ3RDLElBQUksT0FBT0YsT0FBTyxLQUFLLFNBQVMsRUFBRTtNQUM5QixNQUFNLElBQUlELFNBQVMsQ0FDZiwwREFDSSxJQUFJLEtBQUssSUFBSSxHQUFHLE1BQU0sR0FBRyxPQUFPLElBQ3BDLEVBQUUsQ0FDTDs7SUFFTCxPQUFPQyxPQUFPOzs7QUFHdEJKLGVBQUEsQ0FBQU8sb0JBQW9CLENBQUNSLFdBQVcsQ0FBQ1MsU0FBUyxFQUFFLE9BQU8sQ0FBQzs7OztBQUtwRCxTQUFnQkMsaUJBQWlCQSxDQUFBO0VBQzdCLE1BQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNiLFdBQVcsQ0FBQ1MsU0FBUyxDQUFDO0VBQ25EUixlQUFBLENBQUFDLFdBQVcsQ0FBQ1ksSUFBSSxDQUFDSCxNQUFNLENBQUM7RUFDeEJMLFlBQVksQ0FBQ1MsR0FBRyxDQUFDSixNQUFNLEVBQUUsS0FBSyxDQUFDO0VBQy9CLE9BQU9BLE1BQU07Ozs7O0FBTWpCLFNBQWdCSyxXQUFXQSxDQUFDTCxNQUFtQjtFQUMzQyxJQUFJTCxZQUFZLENBQUNDLEdBQUcsQ0FBQ0ksTUFBTSxDQUFDLEtBQUssS0FBSyxFQUFFO0lBQ3BDOztFQUdKTCxZQUFZLENBQUNTLEdBQUcsQ0FBQ0osTUFBTSxFQUFFLElBQUksQ0FBQztFQUM5QkEsTUFBTSxDQUFDTSxhQUFhLENB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Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2Fib3J0LXNpZ25hbC50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2Fib3J0LWNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9ldmVudC5tanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9ldmVudC10YXJnZXQubWpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWRvbWV4Y2VwdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3N0dWIvc3ltYm9sLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvaGVscGVycy9taXNjZWxsYW5lb3VzLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2hlbHBlcnMvd2ViaWRsLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3NpbXBsZS1xdWV1ZS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vZ2VuZXJpYy1yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9zdHViL251bWJlci1pc2Zpbml0ZS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3N0dWIvbWF0aC10cnVuYy50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL2Jhc2ljLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvcmVhZGFibGUtc3RyZWFtLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3RhcmdldC9lczIwMTgvc3R1Yi9hc3luYy1pdGVyYXRvci1wcm90b3R5cGUudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2FzeW5jLWl0ZXJhdG9yLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvc3R1Yi9udW1iZXItaXNuYW4udHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYWJzdHJhY3Qtb3BzL21pc2NlbGxhbmVvdXMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2J5b2ItcmVhZGVyLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5LnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3VuZGVybHlpbmctc2luay50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3dyaXRhYmxlLXN0cmVhbS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9hYm9ydC1zaWduYWwudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvd3JpdGFibGUtc3RyZWFtLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvc3R1Yi9uYXRpdmUudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9zdHViL2RvbS1leGNlcHRpb24udHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL3BpcGUudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vdGVlLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zb3VyY2UudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkZXItb3B0aW9ucy50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL2l0ZXJhdG9yLW9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9waXBlLW9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdC50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9ieXRlLWxlbmd0aC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2NvdW50LXF1ZXVpbmctc3RyYXRlZ3kudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy90cmFuc2Zvcm1lci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi90cmFuc2Zvcm0tc3RyZWFtLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL3N0cmVhbXMuY2pzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL2ZldGNoLWJsb2IvZmlsZS5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9mcm9tLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2luZGV4LmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9mb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9reS11bml2ZXJzYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2JvZHkuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2Vycm9ycy9hYm9ydC1lcnJvci5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvZXJyb3JzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2Vycm9ycy9mZXRjaC1lcnJvci5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvaGVhZGVycy5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3Jlc3BvbnNlLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9nZXQtc2VhcmNoLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9pcy1yZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvdXRpbHMvaXMuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3V0aWxzL3JlZmVycmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgLy8gRXZlbnQsXG4gICAgRXZlbnRUYXJnZXQsXG4gICAgLy8gVHlwZSxcbiAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZSxcbn0gZnJvbSBcImV2ZW50LXRhcmdldC1zaGltXCJcblxuLy8gS25vd24gTGltaXRhdGlvblxuLy8gICBVc2UgYGFueWAgYmVjYXVzZSB0aGUgdHlwZSBvZiBgQWJvcnRTaWduYWxgIGluIGBsaWIuZG9tLmQudHNgIGlzIHdyb25nIGFuZFxuLy8gICB0byBtYWtlIGFzc2lnbmFibGUgb3VyIGBBYm9ydFNpZ25hbGAgaW50byB0aGF0LlxuLy8gICBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1RTSlMtbGliLWdlbmVyYXRvci9wdWxsLzYyM1xudHlwZSBFdmVudHMgPSB7XG4gICAgYWJvcnQ6IGFueSAvLyBFdmVudCAmIFR5cGU8XCJhYm9ydFwiPlxufVxudHlwZSBFdmVudEF0dHJpYnV0ZXMgPSB7XG4gICAgb25hYm9ydDogYW55IC8vIEV2ZW50ICYgVHlwZTxcImFib3J0XCI+XG59XG5cbi8qKlxuICogVGhlIHNpZ25hbCBjbGFzcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNhYm9ydHNpZ25hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBYm9ydFNpZ25hbCBleHRlbmRzIEV2ZW50VGFyZ2V0PEV2ZW50cywgRXZlbnRBdHRyaWJ1dGVzPiB7XG4gICAgLyoqXG4gICAgICogQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBgQWJvcnRTaWduYWxgJ3MgYEFib3J0Q29udHJvbGxlcmAgaGFzIHNpZ25hbGVkIHRvIGFib3J0LCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBhYm9ydGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhYm9ydGVkID0gYWJvcnRlZEZsYWdzLmdldCh0aGlzKVxuICAgICAgICBpZiAodHlwZW9mIGFib3J0ZWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0U2lnbmFsJyBvYmplY3QsIGJ1dCBnb3QgJHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHRoaXNcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJvcnRlZFxuICAgIH1cbn1cbmRlZmluZUV2ZW50QXR0cmlidXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSwgXCJhYm9ydFwiKVxuXG4vKipcbiAqIENyZWF0ZSBhbiBBYm9ydFNpZ25hbCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBYm9ydFNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgY29uc3Qgc2lnbmFsID0gT2JqZWN0LmNyZWF0ZShBYm9ydFNpZ25hbC5wcm90b3R5cGUpXG4gICAgRXZlbnRUYXJnZXQuY2FsbChzaWduYWwpXG4gICAgYWJvcnRlZEZsYWdzLnNldChzaWduYWwsIGZhbHNlKVxuICAgIHJldHVybiBzaWduYWxcbn1cblxuLyoqXG4gKiBBYm9ydCBhIGdpdmVuIHNpZ25hbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib3J0U2lnbmFsKHNpZ25hbDogQWJvcnRTaWduYWwpOiB2b2lkIHtcbiAgICBpZiAoYWJvcnRlZEZsYWdzLmdldChzaWduYWwpICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhYm9ydGVkRmxhZ3Muc2V0KHNpZ25hbCwgdHJ1ZSlcbiAgICBzaWduYWwuZGlzcGF0Y2hFdmVudDxcImFib3J0XCI+KHsgdHlwZTogXCJhYm9ydFwiIH0pXG59XG5cbi8qKlxuICogQWJvcnRlZCBmbGFnIGZvciBlYWNoIGluc3RhbmNlcy5cbiAqL1xuY29uc3QgYWJvcnRlZEZsYWdzID0gbmV3IFdlYWtNYXA8QWJvcnRTaWduYWwsIGJvb2xlYW4+KClcblxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0U2lnbmFsLnByb3RvdHlwZSwge1xuICAgIGFib3J0ZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxufSlcblxuLy8gYHRvU3RyaW5nKClgIHNob3VsZCByZXR1cm4gYFwiW29iamVjdCBBYm9ydFNpZ25hbF1cImBcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydFNpZ25hbC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkFib3J0U2lnbmFsXCIsXG4gICAgfSlcbn1cbiIsImltcG9ydCBBYm9ydFNpZ25hbCwgeyBhYm9ydFNpZ25hbCwgY3JlYXRlQWJvcnRTaWduYWwgfSBmcm9tIFwiLi9hYm9ydC1zaWduYWxcIlxuXG4vKipcbiAqIFRoZSBBYm9ydENvbnRyb2xsZXIuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzaWduYWxzLnNldCh0aGlzLCBjcmVhdGVBYm9ydFNpZ25hbCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBBYm9ydFNpZ25hbGAgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgICAgIHJldHVybiBnZXRTaWduYWwodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbmQgc2lnbmFsIHRvIGFueSBvYnNlcnZlcnMgdGhhdCB0aGUgYXNzb2NpYXRlZCBhY3Rpdml0eSBpcyB0byBiZSBhYm9ydGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYm9ydCgpOiB2b2lkIHtcbiAgICAgICAgYWJvcnRTaWduYWwoZ2V0U2lnbmFsKHRoaXMpKVxuICAgIH1cbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVkIHNpZ25hbHMuXG4gKi9cbmNvbnN0IHNpZ25hbHMgPSBuZXcgV2Vha01hcDxBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsPigpXG5cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGVkIHNpZ25hbCBvZiBhIGdpdmVuIGNvbnRyb2xsZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFNpZ25hbChjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBBYm9ydFNpZ25hbCB7XG4gICAgY29uc3Qgc2lnbmFsID0gc2lnbmFscy5nZXQoY29udHJvbGxlcilcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0Q29udHJvbGxlcicgb2JqZWN0LCBidXQgZ290ICR7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH1gLFxuICAgICAgICApXG4gICAgfVxuICAgIHJldHVybiBzaWduYWxcbn1cblxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICBzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbn0pXG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogXCJBYm9ydENvbnRyb2xsZXJcIixcbiAgICB9KVxufVxuXG5leHBvcnQgeyBBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsIH1cbiIsIi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVTdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIEdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyB7UHJpdmF0ZURhdGF9IFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGQoZXZlbnQpIHtcbiAgICBjb25zdCByZXR2ID0gcHJpdmF0ZURhdGEuZ2V0KGV2ZW50KVxuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudFxuICAgIClcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jc2V0LXRoZS1jYW5jZWxlZC1mbGFnXG4gKiBAcGFyYW0gZGF0YSB7UHJpdmF0ZURhdGF9IHByaXZhdGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FuY2VsRmxhZyhkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFzc2l2ZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgZGF0YS5wYXNzaXZlTGlzdGVuZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFkYXRhLmV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGF0YS5jYW5jZWxlZCA9IHRydWVcbiAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBUaGUgZXZlbnQgd3JhcHBlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgcHJpdmF0ZURhdGEuc2V0KHRoaXMsIHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudFBoYXNlOiAyLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlU3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KVxuXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jVW5mb3JnZWFibGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RydXN0ZWRcIiwgeyB2YWx1ZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUgfSlcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuYnViYmxlcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY2FuY2VsYWJsZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gc3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXG4gICAgfSxcbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGV2ZW50IG9iamVjdC4gQnV0IGRvIG5vdGhpbmcgdW5kZXIgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYnViYmxlcz1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gYnViYmxlIHVwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGNhbmNlbC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGluaXRFdmVudCgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9LFxufVxuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pXG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKVxuXG4gICAgLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgdGhlIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFtrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgcGQodGhpcykuZXZlbnRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnRcbiAgICAgICAgICAgIHJldHVybiBldmVudFtrZXldLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQmFzZUV2ZW50IFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBkZWZpbmVkIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudCwgcHJvdG8pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcbiAgICB9XG5cbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgQmFzZUV2ZW50LmNhbGwodGhpcywgZXZlbnRUYXJnZXQsIGV2ZW50KVxuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KVxuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpXG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFxufVxuXG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBnZXQgaXRzIHdyYXBwZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlcihwcm90bykge1xuICAgIGlmIChwcm90byA9PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBFdmVudFxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyID0gd3JhcHBlcnMuZ2V0KHByb3RvKVxuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pXG4gICAgICAgIHdyYXBwZXJzLnNldChwcm90bywgd3JhcHBlcilcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgdG8gbWFuYWdlbWVudCBhIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB3cmFwLlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgY29uc3QgV3JhcHBlciA9IGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSlcbiAgICByZXR1cm4gbmV3IFdyYXBwZXIoZXZlbnRUYXJnZXQsIGV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlU3RvcHBlZCBmbGFnIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gZ2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIHBkKGV2ZW50KS5pbW1lZGlhdGVTdG9wcGVkXG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50UGhhc2UgTmV3IGV2ZW50IHBoYXNlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZVxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB0YXJnZXQgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldFxufVxuXG4vKipcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBOZXcgcGFzc2l2ZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lclxufVxuIiwiaW1wb3J0IHtcbiAgICBpc1N0b3BwZWQsXG4gICAgc2V0Q3VycmVudFRhcmdldCxcbiAgICBzZXRFdmVudFBoYXNlLFxuICAgIHNldFBhc3NpdmVMaXN0ZW5lcixcbiAgICB3cmFwRXZlbnQsXG59IGZyb20gXCIuL2V2ZW50Lm1qc1wiXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTGlzdGVuZXJOb2RlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogQHByb3BlcnR5IHsxfDJ8M30gbGlzdGVuZXJUeXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NpdmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb25jZVxuICogQHByb3BlcnR5IHtMaXN0ZW5lck5vZGV8bnVsbH0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtXZWFrTWFwPG9iamVjdCwgTWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsaXN0ZW5lcnNNYXAgPSBuZXcgV2Vha01hcCgpXG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMVxuY29uc3QgQlVCQkxFID0gMlxuY29uc3QgQVRUUklCVVRFID0gM1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KVxuICAgIGlmIChsaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBidXQgZ290IGFub3RoZXIgdmFsdWUuXCJcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgZXZlbnQgYXR0cmlidXRlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGdldCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyVHlwZTogQVRUUklCVVRFLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGV2ZW50IGF0dHJpYnV0ZSAoZS5nLiBgZXZlbnRUYXJnZXQub25jbGlja2ApLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50VGFyZ2V0UHJvdG90eXBlIFRoZSBldmVudCB0YXJnZXQgcHJvdG90eXBlIHRvIGRlZmluZSBhbiBldmVudCBhdHRyYml0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZGVmaW5lLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBldmVudE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGV2ZW50VGFyZ2V0UHJvdG90eXBlLFxuICAgICAgICBgb24ke2V2ZW50TmFtZX1gLFxuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKVxuICAgIClcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBjdXN0b20gRXZlbnRUYXJnZXQgd2l0aCBldmVudCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnROYW1lcyBFdmVudCBuYW1lcyBmb3IgZXZlbnQgYXR0cmlidXRlcy5cbiAqIEByZXR1cm5zIHtFdmVudFRhcmdldH0gVGhlIGN1c3RvbSBFdmVudFRhcmdldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGV2ZW50TmFtZXMpIHtcbiAgICAvKiogQ3VzdG9tRXZlbnRUYXJnZXQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudFRhcmdldCgpIHtcbiAgICAgICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKVxuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnROYW1lc1tpXSlcbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRUYXJnZXRcbn1cblxuLyoqXG4gKiBFdmVudFRhcmdldC5cbiAqXG4gKiAtIFRoaXMgaXMgY29uc3RydWN0b3IgaWYgbm8gYXJndW1lbnRzLlxuICogLSBUaGlzIGlzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIEN1c3RvbUV2ZW50VGFyZ2V0IGNvbnN0cnVjdG9yIGlmIHRoZXJlIGFyZSBhcmd1bWVudHMuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGNsYXNzIEEgZXh0ZW5kcyBFdmVudFRhcmdldCB7fVxuICogICAgIGNsYXNzIEIgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIikge31cbiAqICAgICBjbGFzcyBDIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIsIFwiZXJyb3JcIikge31cbiAqICAgICBjbGFzcyBEIGV4dGVuZHMgRXZlbnRUYXJnZXQoW1wibWVzc2FnZVwiLCBcImVycm9yXCJdKSB7fVxuICovXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgICBsaXN0ZW5lcnNNYXAuc2V0KHRoaXMsIG5ldyBNYXAoKSlcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoYXJndW1lbnRzWzBdKVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KHR5cGVzKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpXG4gICAgLyplc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIGEgZ2l2ZW4gbGlzdGVuZXIgdG8gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhZGQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInbGlzdGVuZXInIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKVxuICAgICAgICBjb25zdCBjYXB0dXJlID0gb3B0aW9uc0lzT2JqXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBpdCBhcyB0aGUgZmlyc3Qgbm9kZSBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBudWxsLlxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgY2hlY2tpbmcgZHVwbGljYXRpb24uLlxuICAgICAgICBsZXQgcHJldiA9IG51bGxcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGlnbm9yZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQuXG4gICAgICAgIHByZXYubmV4dCA9IG5ld05vZGVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ2l2ZW4gbGlzdGVuZXIgZnJvbSB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuICAgICAgICBjb25zdCBjYXB0dXJlID0gaXNPYmplY3Qob3B0aW9ucylcbiAgICAgICAgICAgID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpXG4gICAgICAgICAgICA6IEJvb2xlYW4ob3B0aW9ucylcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEVcblxuICAgICAgICBsZXQgcHJldiA9IG51bGxcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBnaXZlbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBpZiBjYW5jZWxlZC5cbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCA9PSBudWxsIHx8IHR5cGVvZiBldmVudC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV2ZW50LnR5cGVcIiBzaG91bGQgYmUgYSBzdHJpbmcuJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxpc3RlbmVycyBhcmVuJ3QgcmVnaXN0ZXJlZCwgdGVybWluYXRlLlxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZVxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgY2Fubm90IHJld3JpdGUgc2V2ZXJhbCBwcm9wZXJ0aWVzLCBzbyB3cmFwIG9iamVjdC5cbiAgICAgICAgY29uc3Qgd3JhcHBlZEV2ZW50ID0gd3JhcEV2ZW50KHRoaXMsIGV2ZW50KVxuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBsaXN0ZW5lciBpZiBpdCdzIG9uY2VcbiAgICAgICAgICAgIGlmIChub2RlLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGlzIGxpc3RlbmVyXG4gICAgICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgd3JhcHBlZEV2ZW50LFxuICAgICAgICAgICAgICAgIG5vZGUucGFzc2l2ZSA/IG5vZGUubGlzdGVuZXIgOiBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlICE9PSBBVFRSSUJVVEUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50KHdyYXBwZWRFdmVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIGlmIChpc1N0b3BwZWQod3JhcHBlZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCBudWxsKVxuICAgICAgICBzZXRFdmVudFBoYXNlKHdyYXBwZWRFdmVudCwgMClcbiAgICAgICAgc2V0Q3VycmVudFRhcmdldCh3cmFwcGVkRXZlbnQsIG51bGwpXG5cbiAgICAgICAgcmV0dXJuICF3cmFwcGVkRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgIH0sXG59XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogRXZlbnRUYXJnZXQsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxufSlcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiXG4pIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKVxufVxuXG5leHBvcnQgeyBkZWZpbmVFdmVudEF0dHJpYnV0ZSwgRXZlbnRUYXJnZXQgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRUYXJnZXRcbiIsIi8qISBub2RlLWRvbWV4Y2VwdGlvbi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuaWYgKCFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgTWVzc2FnZUNoYW5uZWwgfSA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyksXG4gICAgcG9ydCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLFxuICAgIGFiID0gbmV3IEFycmF5QnVmZmVyKClcbiAgICBwb3J0LnBvc3RNZXNzYWdlKGFiLCBbYWIsIGFiXSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdET01FeGNlcHRpb24nICYmIChcbiAgICAgIGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID0gZXJyLmNvbnN0cnVjdG9yXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb25cbiIsIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5zeW1ib2xcIiAvPlxuXG5jb25zdCBTeW1ib2xQb2x5ZmlsbDogKGRlc2NyaXB0aW9uPzogc3RyaW5nKSA9PiBzeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cbiAgICBTeW1ib2wgOlxuICAgIGRlc2NyaXB0aW9uID0+IGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYCBhcyBhbnkgYXMgc3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2xQb2x5ZmlsbDtcbiIsIi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCk6IHVuZGVmaW5lZCB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbHMoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBnbG9iYWxzID0gZ2V0R2xvYmFscygpO1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEFzc2VydGlvbkVycm9yIH0gZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHg6IGFueSk6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb246IChlOiBhbnkpID0+IHZvaWQgPVxuICBERUJVRyA/IGUgPT4ge1xuICAgIC8vIFVzZWQgdGhyb3VnaG91dCB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLCBhcyBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgLCB0byBlbnN1cmUgYW55IGVycm9yc1xuICAgIC8vIGdldCBzaG93bi4gVGhlcmUgYXJlIHBsYWNlcyBpbiB0aGUgc3BlYyB3aGVyZSB3ZSBkbyBwcm9taXNlIHRyYW5zZm9ybWF0aW9ucyBhbmQgcHVycG9zZWZ1bGx5IGlnbm9yZSBvciBkb24ndFxuICAgIC8vIGV4cGVjdCBhbnkgZXJyb3JzLCBidXQgYXNzZXJ0aW9uIGVycm9ycyBhcmUgYWx3YXlzIHByb2JsZW1hdGljLlxuICAgIGlmIChlICYmIGUgaW5zdGFuY2VvZiBBc3NlcnRpb25FcnJvcikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0gOiBub29wO1xuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiB9IGZyb20gJy4vbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcblxuY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbmNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZS5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5jb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdQcm9taXNlPFQ+KGV4ZWN1dG9yOiAoXG4gIHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkLFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWRcbikgPT4gdm9pZCk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoPFQ+KHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlc29sdmUodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aDxUID0gbmV2ZXI+KHJlYXNvbjogYW55KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBlcmZvcm1Qcm9taXNlVGhlbjxULCBUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBvbkZ1bGZpbGxlZD86ICh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4sXG4gIG9uUmVqZWN0ZWQ/OiAocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuICAvLyBhcHByb3hpbWF0aW9uLlxuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSBhcyBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBvblByb21pc2U8VD4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIG9uRnVsZmlsbGVkPzogKHZhbHVlOiBUKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gIG9uUmVqZWN0ZWQ/OiAocmVhc29uOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPik6IHZvaWQge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4oXG4gICAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSxcbiAgICB1bmRlZmluZWQsXG4gICAgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cG9uRnVsZmlsbG1lbnQ8VD4ocHJvbWlzZTogUHJvbWlzZTxUPiwgb25GdWxmaWxsZWQ6ICh2YWx1ZTogVCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KTogdm9pZCB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwb25SZWplY3Rpb24ocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPiwgb25SZWplY3RlZDogKHJlYXNvbjogYW55KSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pOiB2b2lkIHtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoPFQsIFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIGZ1bGZpbGxtZW50SGFuZGxlcj86ICh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4sXG4gIHJlamVjdGlvbkhhbmRsZXI/OiAocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPik6IHZvaWQge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xufVxuXG5leHBvcnQgY29uc3QgcXVldWVNaWNyb3Rhc2s6IChmbjogKCkgPT4gdm9pZCkgPT4gdm9pZCA9ICgoKSA9PiB7XG4gIGNvbnN0IGdsb2JhbFF1ZXVlTWljcm90YXNrID0gZ2xvYmFscyAmJiBnbG9iYWxzLnF1ZXVlTWljcm90YXNrO1xuICBpZiAodHlwZW9mIGdsb2JhbFF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICByZXR1cm4gKGZuOiAoKSA9PiB2b2lkKSA9PiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBmbik7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdENhbGw8VCwgQSBleHRlbmRzIGFueVtdLCBSPihGOiAodGhpczogVCwgLi4uZm5BcmdzOiBBKSA9PiBSLCBWOiBULCBhcmdzOiBBKTogUiB7XG4gIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZUNhbGw8VCwgQSBleHRlbmRzIGFueVtdLCBSPihGOiAodGhpczogVCwgLi4uZm5BcmdzOiBBKSA9PiBSIHwgUHJvbWlzZUxpa2U8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWOiBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogQSk6IFByb21pc2U8Uj4ge1xuICBhc3NlcnQodHlwZW9mIEYgPT09ICdmdW5jdGlvbicpO1xuICBhc3NlcnQoViAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoYXJncykpO1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpKTtcbiAgfSBjYXRjaCAodmFsdWUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG4gIH1cbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuXG4vLyBPcmlnaW5hbCBmcm9tIENocm9taXVtXG4vLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMGFlZTQ0MzRhNGRiYTQyYTQyYWJhZWE5YmZiYzBjZDE5NmE2M2JjMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL3N0cmVhbXMvU2ltcGxlUXVldWUuanNcblxuY29uc3QgUVVFVUVfTUFYX0FSUkFZX1NJWkUgPSAxNjM4NDtcblxuaW50ZXJmYWNlIE5vZGU8VD4ge1xuICBfZWxlbWVudHM6IFRbXTtcbiAgX25leHQ6IE5vZGU8VD4gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXVlIHN0cnVjdHVyZS5cbiAqXG4gKiBBdm9pZHMgc2NhbGFiaWxpdHkgaXNzdWVzIHdpdGggdXNpbmcgYSBwYWNrZWQgYXJyYXkgZGlyZWN0bHkgYnkgdXNpbmdcbiAqIG11bHRpcGxlIGFycmF5cyBpbiBhIGxpbmtlZCBsaXN0IGFuZCBrZWVwaW5nIHRoZSBhcnJheSBzaXplIGJvdW5kZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW1wbGVRdWV1ZTxUPiB7XG4gIHByaXZhdGUgX2Zyb250OiBOb2RlPFQ+O1xuICBwcml2YXRlIF9iYWNrOiBOb2RlPFQ+O1xuICBwcml2YXRlIF9jdXJzb3IgPSAwO1xuICBwcml2YXRlIF9zaXplID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBfZnJvbnQgYW5kIF9iYWNrIGFyZSBhbHdheXMgZGVmaW5lZC5cbiAgICB0aGlzLl9mcm9udCA9IHtcbiAgICAgIF9lbGVtZW50czogW10sXG4gICAgICBfbmV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG4gICAgLy8gVGhlIGN1cnNvciBpcyB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgQXJyYXkuc2hpZnQoKS5cbiAgICAvLyBJdCBjb250YWlucyB0aGUgaW5kZXggb2YgdGhlIGZyb250IGVsZW1lbnQgb2YgdGhlIGFycmF5IGluc2lkZSB0aGVcbiAgICAvLyBmcm9udC1tb3N0IG5vZGUuIEl0IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2UgWzAsIFFVRVVFX01BWF9BUlJBWV9TSVpFKS5cbiAgICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgbm9kZSwgc2l6ZSA9PT0gZWxlbWVudHMubGVuZ3RoIC0gY3Vyc29yLlxuICAgIHRoaXMuX3NpemUgPSAwO1xuICB9XG5cbiAgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgLy8gRm9yIGV4Y2VwdGlvbiBzYWZldHksIHRoaXMgbWV0aG9kIGlzIHN0cnVjdHVyZWQgaW4gb3JkZXI6XG4gIC8vIDEuIFJlYWQgc3RhdGVcbiAgLy8gMi4gQ2FsY3VsYXRlIHJlcXVpcmVkIHN0YXRlIG11dGF0aW9uc1xuICAvLyAzLiBQZXJmb3JtIHN0YXRlIG11dGF0aW9uc1xuICBwdXNoKGVsZW1lbnQ6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBvbGRCYWNrID0gdGhpcy5fYmFjaztcbiAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG4gICAgYXNzZXJ0KG9sZEJhY2suX25leHQgPT09IHVuZGVmaW5lZCk7XG4gICAgaWYgKG9sZEJhY2suX2VsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICBuZXdCYWNrID0ge1xuICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHB1c2goKSBpcyB0aGUgbXV0YXRpb24gbW9zdCBsaWtlbHkgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBpdFxuICAgIC8vIGdvZXMgZmlyc3QuXG4gICAgb2xkQmFjay5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICBpZiAobmV3QmFjayAhPT0gb2xkQmFjaykge1xuICAgICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XG4gICAgICBvbGRCYWNrLl9uZXh0ID0gbmV3QmFjaztcbiAgICB9XG4gICAgKyt0aGlzLl9zaXplO1xuICB9XG5cbiAgLy8gTGlrZSBwdXNoKCksIHNoaWZ0KCkgZm9sbG93cyB0aGUgcmVhZCAtPiBjYWxjdWxhdGUgLT4gbXV0YXRlIHBhdHRlcm4gZm9yXG4gIC8vIGV4Y2VwdGlvbiBzYWZldHkuXG4gIHNoaWZ0KCk6IFQge1xuICAgIGFzc2VydCh0aGlzLl9zaXplID4gMCk7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuXG4gICAgY29uc3Qgb2xkRnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICBsZXQgbmV3RnJvbnQgPSBvbGRGcm9udDtcbiAgICBjb25zdCBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgbGV0IG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IG9sZEZyb250Ll9lbGVtZW50cztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbb2xkQ3Vyc29yXTtcblxuICAgIGlmIChuZXdDdXJzb3IgPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKSB7XG4gICAgICBhc3NlcnQoZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSk7XG4gICAgICBhc3NlcnQob2xkRnJvbnQuX25leHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICBuZXdGcm9udCA9IG9sZEZyb250Ll9uZXh0ITtcbiAgICAgIG5ld0N1cnNvciA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm8gbXV0YXRpb25zIGJlZm9yZSB0aGlzIHBvaW50LlxuICAgIC0tdGhpcy5fc2l6ZTtcbiAgICB0aGlzLl9jdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xuICAgICAgdGhpcy5fZnJvbnQgPSBuZXdGcm9udDtcbiAgICB9XG5cbiAgICAvLyBQZXJtaXQgc2hpZnRlZCBlbGVtZW50IHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB1bmRlZmluZWQhO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBUaGUgdHJpY2t5IHRoaW5nIGFib3V0IGZvckVhY2goKSBpcyB0aGF0IGl0IGNhbiBiZSBjYWxsZWRcbiAgLy8gcmUtZW50cmFudGx5LiBUaGUgcXVldWUgbWF5IGJlIG11dGF0ZWQgaW5zaWRlIHRoZSBjYWxsYmFjay4gSXQgaXMgZWFzeSB0b1xuICAvLyBzZWUgdGhhdCBwdXNoKCkgd2l0aGluIHRoZSBjYWxsYmFjayBoYXMgbm8gbmVnYXRpdmUgZWZmZWN0cyBzaW5jZSB0aGUgZW5kXG4gIC8vIG9mIHRoZSBxdWV1ZSBpcyBjaGVja2VkIGZvciBvbiBldmVyeSBpdGVyYXRpb24uIElmIHNoaWZ0KCkgaXMgY2FsbGVkXG4gIC8vIHJlcGVhdGVkbHkgd2l0aGluIHRoZSBjYWxsYmFjayB0aGVuIHRoZSBuZXh0IGl0ZXJhdGlvbiBtYXkgcmV0dXJuIGFuXG4gIC8vIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiByZW1vdmVkLiBJbiB0aGlzIGNhc2UgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdpdGggdW5kZWZpbmVkIHZhbHVlcyB1bnRpbCB3ZSBlaXRoZXIgXCJjYXRjaCB1cFwiIHdpdGggZWxlbWVudHMgdGhhdCBzdGlsbFxuICAvLyBleGlzdCBvciByZWFjaCB0aGUgYmFjayBvZiB0aGUgcXVldWUuXG4gIGZvckVhY2goY2FsbGJhY2s6IChlbGVtZW50OiBUKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgbGV0IGkgPSB0aGlzLl9jdXJzb3I7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9mcm9udDtcbiAgICBsZXQgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICB3aGlsZSAoaSAhPT0gZWxlbWVudHMubGVuZ3RoIHx8IG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQobm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgYXNzZXJ0KGkgPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX25leHQhO1xuICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgICArK2k7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBlbGVtZW50IHRoYXQgd291bGQgYmUgcmV0dXJuZWQgaWYgc2hpZnQoKSB3YXMgY2FsbGVkIG5vdyxcbiAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlIHF1ZXVlLlxuICBwZWVrKCk6IFQge1xuICAgIGFzc2VydCh0aGlzLl9zaXplID4gMCk7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuXG4gICAgY29uc3QgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgcmV0dXJuIGZyb250Ll9lbGVtZW50c1tjdXJzb3JdO1xuICB9XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbUNhbmNlbCwgUmVhZGFibGVTdHJlYW1SZWFkZXIgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemU8Uj4ocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxSPiwgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPikge1xuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJyk7XG5cbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbn1cblxuLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXG4vLyBjaGVjay5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgYXNzZXJ0KHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID09PSByZWFkZXIpO1xuXG4gIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QoXG4gICAgICByZWFkZXIsXG4gICAgICBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChcbiAgICAgIHJlYWRlcixcbiAgICAgIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICB9XG5cbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZGVyTG9ja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocmVhZGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbn1cbiIsImV4cG9ydCBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sKCdbW0Fib3J0U3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2woJ1tbRXJyb3JTdGVwc11dJyk7XG5leHBvcnQgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2woJ1tbQ2FuY2VsU3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbCgnW1tQdWxsU3RlcHNdXScpO1xuIiwiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGUjUG9seWZpbGxcbmNvbnN0IE51bWJlcklzRmluaXRlOiB0eXBlb2YgTnVtYmVyLmlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJJc0Zpbml0ZTtcbiIsIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuYyNQb2x5ZmlsbFxuY29uc3QgTWF0aFRydW5jOiB0eXBlb2YgTWF0aC50cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhUcnVuYztcbiIsImltcG9ydCBOdW1iZXJJc0Zpbml0ZSBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc2Zpbml0ZSc7XG5pbXBvcnQgTWF0aFRydW5jIGZyb20gJy4uLy4uL3N0dWIvbWF0aC10cnVuYyc7XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1kaWN0aW9uYXJpZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeDogYW55KTogeCBpcyBvYmplY3QgfCBudWxsIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqOiB1bmtub3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyBvYmogaXMgb2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQW55RnVuY3Rpb24gPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWNhbGxiYWNrLWZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBBbnlGdW5jdGlvbiB7XG4gIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHg6IGFueSk6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeDogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIG9iamVjdCB7XG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQ8VCBleHRlbmRzIGFueT4oeDogVCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgVCB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHtwb3NpdGlvbn0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkPFQgZXh0ZW5kcyBhbnk+KHg6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFQge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZTogdW5rbm93bik6IG51bWJlciB7XG4gIHJldHVybiBOdW1iZXIodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gaW50ZWdlclBhcnQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xufVxuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlOiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsb3dlckJvdW5kID0gMDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcblxuICBpZiAoIU51bWJlcklzRmluaXRlKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gIH1cblxuICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cbiAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuICB9XG5cbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuICAvLyBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG4gIC8vIHhCaWdJbnQgPSBCaWdJbnQuYXNVaW50Tig2NCwgeEJpZ0ludCk7XG4gIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG5cbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVN0cmVhbSh4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgUmVhZGFibGVTdHJlYW0ge1xuICBpZiAoIUlzUmVhZGFibGVTdHJlYW0oeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApO1xuICB9XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSxcbiAgcmVhZGVyTG9ja0V4Y2VwdGlvblxufSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7IElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVqZWN0ZWRXaXRoIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi92YWxpZGF0b3JzL3JlYWRhYmxlLXN0cmVhbSc7XG5cbi8qKlxuICogQSByZXN1bHQgcmV0dXJuZWQgYnkge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8VD4gPSB7XG4gIGRvbmU6IGZhbHNlO1xuICB2YWx1ZTogVDtcbn0gfCB7XG4gIGRvbmU6IHRydWU7XG4gIHZhbHVlPzogdW5kZWZpbmVkO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xufVxuXG4vLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0PFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4pOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbS5fcmVhZGVyKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICAoc3RyZWFtLl9yZWFkZXIhIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPikuX3JlYWRSZXF1ZXN0cy5wdXNoKHJlYWRSZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0PFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIGNodW5rOiBSIHwgdW5kZWZpbmVkLCBkb25lOiBib29sZWFuKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPjtcblxuICBhc3NlcnQocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpITtcbiAgaWYgKGRvbmUpIHtcbiAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICB9IGVsc2Uge1xuICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rISk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4pOiBudW1iZXIge1xuICByZXR1cm4gKHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPikuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUmVhZGVyc1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRSZXF1ZXN0PFI+IHtcbiAgX2NodW5rU3RlcHMoY2h1bms6IFIpOiB2b2lkO1xuXG4gIF9jbG9zZVN0ZXBzKCk6IHZvaWQ7XG5cbiAgX2Vycm9yU3RlcHMoZTogYW55KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFIgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkUmVxdWVzdHM6IFNpbXBsZVF1ZXVlPFJlYWRSZXF1ZXN0PFI+PjtcblxuICBjb25zdHJ1Y3RvcihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInKTtcbiAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcblxuICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLFxuICAgKiBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUsIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqL1xuICByZWFkKCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSksXG4gICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMsIHJlYWRSZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAqXG4gICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG4gICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHJlbGVhc2VMb2NrKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkPFI+KHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0IGFzIFJlYWRSZXF1ZXN0PGFueT4pO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xufVxuIiwiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbmV4cG9ydCBjb25zdCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlOiBBc3luY0l0ZXJhYmxlPGFueT4gfCB1bmRlZmluZWQgPVxuICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKiAoKTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge30pLnByb3RvdHlwZSk7XG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG5cbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdCxcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UsXG4gIHJlYWRlckxvY2tFeGNlcHRpb25cbn0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgfSBmcm9tICdAQHRhcmdldC9zdHViL2FzeW5jLWl0ZXJhdG9yLXByb3RvdHlwZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgcXVldWVNaWNyb3Rhc2ssXG4gIHRyYW5zZm9ybVByb21pc2VXaXRoXG59IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuLyoqXG4gKiBBbiBhc3luYyBpdGVyYXRvciByZXR1cm5lZCBieSB7QGxpbmsgUmVhZGFibGVTdHJlYW0udmFsdWVzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IGV4dGVuZHMgQXN5bmNJdGVyYXRvcjxSPiB7XG4gIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxSLCB1bmRlZmluZWQ+PjtcblxuICByZXR1cm4odmFsdWU/OiBhbnkpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PGFueT4+O1xufVxuXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDxSPiB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3JlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcmV2ZW50Q2FuY2VsOiBib29sZWFuO1xuICBwcml2YXRlIF9vbmdvaW5nUHJvbWlzZTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfaXNGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+LCBwcmV2ZW50Q2FuY2VsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIHRoaXMuX3ByZXZlbnRDYW5jZWwgPSBwcmV2ZW50Q2FuY2VsO1xuICB9XG5cbiAgbmV4dCgpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBjb25zdCBuZXh0U3RlcHMgPSAoKSA9PiB0aGlzLl9uZXh0U3RlcHMoKTtcbiAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCBuZXh0U3RlcHMsIG5leHRTdGVwcykgOlxuICAgICAgbmV4dFN0ZXBzKCk7XG4gICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlO1xuICB9XG5cbiAgcmV0dXJuKHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGNvbnN0IHJldHVyblN0ZXBzID0gKCkgPT4gdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG4gICAgICByZXR1cm5TdGVwcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfbmV4dFN0ZXBzKCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4ge1xuICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdpdGVyYXRlJykpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4pID0+IHZvaWQ7XG4gICAgbGV0IHJlamVjdFByb21pc2UhOiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGJ5IG9uZSBtaWNyb3Rhc2ssIG90aGVyd2lzZSB3ZSBzdG9wIHB1bGxpbmcgdG9vIGVhcmx5IHdoaWNoIGJyZWFrcyBhIHRlc3QuXG4gICAgICAgIC8vIEZJWE1FIElzIHRoaXMgYSBidWcgaW4gdGhlIHNwZWNpZmljYXRpb24sIG9yIGluIHRoZSB0ZXN0P1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSkpO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmV0dXJuU3RlcHModmFsdWU6IGFueSk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdmaW5pc2ggaXRlcmF0aW5nJykpO1xuICAgIH1cblxuICAgIGFzc2VydChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPT09IDApO1xuXG4gICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gIH1cbn1cblxuZGVjbGFyZSBjbGFzcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxSPiBpbXBsZW1lbnRzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIC8qKiBAaW50ZXJhbCAqL1xuICBfYXN5bmNJdGVyYXRvckltcGw6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw8Uj47XG5cbiAgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFIsIHVuZGVmaW5lZD4+O1xuXG4gIHJldHVybih2YWx1ZT86IGFueSk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8YW55Pj47XG59XG5cbmNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PiA9IHtcbiAgbmV4dCh0aGlzOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxhbnk+KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcbiAgfSxcblxuICByZXR1cm4odGhpczogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PiwgdmFsdWU6IGFueSk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JldHVybicpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG4gIH1cbn0gYXMgYW55O1xuaWYgKEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENhbmNlbDogYm9vbGVhbik6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4oc3RyZWFtKTtcbiAgY29uc3QgaW1wbCA9IG5ldyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsKHJlYWRlciwgcHJldmVudENhbmNlbCk7XG4gIGNvbnN0IGl0ZXJhdG9yOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSID0gYW55Pih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3luY0l0ZXJhdG9ySW1wbCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgcmV0dXJuICh4IGFzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4pLl9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXG4gICAgICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuY29uc3QgTnVtYmVySXNOYU46IHR5cGVvZiBOdW1iZXIuaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCAhPT0geDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlcklzTmFOO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZUFycmF5RnJvbUxpc3Q8VCBleHRlbmRzIGFueVtdPihlbGVtZW50czogVCk6IFQge1xuICAvLyBXZSB1c2UgYXJyYXlzIHRvIHJlcHJlc2VudCBsaXN0cywgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBuby1vcC5cbiAgLy8gRG8gYSBzbGljZSB0aG91Z2gganVzdCBpbiBjYXNlIHdlIGhhcHBlbiB0byBkZXBlbmQgb24gdGhlIHVuaXF1ZS1uZXNzLlxuICByZXR1cm4gZWxlbWVudHMuc2xpY2UoKSBhcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29weURhdGFCbG9ja0J5dGVzKGRlc3Q6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0T2Zmc2V0OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY09mZnNldDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuOiBudW1iZXIpIHtcbiAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XG59XG5cbi8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2ZlckFycmF5QnVmZmVyPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlckxpa2U+KE86IFQpOiBUIHtcbiAgcmV0dXJuIE87XG59XG5cbi8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBmdW5jdGlvbiBDYW5UcmFuc2ZlckFycmF5QnVmZmVyKE86IEFycmF5QnVmZmVyTGlrZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IGZ1bmN0aW9uIElzRGV0YWNoZWRCdWZmZXIoTzogQXJyYXlCdWZmZXJMaWtlKTogYm9vbGVhbiB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFycmF5QnVmZmVyU2xpY2UoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJlZ2luOiBudW1iZXIsIGVuZDogbnVtYmVyKTogQXJyYXlCdWZmZXJMaWtlIHtcbiAgLy8gQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBhdmFpbGFibGUgb24gSUUxMFxuICAvLyBodHRwczovL3d3dy5jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19hcnJheWJ1ZmZlcl9zbGljZVxuICBpZiAoYnVmZmVyLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBlbmQgLSBiZWdpbjtcbiAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgQ29weURhdGFCbG9ja0J5dGVzKHNsaWNlLCAwLCBidWZmZXIsIGJlZ2luLCBsZW5ndGgpO1xuICByZXR1cm4gc2xpY2U7XG59XG4iLCJpbXBvcnQgTnVtYmVySXNOYU4gZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNuYW4nO1xuaW1wb3J0IHsgQXJyYXlCdWZmZXJTbGljZSB9IGZyb20gJy4vZWNtYXNjcmlwdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBJc05vbk5lZ2F0aXZlTnVtYmVyKHY6IG51bWJlcik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE51bWJlcklzTmFOKHYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDbG9uZUFzVWludDhBcnJheShPOiBBcnJheUJ1ZmZlclZpZXcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgSXNOb25OZWdhdGl2ZU51bWJlciB9IGZyb20gJy4vbWlzY2VsbGFuZW91cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVDb250YWluZXI8VD4ge1xuICBfcXVldWU6IFNpbXBsZVF1ZXVlPFQ+O1xuICBfcXVldWVUb3RhbFNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWV1ZVBhaXI8VD4ge1xuICB2YWx1ZTogVDtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVxdWV1ZVZhbHVlPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8UXVldWVQYWlyPFQ+Pik6IFQge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG4gIGFzc2VydChjb250YWluZXIuX3F1ZXVlLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnNoaWZ0KCkhO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIC09IHBhaXIuc2l6ZTtcbiAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG4gICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gIH1cblxuICByZXR1cm4gcGFpci52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8UXVldWVQYWlyPFQ+PiwgdmFsdWU6IFQsIHNpemU6IG51bWJlcikge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG5cbiAgaWYgKCFJc05vbk5lZ2F0aXZlTnVtYmVyKHNpemUpIHx8IHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NpemUgbXVzdCBiZSBhIGZpbml0ZSwgbm9uLU5hTiwgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgfVxuXG4gIGNvbnRhaW5lci5fcXVldWUucHVzaCh7IHZhbHVlLCBzaXplIH0pO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQZWVrUXVldWVWYWx1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4pOiBUIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuICBhc3NlcnQoY29udGFpbmVyLl9xdWV1ZS5sZW5ndGggPiAwKTtcblxuICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG4gIHJldHVybiBwYWlyLnZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzZXRRdWV1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFQ+KSB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcblxuICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlPFQ+KCk7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xufVxuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyBSZXNldFF1ZXVlIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzLFxuICBSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIsXG4gIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzLFxuICBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIsXG4gIFJlYWRJbnRvUmVxdWVzdFxufSBmcm9tICcuL2J5b2ItcmVhZGVyJztcbmltcG9ydCBOdW1iZXJJc0ludGVnZXIgZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNpbnRlZ2VyJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgUmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgUmVhZGFibGVTdHJlYW1FcnJvclxufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgVmFsaWRhdGVkVW5kZXJseWluZ0J5dGVTb3VyY2UgfSBmcm9tICcuL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQge1xuICBBcnJheUJ1ZmZlclNsaWNlLFxuICBDYW5UcmFuc2ZlckFycmF5QnVmZmVyLFxuICBDb3B5RGF0YUJsb2NrQnl0ZXMsXG4gIElzRGV0YWNoZWRCdWZmZXIsXG4gIFRyYW5zZmVyQXJyYXlCdWZmZXJcbn0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMsIFB1bGxTdGVwcyB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IHByb21pc2VSZXNvbHZlZFdpdGgsIHVwb25Qcm9taXNlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCwgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9iYXNpYyc7XG5cbi8qKlxuICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIhOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAvKiogQGludGVybmFsICovXG4gIF92aWV3ITogQXJyYXlCdWZmZXJWaWV3IHwgbnVsbDtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2aWV3IGZvciB3cml0aW5nIGluIHRvLCBvciBgbnVsbGAgaWYgdGhlIEJZT0IgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJlc3BvbmRlZCB0by5cbiAgICovXG4gIGdldCB2aWV3KCk6IEFycmF5QnVmZmVyVmlldyB8IG51bGwge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZpZXcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdG8gdGhlIGFzc29jaWF0ZWQgcmVhZGFibGUgYnl0ZSBzdHJlYW0gdGhhdCBgYnl0ZXNXcml0dGVuYCBieXRlcyB3ZXJlIHdyaXR0ZW4gaW50b1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC52aWV3IHwgdmlld30sIGNhdXNpbmcgdGhlIHJlc3VsdCBiZSBzdXJmYWNlZCB0byB0aGUgY29uc3VtZXIuXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QudmlldyB8IHZpZXd9IHdpbGwgYmUgdHJhbnNmZXJyZWQgYW5kIG5vIGxvbmdlclxuICAgKiBtb2RpZmlhYmxlLlxuICAgKi9cbiAgcmVzcG9uZChieXRlc1dyaXR0ZW46IG51bWJlcik6IHZvaWQ7XG4gIHJlc3BvbmQoYnl0ZXNXcml0dGVuOiBudW1iZXIgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG4gICAgfVxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoYnl0ZXNXcml0dGVuLCAxLCAncmVzcG9uZCcpO1xuICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZCcpO1xuICAgIH1cblxuICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHRoaXMuX3ZpZXchLmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBCWU9CIHJlcXVlc3QncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2VgKTtcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5fdmlldyEuYnl0ZUxlbmd0aCA+IDApO1xuICAgIGFzc2VydCh0aGlzLl92aWV3IS5idWZmZXIuYnl0ZUxlbmd0aCA+IDApO1xuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRvIHRoZSBhc3NvY2lhdGVkIHJlYWRhYmxlIGJ5dGUgc3RyZWFtIHRoYXQgaW5zdGVhZCBvZiB3cml0aW5nIGludG9cbiAgICoge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QudmlldyB8IHZpZXd9LCB0aGUgdW5kZXJseWluZyBieXRlIHNvdXJjZSBpcyBwcm92aWRpbmcgYSBuZXcgYEFycmF5QnVmZmVyVmlld2AsXG4gICAqIHdoaWNoIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNvbnN1bWVyIG9mIHRoZSByZWFkYWJsZSBieXRlIHN0cmVhbS5cbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBgdmlld2Agd2lsbCBiZSB0cmFuc2ZlcnJlZCBhbmQgbm8gbG9uZ2VyIG1vZGlmaWFibGUuXG4gICAqL1xuICByZXNwb25kV2l0aE5ld1ZpZXcodmlldzogQXJyYXlCdWZmZXJWaWV3KTogdm9pZDtcbiAgcmVzcG9uZFdpdGhOZXdWaWV3KHZpZXc6IEFycmF5QnVmZmVyVmlldyB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuICAgIH1cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHZpZXcsIDEsICdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcblxuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2FuIG9ubHkgcmVzcG9uZCB3aXRoIGFycmF5IGJ1ZmZlciB2aWV3cycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZCcpO1xuICAgIH1cblxuICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGdpdmVuIHZpZXdcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIHVzZWQgYXMgYSByZXNwb25zZScpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCB7XG4gIHJlc3BvbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZXNwb25kV2l0aE5ld1ZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB2aWV3OiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuaW50ZXJmYWNlIEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlclZpZXc+IHtcbiAgbmV3KGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBieXRlT2Zmc2V0OiBudW1iZXIsIGxlbmd0aD86IG51bWJlcik6IFQ7XG5cbiAgcmVhZG9ubHkgcHJvdG90eXBlOiBUO1xuICByZWFkb25seSBCWVRFU19QRVJfRUxFTUVOVDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQnl0ZVF1ZXVlRWxlbWVudCB7XG4gIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbn1cblxudHlwZSBQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyVmlldz4gPVxuICBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yXG4gIHwgQllPQlB1bGxJbnRvRGVzY3JpcHRvcjxUPjtcblxuaW50ZXJmYWNlIERlZmF1bHRQdWxsSW50b0Rlc2NyaXB0b3Ige1xuICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZTtcbiAgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZXNGaWxsZWQ6IG51bWJlcjtcbiAgZWxlbWVudFNpemU6IG51bWJlcjtcbiAgdmlld0NvbnN0cnVjdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxVaW50OEFycmF5PjtcbiAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnO1xufVxuXG5pbnRlcmZhY2UgQllPQlB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXJWaWV3PiB7XG4gIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlO1xuICBidWZmZXJCeXRlTGVuZ3RoOiBudW1iZXI7XG4gIGJ5dGVPZmZzZXQ6IG51bWJlcjtcbiAgYnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlc0ZpbGxlZDogbnVtYmVyO1xuICBlbGVtZW50U2l6ZTogbnVtYmVyO1xuICB2aWV3Q29uc3RydWN0b3I6IEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQ+O1xuICByZWFkZXJUeXBlOiAnYnlvYic7XG59XG5cbi8qKlxuICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBieXRlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0hOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlITogU2ltcGxlUXVldWU8Qnl0ZVF1ZXVlRWxlbWVudD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGFydGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VSZXF1ZXN0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsQWdhaW4hOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsaW5nICE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5SFdNITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsQWxnb3JpdGhtITogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2FuY2VsQWxnb3JpdGhtITogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9hdXRvQWxsb2NhdGVDaHVua1NpemU6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYnlvYlJlcXVlc3Q6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgfCBudWxsO1xuICAvKiogQGludGVybmFsICovXG4gIF9wZW5kaW5nUHVsbEludG9zITogU2ltcGxlUXVldWU8UHVsbEludG9EZXNjcmlwdG9yPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEJZT0IgcHVsbCByZXF1ZXN0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgKi9cbiAgZ2V0IGJ5b2JSZXF1ZXN0KCk6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdieW9iUmVxdWVzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBieXRlIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG4gICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cbiAgICovXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkOyBkbyBub3QgY2xvc2UgaXQgYWdhaW4hJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBjaHVuayBpbiB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uXG4gICAqIFRoZSBjaHVuayBoYXMgdG8gYmUgYW4gYEFycmF5QnVmZmVyVmlld2AgaW5zdGFuY2UsIG9yIGVsc2UgYSBgVHlwZUVycm9yYCB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGVucXVldWUoY2h1bms6IEFycmF5QnVmZmVyVmlldyk6IHZvaWQ7XG4gIGVucXVldWUoY2h1bms6IEFycmF5QnVmZmVyVmlldyB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGNodW5rKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuICAgIH1cbiAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtDYW5jZWxTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKHRoaXMpO1xuXG4gICAgUmVzZXRRdWV1ZSh0aGlzKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFVpbnQ4QXJyYXk+KTogdm9pZCB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICBhc3NlcnQoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpO1xuXG4gICAgaWYgKHRoaXMuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgICAgYXNzZXJ0KFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApO1xuXG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCkhO1xuICAgICAgdGhpcy5fcXVldWVUb3RhbFNpemUgLT0gZW50cnkuYnl0ZUxlbmd0aDtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4odGhpcyk7XG5cbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xuXG4gICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyh2aWV3KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgICAgfSBjYXRjaCAoYnVmZmVyRSkge1xuICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhidWZmZXJFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3I6IERlZmF1bHRQdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICBieXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICBlbGVtZW50U2l6ZTogMSxcbiAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBVaW50OEFycmF5LFxuICAgICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBieW9iUmVxdWVzdDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoeDogYW55KTogeCBpcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogdm9pZCB7XG4gIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gIGlmICghc2hvdWxkUHVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cbiAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG4gIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwdWxsUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZSA9PiB7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICBzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3I8VD5cbikge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSAhPT0gJ2Vycm9yZWQnKTtcblxuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkID09PSAwKTtcbiAgICBkb25lID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGZpbGxlZFZpZXcgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcjxUPihwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICBpZiAocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdkZWZhdWx0Jykge1xuICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldyBhcyB1bmtub3duIGFzIFVpbnQ4QXJyYXksIGRvbmUpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2J5b2InKTtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihcbiAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3I8VD5cbik6IFQge1xuICBjb25zdCBieXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG5cbiAgYXNzZXJ0KGJ5dGVzRmlsbGVkIDw9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoKTtcbiAgYXNzZXJ0KGJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemUgPT09IDApO1xuXG4gIHJldHVybiBuZXcgcHVsbEludG9EZXNjcmlwdG9yLnZpZXdDb25zdHJ1Y3RvcihcbiAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgYnl0ZXNGaWxsZWQgLyBlbGVtZW50U2l6ZSkgYXMgVDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogbnVtYmVyKSB7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlLnB1c2goeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSk7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplICs9IGJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcblxuICBjb25zdCBjdXJyZW50QWxpZ25lZEJ5dGVzID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG5cbiAgY29uc3QgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gIGNvbnN0IG1heEJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgbWF4Qnl0ZXNUb0NvcHk7XG4gIGNvbnN0IG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gbWF4Qnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcblxuICBsZXQgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEJ5dGVzVG9Db3B5O1xuICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgaWYgKG1heEFsaWduZWRCeXRlcyA+IGN1cnJlbnRBbGlnbmVkQnl0ZXMpIHtcbiAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXVlID0gY29udHJvbGxlci5fcXVldWU7XG5cbiAgd2hpbGUgKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPiAwKSB7XG4gICAgY29uc3QgaGVhZE9mUXVldWUgPSBxdWV1ZS5wZWVrKCk7XG5cbiAgICBjb25zdCBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuXG4gICAgY29uc3QgZGVzdFN0YXJ0ID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgQ29weURhdGFCbG9ja0J5dGVzKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGRlc3RTdGFydCwgaGVhZE9mUXVldWUuYnVmZmVyLCBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0LCBieXRlc1RvQ29weSk7XG5cbiAgICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQgKz0gYnl0ZXNUb0NvcHk7XG4gICAgICBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoIC09IGJ5dGVzVG9Db3B5O1xuICAgIH1cbiAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBieXRlc1RvQ29weTtcblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblxuICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG4gIH1cblxuICBpZiAoIXJlYWR5KSB7XG4gICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKTtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkID4gMCk7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSk7XG4gIH1cblxuICByZXR1cm4gcmVhZHk7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPT09IDAgfHwgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCkgPT09IHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gIGFzc2VydChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCk7XG4gIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwICYmIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fdmlldyA9IG51bGwhO1xuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBhc3NlcnQoIWNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKTtcblxuICB3aGlsZSAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cbiAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuXG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKFxuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3JcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG88VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIHZpZXc6IFQsXG4gIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+XG4pOiB2b2lkIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBsZXQgZWxlbWVudFNpemUgPSAxO1xuICBpZiAodmlldy5jb25zdHJ1Y3RvciAhPT0gRGF0YVZpZXcpIHtcbiAgICBlbGVtZW50U2l6ZSA9ICh2aWV3LmNvbnN0cnVjdG9yIGFzIEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQ+KS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuXG4gIGNvbnN0IGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yIGFzIEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQ+O1xuXG4gIC8vIHRyeSB7XG4gIGNvbnN0IGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICAvLyB9IGNhdGNoIChlKSB7XG4gIC8vICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAvLyAgIHJldHVybjtcbiAgLy8gfVxuXG4gIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvcjogQllPQlB1bGxJbnRvRGVzY3JpcHRvcjxUPiA9IHtcbiAgICBidWZmZXIsXG4gICAgYnVmZmVyQnl0ZUxlbmd0aDogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgYnl0ZU9mZnNldDogdmlldy5ieXRlT2Zmc2V0LFxuICAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcbiAgICBieXRlc0ZpbGxlZDogMCxcbiAgICBlbGVtZW50U2l6ZSxcbiAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG4gICAgcmVhZGVyVHlwZTogJ2J5b2InXG4gIH07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gICAgLy8gTm8gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoKSBjYWxsIHNpbmNlOlxuICAgIC8vIC0gTm8gY2hhbmdlIGhhcHBlbnMgb24gZGVzaXJlZFNpemVcbiAgICAvLyAtIFRoZSBzb3VyY2UgaGFzIGFscmVhZHkgYmVlbiBub3RpZmllZCBvZiB0aGF0IHRoZXJlJ3MgYXQgbGVhc3QgMSBwZW5kaW5nIHJlYWQodmlldylcblxuICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBjb25zdCBlbXB0eVZpZXcgPSBuZXcgY3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgMCk7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGVtcHR5Vmlldyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VD4ocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG5cbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhmaWxsZWRWaWV3KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG5cbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdDxUPihzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBhc3NlcnQoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkID09PSAwKTtcblxuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICB3aGlsZSAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbjogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA8PSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCk7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKTtcblxuICBpZiAocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IHJlbWFpbmRlclNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgJSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG4gIGlmIChyZW1haW5kZXJTaXplID4gMCkge1xuICAgIGNvbnN0IGVuZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IEFycmF5QnVmZmVyU2xpY2UocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZW5kIC0gcmVtYWluZGVyU2l6ZSwgZW5kKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCByZW1haW5kZXIsIDAsIHJlbWFpbmRlci5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW46IG51bWJlcikge1xuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgYXNzZXJ0KENhblRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcikpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG5cbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGFzc2VydChieXRlc1dyaXR0ZW4gPT09IDApO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG4gICAgYXNzZXJ0KGJ5dGVzV3JpdHRlbiA+IDApO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcbik6IFB1bGxJbnRvRGVzY3JpcHRvciB7XG4gIGFzc2VydChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCkhO1xuICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpOiBib29sZWFuIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIGFzc2VydChkZXNpcmVkU2l6ZSAhPT0gbnVsbCk7XG4gIGlmIChkZXNpcmVkU2l6ZSEgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuLy8gQSBjbGllbnQgb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCA+IDApIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgY2h1bms6IEFycmF5QnVmZmVyVmlldykge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gY2h1bmsuYnVmZmVyO1xuICBjb25zdCBieXRlT2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldDtcbiAgY29uc3QgYnl0ZUxlbmd0aCA9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIGlmIChJc0RldGFjaGVkQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVua1xcJ3MgYnVmZmVyIGlzIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgZW5xdWV1ZWQnKTtcbiAgfVxuICBjb25zdCB0cmFuc2ZlcnJlZEJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoYnVmZmVyKTtcblxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIEJZT0IgcmVxdWVzdFxcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgZmlsbGVkIHdpdGggYW4gZW5xdWV1ZWQgY2h1bmsnXG4gICAgICApO1xuICAgIH1cbiAgICBmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcik7XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuXG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSkge1xuICAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG4gICAgICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPT09IDApO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKTtcbiAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpLnJlYWRlclR5cGUgPT09ICdkZWZhdWx0Jyk7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZmVycmVkVmlldyA9IG5ldyBVaW50OEFycmF5KHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgLy8gVE9ETzogSWRlYWxseSBpbiB0aGlzIGJyYW5jaCBkZXRhY2hpbmcgc2hvdWxkIGhhcHBlbiBvbmx5IGlmIHRoZSBidWZmZXIgaXMgbm90IGNvbnN1bWVkIGZ1bGx5LlxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydCghSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBlOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcik7XG5cbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG4pOiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbCB7XG4gIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCAmJiBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcblxuICAgIGNvbnN0IGJ5b2JSZXF1ZXN0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KGJ5b2JSZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KTtcbiAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IGJ5b2JSZXF1ZXN0O1xuICB9XG4gIHJldHVybiBjb250cm9sbGVyLl9ieW9iUmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuOiBudW1iZXIpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGlmIChieXRlc1dyaXR0ZW4gIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gIH1cblxuICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCk7XG4gIGFzc2VydCghSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpO1xuXG4gIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBpZiAodmlldy5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG4gICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSB2aWV3XFwncyBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSByZWFkYWJsZSBzdHJlYW0nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlckJ5dGVMZW5ndGggIT09IHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGJ1ZmZlciBvZiB2aWV3IGhhcyBkaWZmZXJlbnQgY2FwYWNpdHkgdGhhbiBieW9iUmVxdWVzdCcpO1xuICB9XG4gIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyB2aWV3LmJ5dGVMZW5ndGggPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGlzIGxhcmdlciB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG4gIH1cblxuICBjb25zdCB2aWV3Qnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIHZpZXdCeXRlTGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgYXNzZXJ0KHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpO1xuICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQoTnVtYmVySXNJbnRlZ2VyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSkpO1xuICAgIGFzc2VydChhdXRvQWxsb2NhdGVDaHVua1NpemUgPiAwKTtcbiAgfVxuXG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG5cbiAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQhO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcblxuICBjb250cm9sbGVyLl9hdXRvQWxsb2NhdGVDaHVua1NpemUgPSBhdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXG4gIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxpbmcpO1xuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9LFxuICAgIHIgPT4ge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuICAgIH1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKFxuICBzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgdW5kZXJseWluZ0J5dGVTb3VyY2U6IFZhbGlkYXRlZFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBoaWdoV2F0ZXJNYXJrOiBudW1iZXJcbikge1xuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIGxldCBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0IShjb250cm9sbGVyKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwhKHJlYXNvbik7XG4gIH1cblxuICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdXRvQWxsb2NhdGVDaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICB9XG5cbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKFxuICAgIHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplXG4gICk7XG59XG5cbmZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChyZXF1ZXN0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogQXJyYXlCdWZmZXJWaWV3KSB7XG4gIGFzc2VydChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoY29udHJvbGxlcikpO1xuICBhc3NlcnQodHlwZW9mIHZpZXcgPT09ICdvYmplY3QnKTtcbiAgYXNzZXJ0KEFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSk7XG4gIGFzc2VydCghSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpO1xuICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIHJlcXVlc3QuX3ZpZXcgPSB2aWV3O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5cblxuZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0YCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxuXG5mdW5jdGlvbiBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKTtcbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVCeXRlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQge1xuICBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50b1xufSBmcm9tICcuL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZWplY3RlZFdpdGggfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBhc3NlcnRSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IElzRGV0YWNoZWRCdWZmZXIgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5cbi8qKlxuICogQSByZXN1bHQgcmV0dXJuZWQgYnkge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5yZWFkfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4gPSB7XG4gIGRvbmU6IGZhbHNlO1xuICB2YWx1ZTogVDtcbn0gfCB7XG4gIGRvbmU6IHRydWU7XG4gIHZhbHVlOiBUIHwgdW5kZWZpbmVkO1xufTtcblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0uX3JlYWRlcikpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyk7XG5cbiAgKHN0cmVhbS5fcmVhZGVyISBhcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIpLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IEFycmF5QnVmZmVyVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogYm9vbGVhbikge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG5cbiAgYXNzZXJ0KHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPiAwKTtcblxuICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKSE7XG4gIGlmIChkb25lKSB7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBudW1iZXIge1xuICByZXR1cm4gKHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcikuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBSZWFkZXJzXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZEludG9SZXF1ZXN0PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+IHtcbiAgX2NodW5rU3RlcHMoY2h1bms6IFQpOiB2b2lkO1xuXG4gIF9jbG9zZVN0ZXBzKGNodW5rOiBUIHwgdW5kZWZpbmVkKTogdm9pZDtcblxuICBfZXJyb3JTdGVwcyhlOiBhbnkpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgQllPQiByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAvKiogQGludGVybmFsICovXG4gIF9vd25lclJlYWRhYmxlU3RyZWFtITogUmVhZGFibGVCeXRlU3RyZWFtO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkSW50b1JlcXVlc3RzOiBTaW1wbGVRdWV1ZTxSZWFkSW50b1JlcXVlc3Q8YW55Pj47XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xuICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArXG4gICAgICAgICdzb3VyY2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cbiAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICogdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICovXG4gIGdldCBjbG9zZWQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgKi9cbiAgY2FuY2VsKHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlYWRzIGJ5dGVzIGludG8gdmlldywgYW5kIHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqL1xuICByZWFkPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KHZpZXc6IFQpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3JykpO1xuICAgIH1cbiAgICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuICAgIH1cbiAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgdmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApKTtcbiAgICB9XG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4pID0+IHZvaWQ7XG4gICAgbGV0IHJlamVjdFByb21pc2UhOiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8UmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IHRydWUgfSksXG4gICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHRoaXMsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcbiAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZEludG9SZXF1ZXN0cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgdmlldzogVCxcbiAgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD5cbik6IHZvaWQge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oXG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgdmlldyxcbiAgICAgIHJlYWRJbnRvUmVxdWVzdFxuICAgICk7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cblxuZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyYCk7XG59XG4iLCJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IE51bWJlcklzTmFOIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzbmFuJztcblxuZXhwb3J0IGZ1bmN0aW9uIEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3ksIGRlZmF1bHRIV006IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG5cbiAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkZWZhdWx0SFdNO1xuICB9XG5cbiAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgaGlnaFdhdGVyTWFyaycpO1xuICB9XG5cbiAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobTxUPihzdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFQ+KTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFQ+IHtcbiAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcblxuICBpZiAoIXNpemUpIHtcbiAgICByZXR1cm4gKCkgPT4gMTtcbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uLCBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIH0gZnJvbSAnLi9iYXNpYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5PFQ+KGluaXQ6IFF1ZXVpbmdTdHJhdGVneTxUPiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3k8VD4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xuICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdD8uaGlnaFdhdGVyTWFyaztcbiAgY29uc3Qgc2l6ZSA9IGluaXQ/LnNpemU7XG4gIHJldHVybiB7XG4gICAgaGlnaFdhdGVyTWFyazogaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSxcbiAgICBzaXplOiBzaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShzaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemU8VD4oZm46IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIGNodW5rID0+IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoZm4oY2h1bmspKTtcbn1cbiIsImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBwcm9taXNlQ2FsbCwgcmVmbGVjdENhbGwgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nU2lua1xufSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0vdW5kZXJseWluZy1zaW5rJztcbmltcG9ydCB7IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rPFc+KG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luazxXPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rPFc+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGFib3J0ID0gb3JpZ2luYWw/LmFib3J0O1xuICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsPy5jbG9zZTtcbiAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbD8uc3RhcnQ7XG4gIGNvbnN0IHR5cGUgPSBvcmlnaW5hbD8udHlwZTtcbiAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbD8ud3JpdGU7XG4gIHJldHVybiB7XG4gICAgYWJvcnQ6IGFib3J0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICBjbG9zZTogY2xvc2UgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxuICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgd3JpdGU6IHdyaXRlID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luayxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAocmVhc29uOiBhbnkpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKCkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrIHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPihcbiAgZm46IFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPixcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rPFc+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbn1cbiIsImltcG9ydCB7IElzV3JpdGFibGVTdHJlYW0sIFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFdyaXRhYmxlU3RyZWFtKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBXcml0YWJsZVN0cmVhbSB7XG4gIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQSBzaWduYWwgb2JqZWN0IHRoYXQgYWxsb3dzIHlvdSB0byBjb21tdW5pY2F0ZSB3aXRoIGEgcmVxdWVzdCBhbmQgYWJvcnQgaXQgaWYgcmVxdWlyZWRcbiAqIHZpYSBpdHMgYXNzb2NpYXRlZCBgQWJvcnRDb250cm9sbGVyYCBvYmplY3QuXG4gKlxuICogQHJlbWFya3NcbiAqICAgVGhpcyBpbnRlcmZhY2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBgQWJvcnRTaWduYWxgIGludGVyZmFjZSBkZWZpbmVkIGluIFR5cGVTY3JpcHQncyBET00gdHlwZXMuXG4gKiAgIEl0IGlzIHJlZGVmaW5lZCBoZXJlLCBzbyBpdCBjYW4gYmUgcG9seWZpbGxlZCB3aXRob3V0IGEgRE9NLCBmb3IgZXhhbXBsZSB3aXRoXG4gKiAgIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwgfCBhYm9ydGNvbnRyb2xsZXItcG9seWZpbGx9IGluIGEgTm9kZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWJvcnRTaWduYWwge1xuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhYm9ydGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgYWJvcnRlZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgc2lnbmFsIGJlY29tZXMgYWJvcnRlZC5cbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZTogJ2Fib3J0JywgbGlzdGVuZXI6ICgpID0+IHZvaWQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCB3YXMgcHJldmlvdXNseSBhZGRlZCB3aXRoIHtAbGluayBBYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyfS5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZTogJ2Fib3J0JywgbGlzdGVuZXI6ICgpID0+IHZvaWQpOiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBYm9ydFNpZ25hbCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEFib3J0U2lnbmFsIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mICh2YWx1ZSBhcyBBYm9ydFNpZ25hbCkuYWJvcnRlZCA9PT0gJ2Jvb2xlYW4nO1xuICB9IGNhdGNoIHtcbiAgICAvLyBBYm9ydFNpZ25hbC5wcm90b3R5cGUuYWJvcnRlZCB0aHJvd3MgaWYgaXRzIGJyYW5kIGNoZWNrIGZhaWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQSBjb250cm9sbGVyIG9iamVjdCB0aGF0IGFsbG93cyB5b3UgdG8gYWJvcnQgYW4gYEFib3J0U2lnbmFsYCB3aGVuIGRlc2lyZWQuXG4gKlxuICogQHJlbWFya3NcbiAqICAgVGhpcyBpbnRlcmZhY2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBgQWJvcnRDb250cm9sbGVyYCBpbnRlcmZhY2UgZGVmaW5lZCBpbiBUeXBlU2NyaXB0J3MgRE9NIHR5cGVzLlxuICogICBJdCBpcyByZWRlZmluZWQgaGVyZSwgc28gaXQgY2FuIGJlIHBvbHlmaWxsZWQgd2l0aG91dCBhIERPTSwgZm9yIGV4YW1wbGUgd2l0aFxuICogICB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsIHwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsfSBpbiBhIE5vZGUgZW52aXJvbm1lbnQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWJvcnRDb250cm9sbGVyIHtcbiAgcmVhZG9ubHkgc2lnbmFsOiBBYm9ydFNpZ25hbDtcblxuICBhYm9ydCgpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgQWJvcnRDb250cm9sbGVyQ29uc3RydWN0b3Ige1xuICBuZXcoKTogQWJvcnRDb250cm9sbGVyO1xufVxuXG5jb25zdCBzdXBwb3J0c0Fib3J0Q29udHJvbGxlciA9IHR5cGVvZiAoQWJvcnRDb250cm9sbGVyIGFzIGFueSkgPT09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQ29uc3RydWN0IGEgbmV3IEFib3J0Q29udHJvbGxlciwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWQge1xuICBpZiAoc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gbmV3IChBYm9ydENvbnRyb2xsZXIgYXMgQWJvcnRDb250cm9sbGVyQ29uc3RydWN0b3IpKCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdXBvblByb21pc2Vcbn0gZnJvbSAnLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBEZXF1ZXVlVmFsdWUsXG4gIEVucXVldWVWYWx1ZVdpdGhTaXplLFxuICBQZWVrUXVldWVWYWx1ZSxcbiAgUXVldWVQYWlyLFxuICBSZXNldFF1ZXVlXG59IGZyb20gJy4vYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMnO1xuaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBBYm9ydFN0ZXBzLCBFcnJvclN0ZXBzIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQge1xuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nU2lua1xufSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbS91bmRlcmx5aW5nLXNpbmsnO1xuaW1wb3J0IHsgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRVbmRlcmx5aW5nU2luayB9IGZyb20gJy4vdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNpbmsnO1xuaW1wb3J0IHsgYXNzZXJ0V3JpdGFibGVTdHJlYW0gfSBmcm9tICcuL3ZhbGlkYXRvcnMvd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IEFib3J0Q29udHJvbGxlciwgQWJvcnRTaWduYWwsIGNyZWF0ZUFib3J0Q29udHJvbGxlciB9IGZyb20gJy4vYWJvcnQtc2lnbmFsJztcblxudHlwZSBXcml0YWJsZVN0cmVhbVN0YXRlID0gJ3dyaXRhYmxlJyB8ICdjbG9zZWQnIHwgJ2Vycm9yaW5nJyB8ICdlcnJvcmVkJztcblxuaW50ZXJmYWNlIFdyaXRlT3JDbG9zZVJlcXVlc3Qge1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG59XG5cbnR5cGUgV3JpdGVSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcbnR5cGUgQ2xvc2VSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcblxuaW50ZXJmYWNlIFBlbmRpbmdBYm9ydFJlcXVlc3Qge1xuICBfcHJvbWlzZTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIF9yZWFzb246IGFueTtcbiAgX3dhc0FscmVhZHlFcnJvcmluZzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFdyaXRhYmxlU3RyZWFtPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBXcml0YWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyITogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGVSZXF1ZXN0cyE6IFNpbXBsZVF1ZXVlPFdyaXRlUmVxdWVzdD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luRmxpZ2h0V3JpdGVSZXF1ZXN0OiBXcml0ZVJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9pbkZsaWdodENsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9wZW5kaW5nQWJvcnRSZXF1ZXN0OiBQZW5kaW5nQWJvcnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9iYWNrcHJlc3N1cmUhOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTaW5rPzogVW5kZXJseWluZ1Npbms8Vz4sIHN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PFc+KTtcbiAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1Npbms6IFVuZGVybHlpbmdTaW5rPFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1VuZGVybHlpbmdTaW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG5cbiAgICBjb25zdCB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcblxuICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cbiAgICovXG4gIGdldCBsb2NrZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdsb2NrZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG4gICAqIGltbWVkaWF0ZWx5IG1vdmVkIHRvIGFuIGVycm9yZWQgc3RhdGUsIHdpdGggYW55IHF1ZXVlZC11cCB3cml0ZXMgZGlzY2FyZGVkLiBUaGlzIHdpbGwgYWxzbyBleGVjdXRlIGFueSBhYm9ydFxuICAgKiBtZWNoYW5pc20gb2YgdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIGlmIHRoZSBzdHJlYW0gc2h1dHMgZG93biBzdWNjZXNzZnVsbHksIG9yIHJlamVjdCBpZiB0aGUgdW5kZXJseWluZyBzaW5rIHNpZ25hbGVkXG4gICAqIHRoYXQgdGhlcmUgd2FzIGFuIGVycm9yIGRvaW5nIHNvLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGggYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbFxuICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAqL1xuICBhYm9ydChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuICAgKiBjbG9zZSBiZWhhdmlvci4gRHVyaW5nIHRoaXMgdGltZSBhbnkgZnVydGhlciBhdHRlbXB0cyB0byB3cml0ZSB3aWxsIGZhaWwgKHdpdGhvdXQgZXJyb3JpbmcgdGhlIHN0cmVhbSkuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG4gICAqIHN1Y2Nlc3NmdWxseSBjbG9zZXMsIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcy4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoXG4gICAqIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWwgdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgfVxuXG4gICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cbiAgICogaXMgbG9ja2VkLCBubyBvdGhlciB3cml0ZXIgY2FuIGJlIGFjcXVpcmVkIHVudGlsIHRoaXMgb25lIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxuICAgKiB3aXRob3V0IGludGVycnVwdGlvbiBvciBpbnRlcmxlYXZpbmcuIEJ5IGdldHRpbmcgYSB3cml0ZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiB3cml0ZSBhdFxuICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuICAgKi9cbiAgZ2V0V3JpdGVyKCk6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRXcml0ZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgQ3JlYXRlV3JpdGFibGVTdHJlYW0sXG4gIElzV3JpdGFibGVTdHJlYW0sXG4gIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQsXG4gIFdyaXRhYmxlU3RyZWFtLFxuICBXcml0YWJsZVN0cmVhbUFib3J0LFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbixcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUsXG4gIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0LFxuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrXG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPik6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XG59XG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5mdW5jdGlvbiBDcmVhdGVXcml0YWJsZVN0cmVhbTxXPihzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVBbGdvcml0aG06IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcmsgPSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+ID0gKCkgPT4gMSkge1xuICBhc3NlcnQoSXNOb25OZWdhdGl2ZU51bWJlcihoaWdoV2F0ZXJNYXJrKSk7XG5cbiAgY29uc3Qgc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPiA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPiA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbTxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+KSB7XG4gIHN0cmVhbS5fc3RhdGUgPSAnd3JpdGFibGUnO1xuXG4gIC8vIFRoZSBlcnJvciB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgYnkgbmV3IG1ldGhvZCBjYWxscyBvbmNlIHRoZSBzdGF0ZSBiZWNvbWVzIGVycm9yZWQuIE9ubHkgc2V0IHdoZW4gW1tzdGF0ZV1dIGlzXG4gIC8vICdlcnJvcmluZycgb3IgJ2Vycm9yZWQnLiBNYXkgYmUgc2V0IHRvIGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblxuICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcblxuICAvLyBJbml0aWFsaXplIHRvIHVuZGVmaW5lZCBmaXJzdCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbGxlciBjaGVja3MgdGhpc1xuICAvLyB2YXJpYWJsZSB0byB2YWxpZGF0ZSB0aGUgY2FsbGVyLlxuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG5cbiAgLy8gVGhpcyBxdWV1ZSBpcyBwbGFjZWQgaGVyZSBpbnN0ZWFkIG9mIHRoZSB3cml0ZXIgY2xhc3MgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cml0ZXIgdG8gdGhlIG5leHQgZGF0YVxuICAvLyBwcm9kdWNlciB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBxdWV1ZWQgd3JpdGVzIHRvIGZpbmlzaC5cbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cbiAgLy8gV3JpdGUgcmVxdWVzdHMgYXJlIHJlbW92ZWQgZnJvbSBfd3JpdGVSZXF1ZXN0cyB3aGVuIHdyaXRlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHNcbiAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG4gIC8vIGhhcyBiZWVuIGRldGFjaGVkLlxuICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBDbG9zZSByZXF1ZXN0IGlzIHJlbW92ZWQgZnJvbSBfY2xvc2VSZXF1ZXN0IHdoZW4gY2xvc2UoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50cyBpdFxuICAvLyBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIGNsb3NlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmFib3J0KCkuIFRoaXMgbWF5IGFsc28gYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXIgaGFzIGRldGFjaGVkLlxuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVGhlIGJhY2twcmVzc3VyZSBzaWduYWwgc2V0IGJ5IHRoZSBjb250cm9sbGVyLlxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFdyaXRhYmxlU3RyZWFtIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRSZWFzb24gPSByZWFzb247XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG5cbiAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuICAvLyBidXQgaXQgZG9lc24ndCBrbm93IHRoYXQgc2lnbmFsaW5nIGFib3J0IHJ1bnMgYXV0aG9yIGNvZGUgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQgdGhlIHN0YXRlLlxuICAvLyBXaWRlbiB0aGUgdHlwZSBhZ2FpbiBieSBjYXN0aW5nIHRvIFdyaXRhYmxlU3RyZWFtU3RhdGUuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZSBhcyBXcml0YWJsZVN0cmVhbVN0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICB3YXNBbHJlYWR5RXJyb3JpbmcgPSB0cnVlO1xuICAgIC8vIHJlYXNvbiB3aWxsIG5vdCBiZSB1c2VkLCBzbyBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0LlxuICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcbiAgICAgIF9wcm9taXNlOiB1bmRlZmluZWQhLFxuICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgICBfcmVhc29uOiByZWFzb24sXG4gICAgICBfd2FzQWxyZWFkeUVycm9yaW5nOiB3YXNBbHJlYWR5RXJyb3JpbmdcbiAgICB9O1xuICB9KTtcbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0IS5fcHJvbWlzZSA9IHByb21pc2U7XG5cbiAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxhbnk+KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFxuICAgICAgYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHdyaXRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCkpO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgYXNzZXJ0KCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKTtcblxuICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjbG9zZVJlcXVlc3Q6IENsb3NlUmVxdWVzdCA9IHtcbiAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgfTtcblxuICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuICB9KTtcblxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFdyaXRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgd3JpdGVSZXF1ZXN0OiBXcml0ZVJlcXVlc3QgPSB7XG4gICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgIH07XG5cbiAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RvcmVkRXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIGFzc2VydChjb250cm9sbGVyICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICB9XG5cbiAgaWYgKCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkgJiYgY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICBhc3NlcnQoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSk7XG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Vycm9yU3RlcHNdKCk7XG5cbiAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCh3cml0ZVJlcXVlc3QgPT4ge1xuICAgIHdyaXRlUmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgfSk7XG4gIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhYm9ydFJlcXVlc3QgPSBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3Q7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltBYm9ydFN0ZXBzXShhYm9ydFJlcXVlc3QuX3JlYXNvbik7XG4gIHVwb25Qcm9taXNlKFxuICAgIHByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgfSxcbiAgICAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHJlYXNvbik7XG4gICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IS5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCEuX3JlamVjdChlcnJvcik7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QhLl9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgLy8gVGhlIGVycm9yIHdhcyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZywgc28gaXQgaXMgaWdub3JlZC5cbiAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuXG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuXG4gIGFzc2VydChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3N0b3JlZEVycm9yID09PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCEuX3JlamVjdChlcnJvcik7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgLy8gTmV2ZXIgZXhlY3V0ZSBzaW5rIGFib3J0KCkgYWZ0ZXIgc2luayBjbG9zZSgpLlxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG59XG5cbi8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0ZVJlcXVlc3RzLmxlbmd0aCAhPT0gMCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpO1xuICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuXG4gICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBiYWNrcHJlc3N1cmU6IGJvb2xlYW4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuICBhc3NlcnQoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpO1xuXG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgIGlmIChiYWNrcHJlc3N1cmUpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoIWJhY2twcmVzc3VyZSk7XG5cbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHdyaXRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX293bmVyV3JpdGFibGVTdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlU3RhdGUhOiAncGVuZGluZycgfCAncmVzb2x2ZWQnIHwgJ3JlamVjdGVkJztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlU3RhdGUhOiAncGVuZGluZycgfCAnZnVsZmlsbGVkJyB8ICdyZWplY3RlZCc7XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPikge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyk7XG4gICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5fd3JpdGVyID0gdGhpcztcblxuICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoc3RhdGUgPT09ICdlcnJvcmVkJyk7XG5cbiAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgKi9cbiAgZ2V0IGNsb3NlZCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cbiAgICpcbiAgICogSXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gKGR1ZSB0byBlaXRoZXIgYmVpbmcgZXJyb3JlZCwgb3IgaGF2aW5nIGFuIGFib3J0XG4gICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLlxuICAgKi9cbiAgZ2V0IGRlc2lyZWRTaXplKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlIHRyYW5zaXRpb25zXG4gICAqIGZyb20gbm9uLXBvc2l0aXZlIHRvIHBvc2l0aXZlLCBzaWduYWxpbmcgdGhhdCBpdCBpcyBubyBsb25nZXIgYXBwbHlpbmcgYmFja3ByZXNzdXJlLiBPbmNlIHRoZSBkZXNpcmVkIHNpemUgZGlwc1xuICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogSWYgdGhlIHN0cmVhbSBiZWNvbWVzIGVycm9yZWQgb3IgYWJvcnRlZCwgb3IgdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZWNvbWVcbiAgICogcmVqZWN0ZWQuXG4gICAqL1xuICBnZXQgcmVhZHkoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZHknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uYWJvcnQgfCBzdHJlYW0uYWJvcnQocmVhc29uKX0uXG4gICAqL1xuICBhYm9ydChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmNsb3NlIHwgc3RyZWFtLmNsb3NlKCl9LlxuICAgKi9cbiAgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5IGZyb21cbiAgICogbm93IG9uOyBvdGhlcndpc2UsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGxvY2sgY2FuIHN0aWxsIGJlIHJlbGVhc2VkIGV2ZW4gaWYgc29tZSBvbmdvaW5nIHdyaXRlcyBoYXZlIG5vdCB5ZXQgZmluaXNoZWQgKGkuZS4gZXZlbiBpZiB0aGVcbiAgICogcHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBwcmV2aW91cyBjYWxscyB0byB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLndyaXRlIHwgd3JpdGUoKX0gaGF2ZSBub3QgeWV0IHNldHRsZWQpLlxuICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXG4gICAqIG90aGVyIHByb2R1Y2VycyBmcm9tIHdyaXRpbmcgaW4gYW4gaW50ZXJsZWF2ZWQgbWFubmVyLlxuICAgKi9cbiAgcmVsZWFzZUxvY2soKTogdm9pZCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFzc2VydChzdHJlYW0uX3dyaXRlciAhPT0gdW5kZWZpbmVkKTtcblxuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBnaXZlbiBjaHVuayB0byB0aGUgd3JpdGFibGUgc3RyZWFtLCBieSB3YWl0aW5nIHVudGlsIGFueSBwcmV2aW91cyB3cml0ZXMgaGF2ZSBmaW5pc2hlZCBzdWNjZXNzZnVsbHksXG4gICAqIGFuZCB0aGVuIHNlbmRpbmcgdGhlIGNodW5rIHRvIHRoZSB1bmRlcmx5aW5nIHNpbmsncyB7QGxpbmsgVW5kZXJseWluZ1Npbmsud3JpdGUgfCB3cml0ZSgpfSBtZXRob2QuIEl0IHdpbGwgcmV0dXJuXG4gICAqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdW5kZWZpbmVkIHVwb24gYSBzdWNjZXNzZnVsIHdyaXRlLCBvciByZWplY3RzIGlmIHRoZSB3cml0ZSBmYWlscyBvciBzdHJlYW0gYmVjb21lc1xuICAgKiBlcnJvcmVkIGJlZm9yZSB0aGUgd3JpdGluZyBwcm9jZXNzIGlzIGluaXRpYXRlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdoYXQgXCJzdWNjZXNzXCIgbWVhbnMgaXMgdXAgdG8gdGhlIHVuZGVybHlpbmcgc2luazsgaXQgbWlnaHQgaW5kaWNhdGUgc2ltcGx5IHRoYXQgdGhlIGNodW5rIGhhcyBiZWVuXG4gICAqIGFjY2VwdGVkLCBhbmQgbm90IG5lY2Vzc2FyaWx5IHRoYXQgaXQgaXMgc2FmZWx5IHNhdmVkIHRvIGl0cyB1bHRpbWF0ZSBkZXN0aW5hdGlvbi5cbiAgICovXG4gIHdyaXRlKGNodW5rOiBXKTogUHJvbWlzZTx2b2lkPjtcbiAgd3JpdGUoY2h1bms6IFcgPSB1bmRlZmluZWQhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUodGhpcywgY2h1bmspO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFcgPSBhbnk+KHg6IGFueSk6IHggaXMgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX293bmVyV3JpdGFibGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xufVxuXG4vLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCBlcnJvcjogYW55KSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIGVycm9yOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0ZXIgPT09IHdyaXRlcik7XG5cbiAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcblxuICAvLyBUaGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gXCJlcnJvcmVkXCIgYmVmb3JlIHRoZSBzaW5rIGFib3J0KCkgbWV0aG9kIHJ1bnMsIGJ1dCB0aGUgd3JpdGVyLmNsb3NlZCBwcm9taXNlIGlzIG5vdFxuICAvLyByZWplY3RlZCB1bnRpbCBhZnRlcndhcmRzLiBUaGlzIG1lYW5zIHRoYXQgc2ltcGx5IHRlc3Rpbmcgc3RhdGUgd2lsbCBub3Qgd29yay5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cbiAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlPFc+KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+LCBjaHVuazogVyk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdCBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcblxuICBpZiAoc3RyZWFtICE9PSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG8nKSk7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IHByb21pc2UgPSBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pO1xuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuY29uc3QgY2xvc2VTZW50aW5lbDogdW5pcXVlIHN5bWJvbCA9IHt9IGFzIGFueTtcblxudHlwZSBRdWV1ZVJlY29yZDxXPiA9IFcgfCB0eXBlb2YgY2xvc2VTZW50aW5lbDtcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSE6IFdyaXRhYmxlU3RyZWFtPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPFF1ZXVlUGFpcjxRdWV1ZVJlY29yZDxXPj4+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZVRvdGFsU2l6ZSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWJvcnRSZWFzb246IGFueTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXJ0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneVNpemVBbGdvcml0aG0hOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5SFdNITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZUFsZ29yaXRobSE6IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHdoaWNoIHdhcyBwYXNzZWQgdG8gYFdyaXRhYmxlU3RyZWFtLmFib3J0KHJlYXNvbilgIHdoZW4gdGhlIHN0cmVhbSB3YXMgYWJvcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL3B1bGwvMTE3Ny5cbiAgICogIFVzZSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5zaWduYWx9J3MgYHJlYXNvbmAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhYm9ydFJlYXNvbigpOiBhbnkge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0UmVhc29uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hYm9ydFJlYXNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBgQWJvcnRTaWduYWxgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWJvcnQgdGhlIHBlbmRpbmcgd3JpdGUgb3IgY2xvc2Ugb3BlcmF0aW9uIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm9ydGVkLlxuICAgKi9cbiAgZ2V0IHNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignc2lnbmFsJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgb3Igb2xkZXIgTm9kZSB2ZXJzaW9ucyBtYXkgbm90IHN1cHBvcnQgYEFib3J0Q29udHJvbGxlcmAgb3IgYEFib3J0U2lnbmFsYC5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnVuZGxlIGFuZCBzaGlwIGFuIGBBYm9ydENvbnRyb2xsZXJgIHBvbHlmaWxsIHRvZ2V0aGVyIHdpdGggb3VyIHBvbHlmaWxsLFxuICAgICAgLy8gc28gaW5zdGVhZCB3ZSBvbmx5IGltcGxlbWVudCBzdXBwb3J0IGZvciBgc2lnbmFsYCBpZiB3ZSBmaW5kIGEgZ2xvYmFsIGBBYm9ydENvbnRyb2xsZXJgIGNvbnN0cnVjdG9yLlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHdyaXRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJhcmVseSB1c2VkLCBzaW5jZSB1c3VhbGx5IGl0IHN1ZmZpY2VzIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZnJvbSBvbmUgb2YgdGhlIHVuZGVybHlpbmdcbiAgICogc2luaydzIG1ldGhvZHMuIEhvd2V2ZXIsIGl0IGNhbiBiZSB1c2VmdWwgZm9yIHN1ZGRlbmx5IHNodXR0aW5nIGRvd24gYSBzdHJlYW0gaW4gcmVzcG9uc2UgdG8gYW4gZXZlbnQgb3V0c2lkZSB0aGVcbiAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gJ3dyaXRhYmxlJykge1xuICAgICAgLy8gVGhlIHN0cmVhbSBpcyBjbG9zZWQsIGVycm9yZWQgb3Igd2lsbCBiZSBzb29uLiBUaGUgc2luayBjYW4ndCBkbyBhbnl0aGluZyB1c2VmdWwgaWYgaXQgZ2V0cyBhbiBlcnJvciBoZXJlLCBzb1xuICAgICAgLy8ganVzdCB0cmVhdCBpdCBhcyBhIG5vLW9wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0Fib3J0U3RlcHNdKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtFcnJvclN0ZXBzXSgpIHtcbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGltcGxlbWVudGluZyBpbnRlcmZhY2UgcmVxdWlyZWQgYnkgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeDogYW55KTogeCBpcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPikge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpO1xuXG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcblxuICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcbiAgdXBvblByb21pc2UoXG4gICAgc3RhcnRQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgcik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1Npbms8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmx5aW5nU2luazogVmFsaWRhdGVkVW5kZXJseWluZ1Npbms8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPikge1xuICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIGxldCB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIGxldCBhYm9ydEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLndyaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB3cml0ZUFsZ29yaXRobSA9IGNodW5rID0+IHVuZGVybHlpbmdTaW5rLndyaXRlIShjaHVuaywgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlISgpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQhKHJlYXNvbik7XG4gIH1cblxuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xufVxuXG4vLyBDbGVhckFsZ29yaXRobXMgbWF5IGJlIGNhbGxlZCB0d2ljZS4gRXJyb3JpbmcgdGhlIHNhbWUgc3RyZWFtIGluIG11bHRpcGxlIHdheXMgd2lsbCBvZnRlbiByZXN1bHQgaW4gcmVkdW5kYW50IGNhbGxzLlxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4pIHtcbiAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogVyk6IG51bWJlciB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogbnVtYmVyIHtcbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogbnVtYmVyKSB7XG4gIHRyeSB7XG4gICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgfVxuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZDxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBhc3NlcnQoc3RhdGUgIT09ICdjbG9zZWQnICYmIHN0YXRlICE9PSAnZXJyb3JlZCcpO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlcnJvcjogYW55KSB7XG4gIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblxuICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApO1xuXG4gIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICB1cG9uUHJvbWlzZShcbiAgICBzaW5rQ2xvc2VQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pO1xuICAgIH0sXG4gICAgcmVhc29uID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sIGNodW5rOiBXKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSk7XG5cbiAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcbiAgdXBvblByb21pc2UoXG4gICAgc2lua1dyaXRlUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKTtcblxuICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuXG4gICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgfVxuXG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByZWFzb24gPT4ge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IGJvb2xlYW4ge1xuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG59XG5cbi8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlcnJvcjogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbWApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG5cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJyk7XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgIT09ICdwZW5kaW5nJyk7XG5cbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJyk7XG5cbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3Jlc29sdmVkJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX3JlYWR5UHJvbWlzZSk7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuZXhwb3J0IGNvbnN0IE5hdGl2ZURPTUV4Y2VwdGlvbjogdHlwZW9mIERPTUV4Y2VwdGlvbiB8IHVuZGVmaW5lZCA9XG4gIHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnID8gRE9NRXhjZXB0aW9uIDogdW5kZWZpbmVkO1xuIiwiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cbmltcG9ydCB7IE5hdGl2ZURPTUV4Y2VwdGlvbiB9IGZyb20gJy4vbmF0aXZlJztcblxuZGVjbGFyZSBjbGFzcyBET01FeGNlcHRpb25DbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZywgbmFtZT86IHN0cmluZyk7XG5cbiAgbmFtZTogc3RyaW5nO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbnR5cGUgRE9NRXhjZXB0aW9uID0gRE9NRXhjZXB0aW9uQ2xhc3M7XG50eXBlIERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yID0gdHlwZW9mIERPTUV4Y2VwdGlvbkNsYXNzO1xuXG5mdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3I6IHVua25vd24pOiBjdG9yIGlzIERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIHtcbiAgaWYgKCEodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGN0b3IgPT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIG5ldyAoY3RvciBhcyBET01FeGNlcHRpb25Db25zdHJ1Y3RvcikoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCk6IERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBjb25zdCBjdG9yID0gZnVuY3Rpb24gRE9NRXhjZXB0aW9uKHRoaXM6IERPTUV4Y2VwdGlvbiwgbWVzc2FnZT86IHN0cmluZywgbmFtZT86IHN0cmluZykge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnRXJyb3InO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICB9IGFzIGFueTtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgeyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIGN0b3I7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IERPTUV4Y2VwdGlvbjogRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IgPVxuICBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuXG5leHBvcnQgeyBET01FeGNlcHRpb24gfTtcbiIsImltcG9ydCB7IElzUmVhZGFibGVTdHJlYW0sIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsIFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbUNhbmNlbCB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkIH0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIH0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLFxuICBJc1dyaXRhYmxlU3RyZWFtLFxuICBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkLFxuICBXcml0YWJsZVN0cmVhbSxcbiAgV3JpdGFibGVTdHJlYW1BYm9ydCxcbiAgV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24sXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlXG59IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7XG4gIG5ld1Byb21pc2UsXG4gIFBlcmZvcm1Qcm9taXNlVGhlbixcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdXBvbkZ1bGZpbGxtZW50LFxuICB1cG9uUHJvbWlzZSxcbiAgdXBvblJlamVjdGlvblxufSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQWJvcnRTaWduYWwsIGlzQWJvcnRTaWduYWwgfSBmcm9tICcuLi9hYm9ydC1zaWduYWwnO1xuaW1wb3J0IHsgRE9NRXhjZXB0aW9uIH0gZnJvbSAnLi4vLi4vc3R1Yi9kb20tZXhjZXB0aW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvPFQ+KHNvdXJjZTogUmVhZGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogV3JpdGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENsb3NlOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRBYm9ydDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzb3VyY2UpKTtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW0oZGVzdCkpO1xuICBhc3NlcnQodHlwZW9mIHByZXZlbnRDbG9zZSA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHR5cGVvZiBwcmV2ZW50QWJvcnQgPT09ICdib29sZWFuJyk7XG4gIGFzc2VydCh0eXBlb2YgcHJldmVudENhbmNlbCA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHNpZ25hbCA9PT0gdW5kZWZpbmVkIHx8IGlzQWJvcnRTaWduYWwoc2lnbmFsKSk7XG4gIGFzc2VydCghSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzb3VyY2UpKTtcbiAgYXNzZXJ0KCFJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3QpKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFQ+KHNvdXJjZSk7XG4gIGNvbnN0IHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VD4oZGVzdCk7XG5cbiAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3BlYydzIHJlcXVpcmVtZW50IHRoYXQgd2Ugd2FpdCBmb3Igb25nb2luZyB3cml0ZXMgZHVyaW5nIHNodXRkb3duLlxuICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aDx2b2lkPih1bmRlZmluZWQpO1xuXG4gIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgYWJvcnRBbGdvcml0aG06ICgpID0+IHZvaWQ7XG4gICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcbiAgICAgICAgY29uc3QgYWN0aW9uczogQXJyYXk8KCkgPT4gUHJvbWlzZTx2b2lkPj4gPSBbXTtcbiAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBhY3Rpb24oKSkpLCB0cnVlLCBlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRBbGdvcml0aG0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgcmVhZGVyIGFuZCB3cml0ZXIsIHJlYWQgYWxsIGNodW5rcyBmcm9tIHRoaXMgYW5kIHdyaXRlIHRoZW0gdG8gZGVzdFxuICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcbiAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcbiAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcbiAgICAgIHJldHVybiBuZXdQcm9taXNlPHZvaWQ+KChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmU6IGJvb2xlYW4pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZUxvb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gYWRkaW5nIHVubmVjZXNzYXJ5IGAuY2F0Y2gocmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKWAgaGFuZGxlcnNcbiAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwaXBlU3RlcCgpLCBuZXh0LCByZWplY3RMb29wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBpcGVTdGVwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTxib29sZWFuPigocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKFxuICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVhZChmYWxzZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUmVhZCh0cnVlKSxcbiAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlamVjdFJlYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG4gICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcblxuICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWQpLCB0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxuICAgICAgLy8gZm9yIHRoYXQgdG9vLlxuICAgICAgY29uc3Qgb2xkQ3VycmVudFdyaXRlID0gY3VycmVudFdyaXRlO1xuICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihcbiAgICAgICAgY3VycmVudFdyaXRlLFxuICAgICAgICAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtIHwgV3JpdGFibGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKHJlYXNvbjogYW55KSA9PiB2b2lkKSB7XG4gICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtIHwgV3JpdGFibGVTdHJlYW0sIHByb21pc2U6IFByb21pc2U8dm9pZD4sIGFjdGlvbjogKCkgPT4gdm9pZCkge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbjogKCkgPT4gUHJvbWlzZTx1bmtub3duPiwgb3JpZ2luYWxJc0Vycm9yPzogYm9vbGVhbiwgb3JpZ2luYWxFcnJvcj86IGFueSkge1xuICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXG4gICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvVGhlUmVzdCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKFxuICAgICAgICAgIGFjdGlvbigpLFxuICAgICAgICAgICgpID0+IGZpbmFsaXplKG9yaWdpbmFsSXNFcnJvciwgb3JpZ2luYWxFcnJvciksXG4gICAgICAgICAgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2h1dGRvd24oaXNFcnJvcj86IGJvb2xlYW4sIGVycm9yPzogYW55KSB7XG4gICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG5cbiAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3I/OiBib29sZWFuLCBlcnJvcj86IGFueSkge1xuICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXG4gICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IERlcXVldWVWYWx1ZSwgRW5xdWV1ZVZhbHVlV2l0aFNpemUsIFF1ZXVlUGFpciwgUmVzZXRRdWV1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyxcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1DbG9zZSwgUmVhZGFibGVTdHJlYW1FcnJvciB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRVbmRlcmx5aW5nU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMsIFB1bGxTdGVwcyB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IHByb21pc2VSZXNvbHZlZFdpdGgsIHVwb25Qcm9taXNlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtITogUmVhZGFibGVTdHJlYW08Uj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlITogU2ltcGxlUXVldWU8UXVldWVQYWlyPFI+PjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWVUb3RhbFNpemUhOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXJ0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZVJlcXVlc3RlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBZ2FpbiE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxpbmcgITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lTaXplQWxnb3JpdGhtITogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG4gICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cbiAgICovXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBgY2h1bmtgIGluIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS5cbiAgICovXG4gIGVucXVldWUoY2h1bms6IFIpOiB2b2lkO1xuICBlbnF1ZXVlKGNodW5rOiBSID0gdW5kZWZpbmVkISk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAqL1xuICBlcnJvcihlOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0NhbmNlbFN0ZXBzXShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4pOiB2b2lkIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBEZXF1ZXVlVmFsdWUodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSID0gYW55Pih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IHZvaWQge1xuICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXG4gIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwdWxsUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZSA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICBhc3NlcnQoZGVzaXJlZFNpemUgIT09IG51bGwpO1xuICBpZiAoZGVzaXJlZFNpemUhID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcblxuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlPFI+KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICBjaHVuazogUlxuKTogdm9pZCB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNodW5rU2l6ZTtcbiAgICB0cnkge1xuICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICB9IGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgICB0aHJvdyBjaHVua1NpemVFO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgIHRocm93IGVucXVldWVFO1xuICAgIH1cbiAgfVxuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiwgZTogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT5cbik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBUcmFuc2Zvcm1TdHJlYW0uXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBib29sZWFuIHtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT5cbik6IGJvb2xlYW4ge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPikge1xuICBhc3NlcnQoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQhO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcblxuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsaW5nKTtcbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZTxSPihcbiAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgdW5kZXJseWluZ1NvdXJjZTogVmFsaWRhdGVkVW5kZXJseWluZ1NvdXJjZTxSPixcbiAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj5cbikge1xuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIGxldCBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2UucHVsbCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NvdXJjZS5jYW5jZWwhKHJlYXNvbik7XG4gIH1cblxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtXG4gICk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cbiIsImltcG9ydCB7XG4gIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgQ3JlYXRlUmVhZGFibGVTdHJlYW0sXG4gIElzUmVhZGFibGVTdHJlYW0sXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgUmVhZGFibGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlclxufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSB9IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQsXG4gIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQsXG4gIFJlYWRJbnRvUmVxdWVzdFxufSBmcm9tICcuL2J5b2ItcmVhZGVyJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlc29sdmVkV2l0aCwgcXVldWVNaWNyb3Rhc2ssIHVwb25SZWplY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3Jcbn0gZnJvbSAnLi9kZWZhdWx0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXdcbn0gZnJvbSAnLi9ieXRlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IENyZWF0ZUFycmF5RnJvbUxpc3QgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5pbXBvcnQgeyBDbG9uZUFzVWludDhBcnJheSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVGVlPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVGb3JCcmFuY2gyOiBib29sZWFuKTogW1JlYWRhYmxlU3RyZWFtPFI+LCBSZWFkYWJsZVN0cmVhbTxSPl0ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHR5cGVvZiBjbG9uZUZvckJyYW5jaDIgPT09ICdib29sZWFuJyk7XG4gIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbVRlZShzdHJlYW0gYXMgdW5rbm93biBhcyBSZWFkYWJsZUJ5dGVTdHJlYW0pIGFzXG4gICAgICB1bmtub3duIGFzIFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dO1xuICB9XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lRm9yQnJhbmNoMjogYm9vbGVhbik6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydCh0eXBlb2YgY2xvbmVGb3JCcmFuY2gyID09PSAnYm9vbGVhbicpO1xuXG4gIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4oc3RyZWFtKTtcblxuICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICBsZXQgcmVhZEFnYWluID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICBsZXQgcmVhc29uMTogYW55O1xuICBsZXQgcmVhc29uMjogYW55O1xuICBsZXQgYnJhbmNoMTogUmVhZGFibGVTdHJlYW08Uj47XG4gIGxldCBicmFuY2gyOiBSZWFkYWJsZVN0cmVhbTxSPjtcblxuICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U6ICh2YWx1ZTogdW5kZWZpbmVkIHwgUHJvbWlzZTx1bmRlZmluZWQ+KSA9PiB2b2lkO1xuICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAocmVhZGluZykge1xuICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuXG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgY2xvbmluZyBjb2RlIHJpZ2h0IG5vdyBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIC8vIElmIHdlIGFkZCBvbmUgdGhlbiB3ZSdsbCBuZWVkIGFuIGltcGxlbWVudGF0aW9uIGZvciBzZXJpYWxpemFibGUgb2JqZWN0cy5cbiAgICAgICAgICAvLyBpZiAoIWNhbmNlbGVkMiAmJiBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgICAvLyAgIGNodW5rMiA9IFN0cnVjdHVyZWREZXNlcmlhbGl6ZShTdHJ1Y3R1cmVkU2VyaWFsaXplKGNodW5rMikpO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShcbiAgICAgICAgICAgICAgYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gICAgICAgICAgICAgIGNodW5rMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKFxuICAgICAgICAgICAgICBicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPixcbiAgICAgICAgICAgICAgY2h1bmsyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVhZEFnYWluKSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNhbmNlbGVkMSA9IHRydWU7XG4gICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICBpZiAoY2FuY2VsZWQyKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDIgPSB0cnVlO1xuICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMSkge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuXG4gIHVwb25SZWplY3Rpb24ocmVhZGVyLl9jbG9zZWRQcm9taXNlLCAocjogYW55KSA9PiB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LCByKTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sIHIpO1xuICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogW1JlYWRhYmxlQnl0ZVN0cmVhbSwgUmVhZGFibGVCeXRlU3RyZWFtXSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSk7XG5cbiAgbGV0IHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8VWludDhBcnJheT4gPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gIGxldCByZWFkaW5nID0gZmFsc2U7XG4gIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICBsZXQgcmVhc29uMTogYW55O1xuICBsZXQgcmVhc29uMjogYW55O1xuICBsZXQgYnJhbmNoMTogUmVhZGFibGVCeXRlU3RyZWFtO1xuICBsZXQgYnJhbmNoMjogUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTogKHZhbHVlOiB1bmRlZmluZWQgfCBQcm9taXNlPHVuZGVmaW5lZD4pID0+IHZvaWQ7XG4gIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZFJlYWRlckVycm9yKHRoaXNSZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFVpbnQ4QXJyYXk+KSB7XG4gICAgdXBvblJlamVjdGlvbih0aGlzUmVhZGVyLl9jbG9zZWRQcm9taXNlLCByID0+IHtcbiAgICAgIGlmICh0aGlzUmVhZGVyICE9PSByZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpIHtcbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgYXNzZXJ0KHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPT09IDApO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXG4gICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8VWludDhBcnJheT4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICBsZXQgY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDEgJiYgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2h1bmsyID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgICAgfSBjYXRjaCAoY2xvbmVFKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbFdpdGhCWU9CUmVhZGVyKHZpZXc6IEFycmF5QnVmZmVyVmlldywgZm9yQnJhbmNoMjogYm9vbGVhbikge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PihyZWFkZXIpKSB7XG4gICAgICBhc3NlcnQocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID09PSAwKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblxuICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgYnlvYkJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gyIDogYnJhbmNoMTtcbiAgICBjb25zdCBvdGhlckJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gxIDogYnJhbmNoMjtcblxuICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PEFycmF5QnVmZmVyVmlldz4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuICAgICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xuXG4gICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICBsZXQgY2xvbmVkQ2h1bms7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjbG9uZWRDaHVuayA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lZENodW5rKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblxuICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0KGNodW5rLmJ5dGVMZW5ndGggPT09IDApO1xuXG4gICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCAmJiBvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbDFBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3ISwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsMkFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAocmVhZGluZykge1xuICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlYWRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXchLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNhbmNlbGVkMSA9IHRydWU7XG4gICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICBpZiAoY2FuY2VsZWQyKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDIgPSB0cnVlO1xuICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMSkge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpOiB2b2lkIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMUFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGwyQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblxuICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcblxuICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24sIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1Db250cm9sbGVyLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVmFsaWRhdGVkVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Vcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IHByb21pc2VDYWxsLCByZWZsZWN0Q2FsbCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPihcbiAgc291cmNlOiBVbmRlcmx5aW5nU291cmNlPFI+IHwgVW5kZXJseWluZ0J5dGVTb3VyY2UgfCBudWxsLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFZhbGlkYXRlZFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZSBhcyAoVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4gfCBudWxsKTtcbiAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWw/LmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWw/LmNhbmNlbDtcbiAgY29uc3QgcHVsbCA9IG9yaWdpbmFsPy5wdWxsO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHlwZSA9IG9yaWdpbmFsPy50eXBlO1xuICByZXR1cm4ge1xuICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShcbiAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgXG4gICAgICApLFxuICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLFxuICAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdwdWxsJyB0aGF0YCksXG4gICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgIHR5cGU6IHR5cGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHlwZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAocmVhc29uOiBhbnkpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjazxSPihcbiAgZm46IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlUHVsbENhbGxiYWNrPFI+LFxuICBvcmlnaW5hbDogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8Uj4pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrPFI+KFxuICBmbjogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VTdGFydENhbGxiYWNrPFI+LFxuICBvcmlnaW5hbDogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VTdGFydENhbGxiYWNrPFI+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGU6IHN0cmluZywgY29udGV4dDogc3RyaW5nKTogJ2J5dGVzJyB7XG4gIHR5cGUgPSBgJHt0eXBlfWA7XG4gIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHt0eXBlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZWApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL3JlYWRlci1vcHRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWFkZXJPcHRpb25zKG9wdGlvbnM6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgbW9kZSA9IG9wdGlvbnM/Lm1vZGU7XG4gIHJldHVybiB7XG4gICAgbW9kZTogbW9kZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlOiBzdHJpbmcsIGNvbnRleHQ6IHN0cmluZyk6ICdieW9iJyB7XG4gIG1vZGUgPSBgJHttb2RlfWA7XG4gIGlmIChtb2RlICE9PSAnYnlvYicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG4gIH1cbiAgcmV0dXJuIG1vZGU7XG59XG4iLCJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5IH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyxcbiAgVmFsaWRhdGVkUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnNcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL2l0ZXJhdG9yLW9wdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zOiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBWYWxpZGF0ZWRSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zPy5wcmV2ZW50Q2FuY2VsO1xuICByZXR1cm4geyBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpIH07XG59XG4iLCJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5IH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBTdHJlYW1QaXBlT3B0aW9ucywgVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vcGlwZS1vcHRpb25zJztcbmltcG9ydCB7IEFib3J0U2lnbmFsLCBpc0Fib3J0U2lnbmFsIH0gZnJvbSAnLi4vYWJvcnQtc2lnbmFsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgcHJldmVudEFib3J0ID0gb3B0aW9ucz8ucHJldmVudEFib3J0O1xuICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucz8ucHJldmVudENhbmNlbDtcbiAgY29uc3QgcHJldmVudENsb3NlID0gb3B0aW9ucz8ucHJldmVudENsb3NlO1xuICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcmV2ZW50QWJvcnQ6IEJvb2xlYW4ocHJldmVudEFib3J0KSxcbiAgICBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpLFxuICAgIHByZXZlbnRDbG9zZTogQm9vbGVhbihwcmV2ZW50Q2xvc2UpLFxuICAgIHNpZ25hbFxuICB9O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWw6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgc2lnbmFsIGlzIEFib3J0U2lnbmFsIHtcbiAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBBYm9ydFNpZ25hbC5gKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0UmVxdWlyZWRGaWVsZCB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgV3JpdGFibGVTdHJlYW0gfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBhc3NlcnRXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcjxSUyBleHRlbmRzIFJlYWRhYmxlU3RyZWFtLCBXUyBleHRlbmRzIFdyaXRhYmxlU3RyZWFtPihcbiAgcGFpcjogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXUyB9IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgY29udGV4dDogc3RyaW5nXG4pOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdTIH0ge1xuICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuXG4gIGNvbnN0IHJlYWRhYmxlID0gcGFpcj8ucmVhZGFibGU7XG4gIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICBhc3NlcnRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtcblxuICBjb25zdCB3cml0YWJsZSA9IHBhaXI/LndyaXRhYmxlO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XG5cbiAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7XG4gIHByb21pc2VSZWplY3RlZFdpdGgsXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUsXG4gIHRyYW5zZm9ybVByb21pc2VXaXRoXG59IGZyb20gJy4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciwgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vYXN5bmMtaXRlcmF0b3InO1xuaW1wb3J0IHsgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QsIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHRcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdFxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9ieW9iLXJlYWRlcic7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVBpcGVUbyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3BpcGUnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1UZWUgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS90ZWUnO1xuaW1wb3J0IHsgSXNXcml0YWJsZVN0cmVhbSwgSXNXcml0YWJsZVN0cmVhbUxvY2tlZCwgV3JpdGFibGVTdHJlYW0gfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsXG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Vcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vYnl0ZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdCeXRlU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFja1xufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgQ3JlYXRlQXJyYXlGcm9tTGlzdCB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGFzc2VydE9iamVjdCwgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRXh0cmFjdEhpZ2hXYXRlck1hcmssIEV4dHJhY3RTaXplQWxnb3JpdGhtIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UgfSBmcm9tICcuL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcmVhZGVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgY29udmVydFJlYWRlck9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcmVhZGVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgU3RyZWFtUGlwZU9wdGlvbnMsIFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcGlwZS1vcHRpb25zJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vaXRlcmF0b3Itb3B0aW9ucyc7XG5pbXBvcnQgeyBjb252ZXJ0SXRlcmF0b3JPcHRpb25zIH0gZnJvbSAnLi92YWxpZGF0b3JzL2l0ZXJhdG9yLW9wdGlvbnMnO1xuaW1wb3J0IHsgY29udmVydFBpcGVPcHRpb25zIH0gZnJvbSAnLi92YWxpZGF0b3JzL3BpcGUtb3B0aW9ucyc7XG5pbXBvcnQgeyBSZWFkYWJsZVdyaXRhYmxlUGFpciB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLXdyaXRhYmxlLXBhaXInO1xuaW1wb3J0IHsgY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyIH0gZnJvbSAnLi92YWxpZGF0b3JzL3JlYWRhYmxlLXdyaXRhYmxlLXBhaXInO1xuXG5leHBvcnQgdHlwZSBSZWFkYWJsZUJ5dGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiAmIHtcbiAgX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxufTtcblxudHlwZSBSZWFkYWJsZVN0cmVhbVN0YXRlID0gJ3JlYWRhYmxlJyB8ICdjbG9zZWQnIHwgJ2Vycm9yZWQnO1xuXG4vKipcbiAqIEEgcmVhZGFibGUgc3RyZWFtIHJlcHJlc2VudHMgYSBzb3VyY2Ugb2YgZGF0YSwgZnJvbSB3aGljaCB5b3UgY2FuIHJlYWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW08UiA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGF0ZSE6IFJlYWRhYmxlU3RyZWFtU3RhdGU7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8Uj4gfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0b3JlZEVycm9yOiBhbnk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Rpc3R1cmJlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciE6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4gfCBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuXG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTb3VyY2U6IFVuZGVybHlpbmdCeXRlU291cmNlLCBzdHJhdGVneT86IHsgaGlnaFdhdGVyTWFyaz86IG51bWJlcjsgc2l6ZT86IHVuZGVmaW5lZCB9KTtcbiAgY29uc3RydWN0b3IodW5kZXJseWluZ1NvdXJjZT86IFVuZGVybHlpbmdTb3VyY2U8Uj4sIHN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PFI+KTtcbiAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NvdXJjZTogVW5kZXJseWluZ1NvdXJjZTxSPiB8IFVuZGVybHlpbmdCeXRlU291cmNlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFI+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmF3VW5kZXJseWluZ1NvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHVuZGVybHlpbmdTb3VyY2UgPSBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHRoaXMpO1xuXG4gICAgaWYgKHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgaWYgKHN0cmF0ZWd5LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAwKTtcbiAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKFxuICAgICAgICB0aGlzIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICB1bmRlcmx5aW5nU291cmNlLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSB1bmRlZmluZWQpO1xuICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcbiAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG4gICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdW5kZXJseWluZ1NvdXJjZSxcbiAgICAgICAgaGlnaFdhdGVyTWFyayxcbiAgICAgICAgc2l6ZUFsZ29yaXRobVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHwgcmVhZGVyfS5cbiAgICovXG4gIGdldCBsb2NrZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdsb2NrZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBzdHJlYW0sIHNpZ25hbGluZyBhIGxvc3Mgb2YgaW50ZXJlc3QgaW4gdGhlIHN0cmVhbSBieSBhIGNvbnN1bWVyLlxuICAgKlxuICAgKiBUaGUgc3VwcGxpZWQgYHJlYXNvbmAgYXJndW1lbnQgd2lsbCBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UncyB7QGxpbmsgVW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgfCBjYW5jZWwoKX1cbiAgICogbWV0aG9kLCB3aGljaCBtaWdodCBvciBtaWdodCBub3QgdXNlIGl0LlxuICAgKi9cbiAgY2FuY2VsKHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYW5jZWwgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHJlYWRlcicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyByZWFkZXIuXG4gICAqXG4gICAqIFRoaXMgY2FsbCBiZWhhdmVzIHRoZSBzYW1lIHdheSBhcyB0aGUgbm8tYXJndW1lbnQgdmFyaWFudCwgZXhjZXB0IHRoYXQgaXQgb25seSB3b3JrcyBvbiByZWFkYWJsZSBieXRlIHN0cmVhbXMsXG4gICAqIGkuZS4gc3RyZWFtcyB3aGljaCB3ZXJlIGNvbnN0cnVjdGVkIHNwZWNpZmljYWxseSB3aXRoIHRoZSBhYmlsaXR5IHRvIGhhbmRsZSBcImJyaW5nIHlvdXIgb3duIGJ1ZmZlclwiIHJlYWRpbmcuXG4gICAqIFRoZSByZXR1cm5lZCBCWU9CIHJlYWRlciBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byBkaXJlY3RseSByZWFkIGluZGl2aWR1YWwgY2h1bmtzIGZyb20gdGhlIHN0cmVhbSB2aWEgaXRzXG4gICAqIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kLCBpbnRvIGRldmVsb3Blci1zdXBwbGllZCBidWZmZXJzLCBhbGxvd2luZyBtb3JlIHByZWNpc2VcbiAgICogY29udHJvbCBvdmVyIGFsbG9jYXRpb24uXG4gICAqL1xuICBnZXRSZWFkZXIoeyBtb2RlIH06IHsgbW9kZTogJ2J5b2InIH0pOiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyByZWFkZXIuXG4gICAqIFdoaWxlIHRoZSBzdHJlYW0gaXMgbG9ja2VkLCBubyBvdGhlciByZWFkZXIgY2FuIGJlIGFjcXVpcmVkIHVudGlsIHRoaXMgb25lIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byBjb25zdW1lIGEgc3RyZWFtXG4gICAqIGluIGl0cyBlbnRpcmV0eS4gQnkgZ2V0dGluZyBhIHJlYWRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIGludGVybGVhdmUgcmVhZHMgd2l0aCB5b3Vyc1xuICAgKiBvciBjYW5jZWwgdGhlIHN0cmVhbSwgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggeW91ciBhYnN0cmFjdGlvbi5cbiAgICovXG4gIGdldFJlYWRlcigpOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj47XG4gIGdldFJlYWRlcihcbiAgICByYXdPcHRpb25zOiBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICk6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiB8IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRSZWFkZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKTtcbiAgICB9XG5cbiAgICBhc3NlcnQob3B0aW9ucy5tb2RlID09PSAnYnlvYicpO1xuICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMgYXMgdW5rbm93biBhcyBSZWFkYWJsZUJ5dGVTdHJlYW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgY29udmVuaWVudCwgY2hhaW5hYmxlIHdheSBvZiBwaXBpbmcgdGhpcyByZWFkYWJsZSBzdHJlYW0gdGhyb3VnaCBhIHRyYW5zZm9ybSBzdHJlYW1cbiAgICogKG9yIGFueSBvdGhlciBgeyB3cml0YWJsZSwgcmVhZGFibGUgfWAgcGFpcikuIEl0IHNpbXBseSB7QGxpbmsgUmVhZGFibGVTdHJlYW0ucGlwZVRvIHwgcGlwZXN9IHRoZSBzdHJlYW1cbiAgICogaW50byB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgc3VwcGxpZWQgcGFpciwgYW5kIHJldHVybnMgdGhlIHJlYWRhYmxlIHNpZGUgZm9yIGZ1cnRoZXIgdXNlLlxuICAgKlxuICAgKiBQaXBpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBpcGUsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKi9cbiAgcGlwZVRocm91Z2g8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbT4oXG4gICAgdHJhbnNmb3JtOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFI+IH0sXG4gICAgb3B0aW9ucz86IFN0cmVhbVBpcGVPcHRpb25zXG4gICk6IFJTO1xuICBwaXBlVGhyb3VnaDxSUyBleHRlbmRzIFJlYWRhYmxlU3RyZWFtPihcbiAgICByYXdUcmFuc2Zvcm06IHsgcmVhZGFibGU6IFJTOyB3cml0YWJsZTogV3JpdGFibGVTdHJlYW08Uj4gfSB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgcmF3T3B0aW9uczogU3RyZWFtUGlwZU9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0ge31cbiAgKTogUlMge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncGlwZVRocm91Z2gnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsICdwaXBlVGhyb3VnaCcpO1xuXG4gICAgY29uc3QgdHJhbnNmb3JtID0gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHJhd1RyYW5zZm9ybSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcbiAgICB9XG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodHJhbnNmb3JtLndyaXRhYmxlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbWlzZSA9IFJlYWRhYmxlU3RyZWFtUGlwZVRvKFxuICAgICAgdGhpcywgdHJhbnNmb3JtLndyaXRhYmxlLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWxcbiAgICApO1xuXG4gICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm0ucmVhZGFibGU7XG4gIH1cblxuICAvKipcbiAgICogUGlwZXMgdGhpcyByZWFkYWJsZSBzdHJlYW0gdG8gYSBnaXZlbiB3cml0YWJsZSBzdHJlYW0uIFRoZSB3YXkgaW4gd2hpY2ggdGhlIHBpcGluZyBwcm9jZXNzIGJlaGF2ZXMgdW5kZXJcbiAgICogdmFyaW91cyBlcnJvciBjb25kaXRpb25zIGNhbiBiZSBjdXN0b21pemVkIHdpdGggYSBudW1iZXIgb2YgcGFzc2VkIG9wdGlvbnMuIEl0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHNcbiAgICogd2hlbiB0aGUgcGlwaW5nIHByb2Nlc3MgY29tcGxldGVzIHN1Y2Nlc3NmdWxseSwgb3IgcmVqZWN0cyBpZiBhbnkgZXJyb3JzIHdlcmUgZW5jb3VudGVyZWQuXG4gICAqXG4gICAqIFBpcGluZyBhIHN0cmVhbSB3aWxsIGxvY2sgaXQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGlwZSwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqL1xuICBwaXBlVG8oZGVzdGluYXRpb246IFdyaXRhYmxlU3RyZWFtPFI+LCBvcHRpb25zPzogU3RyZWFtUGlwZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBwaXBlVG8oZGVzdGluYXRpb246IFdyaXRhYmxlU3RyZWFtPFI+IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgIHJhd09wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdwaXBlVG8nKSk7XG4gICAgfVxuXG4gICAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGBQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5gKTtcbiAgICB9XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKGRlc3RpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1gKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9uczogVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICB9XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoZGVzdGluYXRpb24pKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChcbiAgICAgICAgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVBpcGVUbzxSPihcbiAgICAgIHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlZXMgdGhpcyByZWFkYWJsZSBzdHJlYW0sIHJldHVybmluZyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHR3byByZXN1bHRpbmcgYnJhbmNoZXMgYXNcbiAgICogbmV3IHtAbGluayBSZWFkYWJsZVN0cmVhbX0gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBUZWVpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0LCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICogVG8gY2FuY2VsIHRoZSBzdHJlYW0sIGNhbmNlbCBib3RoIG9mIHRoZSByZXN1bHRpbmcgYnJhbmNoZXM7IGEgY29tcG9zaXRlIGNhbmNlbGxhdGlvbiByZWFzb24gd2lsbCB0aGVuIGJlXG4gICAqIHByb3BhZ2F0ZWQgdG8gdGhlIHN0cmVhbSdzIHVuZGVybHlpbmcgc291cmNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNodW5rcyBzZWVuIGluIGVhY2ggYnJhbmNoIHdpbGwgYmUgdGhlIHNhbWUgb2JqZWN0LiBJZiB0aGUgY2h1bmtzIGFyZSBub3QgaW1tdXRhYmxlLFxuICAgKiB0aGlzIGNvdWxkIGFsbG93IGludGVyZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gYnJhbmNoZXMuXG4gICAqL1xuICB0ZWUoKTogW1JlYWRhYmxlU3RyZWFtPFI+LCBSZWFkYWJsZVN0cmVhbTxSPl0ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigndGVlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYnJhbmNoZXMgPSBSZWFkYWJsZVN0cmVhbVRlZSh0aGlzLCBmYWxzZSk7XG4gICAgcmV0dXJuIENyZWF0ZUFycmF5RnJvbUxpc3QoYnJhbmNoZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGl0ZXJhdGVzIG92ZXIgdGhlIGNodW5rcyBpbiB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEFzeW5jaHJvbm91c2x5IGl0ZXJhdGluZyBvdmVyIHRoZSBzdHJlYW0gd2lsbCBsb2NrIGl0LCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICogVGhlIGxvY2sgd2lsbCBiZSByZWxlYXNlZCBpZiB0aGUgYXN5bmMgaXRlcmF0b3IncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLnJldHVybiB8IHJldHVybigpfSBtZXRob2RcbiAgICogaXMgY2FsbGVkLCBlLmcuIGJ5IGJyZWFraW5nIG91dCBvZiB0aGUgbG9vcC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgY2FsbGluZyB0aGUgYXN5bmMgaXRlcmF0b3IncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLnJldHVybiB8IHJldHVybigpfSBtZXRob2Qgd2lsbCBhbHNvXG4gICAqIGNhbmNlbCB0aGUgc3RyZWFtLiBUbyBwcmV2ZW50IHRoaXMsIHVzZSB0aGUgc3RyZWFtJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtLnZhbHVlcyB8IHZhbHVlcygpfSBtZXRob2QsIHBhc3NpbmdcbiAgICogYHRydWVgIGZvciB0aGUgYHByZXZlbnRDYW5jZWxgIG9wdGlvbi5cbiAgICovXG4gIHZhbHVlcyhvcHRpb25zPzogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMpOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj47XG4gIHZhbHVlcyhyYXdPcHRpb25zOiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigndmFsdWVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRJdGVyYXRvck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+KHRoaXMsIG9wdGlvbnMucHJldmVudENhbmNlbCk7XG4gIH1cblxuICAvKipcbiAgICoge0Bpbmhlcml0RG9jIFJlYWRhYmxlU3RyZWFtLnZhbHVlc31cbiAgICovXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06IChvcHRpb25zPzogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMpID0+IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPjtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGdldFJlYWRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHBpcGVUaHJvdWdoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcGlwZVRvOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdGVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuaWYgKHR5cGVvZiBTeW1ib2wuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIHtcbiAgICB2YWx1ZTogUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnZhbHVlcyxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdCxcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdCxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdCeXRlU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFN0cmVhbVBpcGVPcHRpb25zLFxuICBSZWFkYWJsZVdyaXRhYmxlUGFpcixcbiAgUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnNcbn07XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZVN0cmVhbTxSPihzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyayA9IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+ID0gKCkgPT4gMSk6IFJlYWRhYmxlU3RyZWFtPFI+IHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIoaGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKFxuICAgIHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKFxuICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPlxuKTogUmVhZGFibGVCeXRlU3RyZWFtIHtcbiAgY29uc3Qgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCwgdW5kZWZpbmVkKTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcbiAgc3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFJlYWRhYmxlU3RyZWFtIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EaXN0dXJiZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcblxuICByZXR1cm4gc3RyZWFtLl9kaXN0dXJiZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG5cbiAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWw8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPiwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cblxuICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIGlmIChyZWFkZXIgIT09IHVuZGVmaW5lZCAmJiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyh1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG5cbiAgY29uc3Qgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNsb3NlPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4pOiB2b2lkIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuXG4gIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ocmVhZGVyKSkge1xuICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICB9KTtcbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUVycm9yPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIGU6IGFueSk6IHZvaWQge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuXG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSBlO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHJlYWRlcikpIHtcbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgIH0pO1xuXG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSk7XG5cbiAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaChyZWFkSW50b1JlcXVlc3QgPT4ge1xuICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgIH0pO1xuXG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cbn1cblxuLy8gUmVhZGVyc1xuXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbVJlYWRlcjxSPiA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiB8IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblxuZXhwb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJcbn07XG5cbi8vIENvbnRyb2xsZXJzXG5cbmV4cG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtYCk7XG59XG4iLCJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRSZXF1aXJlZEZpZWxkLCBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIH0gZnJvbSAnLi9iYXNpYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChpbml0OiBRdWV1aW5nU3RyYXRlZ3lJbml0IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3lJbml0IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQ/LmhpZ2hXYXRlck1hcms7XG4gIGFzc2VydFJlcXVpcmVkRmllbGQoaGlnaFdhdGVyTWFyaywgJ2hpZ2hXYXRlck1hcmsnLCAnUXVldWluZ1N0cmF0ZWd5SW5pdCcpO1xuICByZXR1cm4ge1xuICAgIGhpZ2hXYXRlck1hcms6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyaylcbiAgfTtcbn1cbiIsImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24gPSAoY2h1bms6IEFycmF5QnVmZmVyVmlldyk6IG51bWJlciA9PiB7XG4gIHJldHVybiBjaHVuay5ieXRlTGVuZ3RoO1xufTtcbnRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogJ3NpemUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn0gY2F0Y2gge1xuICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbn1cblxuLyoqXG4gKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIGNodW5rLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSBpbXBsZW1lbnRzIFF1ZXVpbmdTdHJhdGVneTxBcnJheUJ1ZmZlclZpZXc+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBRdWV1aW5nU3RyYXRlZ3lJbml0KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScpO1xuICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdldCBoaWdoV2F0ZXJNYXJrKCk6IG51bWJlciB7XG4gICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICovXG4gIGdldCBzaXplKCk6IChjaHVuazogQXJyYXlCdWZmZXJWaWV3KSA9PiBudW1iZXIge1xuICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZUxlbmd0aFNpemVGdW5jdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LlxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHg6IGFueSk6IHggaXMgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xufVxuIiwiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneS1pbml0JztcblxuLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuY29uc3QgY291bnRTaXplRnVuY3Rpb24gPSAoKTogMSA9PiB7XG4gIHJldHVybiAxO1xufTtcbnRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3VudFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdzaXplJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59IGNhdGNoIHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG59XG5cbi8qKlxuICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgY2h1bmtzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ291bnRRdWV1aW5nU3RyYXRlZ3kgaW1wbGVtZW50cyBRdWV1aW5nU3RyYXRlZ3k8YW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVhZG9ubHkgX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayE6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBRdWV1aW5nU3RyYXRlZ3lJbml0KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQ291bnRRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ2V0IGhpZ2hXYXRlck1hcmsoKTogbnVtYmVyIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgYWx3YXlzIHJldHVybmluZyAxLlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdG90YWwgcXVldWUgc2l6ZSBpcyBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzIGluIHRoZSBxdWV1ZS5cbiAgICovXG4gIGdldCBzaXplKCk6IChjaHVuazogYW55KSA9PiAxIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQ291bnRRdWV1aW5nU3RyYXRlZ3kuXG5cbmZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHg6IGFueSk6IHggaXMgQ291bnRRdWV1aW5nU3RyYXRlZ3kge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24gfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IHByb21pc2VDYWxsLCByZWZsZWN0Q2FsbCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayxcbiAgVmFsaWRhdGVkVHJhbnNmb3JtZXJcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLXN0cmVhbS90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4uL3RyYW5zZm9ybS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyPEksIE8+KG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFRyYW5zZm9ybWVyPEksIE8+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGZsdXNoID0gb3JpZ2luYWw/LmZsdXNoO1xuICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbD8ucmVhZGFibGVUeXBlO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWw/LnRyYW5zZm9ybTtcbiAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWw/LndyaXRhYmxlVHlwZTtcbiAgcmV0dXJuIHtcbiAgICBmbHVzaDogZmx1c2ggPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLFxuICAgIHJlYWRhYmxlVHlwZSxcbiAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0cmFuc2Zvcm0nIHRoYXRgKSxcbiAgICB3cml0YWJsZVR5cGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjazxPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPEksIE8+KFxuICBmbjogVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPE8+LFxuICBvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPE8+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrPEksIE8+KFxuICBmbjogVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjazxJLCBPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjaHVuazogSSwgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY2h1bms6IEksIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xufVxuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVqZWN0ZWRXaXRoLCBwcm9taXNlUmVzb2x2ZWRXaXRoLCB0cmFuc2Zvcm1Qcm9taXNlV2l0aCB9IGZyb20gJy4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgQ3JlYXRlUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgQ3JlYXRlV3JpdGFibGVTdHJlYW0sIFdyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayxcbiAgVmFsaWRhdGVkVHJhbnNmb3JtZXJcbn0gZnJvbSAnLi90cmFuc2Zvcm0tc3RyZWFtL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IGNvbnZlcnRUcmFuc2Zvcm1lciB9IGZyb20gJy4vdmFsaWRhdG9ycy90cmFuc2Zvcm1lcic7XG5cbi8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbVxuXG4vKipcbiAqIEEgdHJhbnNmb3JtIHN0cmVhbSBjb25zaXN0cyBvZiBhIHBhaXIgb2Ygc3RyZWFtczogYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19LFxuICoga25vd24gYXMgaXRzIHdyaXRhYmxlIHNpZGUsIGFuZCBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0sIGtub3duIGFzIGl0cyByZWFkYWJsZSBzaWRlLlxuICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcbiAqIG1hZGUgYXZhaWxhYmxlIGZvciByZWFkaW5nIGZyb20gdGhlIHJlYWRhYmxlIHNpZGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtU3RyZWFtPEkgPSBhbnksIE8gPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGFibGUhOiBXcml0YWJsZVN0cmVhbTxJPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZGFibGUhOiBSZWFkYWJsZVN0cmVhbTxPPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSE6IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSE6ICgpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIhOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0cmFuc2Zvcm1lcj86IFRyYW5zZm9ybWVyPEksIE8+LFxuICAgIHdyaXRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8ST4sXG4gICAgcmVhZGFibGVTdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxPPlxuICApO1xuICBjb25zdHJ1Y3RvcihyYXdUcmFuc2Zvcm1lcjogVHJhbnNmb3JtZXI8SSwgTz4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1dyaXRhYmxlU3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxJPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3UmVhZGFibGVTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PE8+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuXG4gICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlITogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ7XG4gICAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICB0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobVxuICAgICk7XG4gICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG5cbiAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cbiAgICovXG4gIGdldCByZWFkYWJsZSgpOiBSZWFkYWJsZVN0cmVhbTxPPiB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBnZXQgd3JpdGFibGUoKTogV3JpdGFibGVTdHJlYW08ST4ge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBUcmFuc2Zvcm1lcixcbiAgVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2tcbn07XG5cbi8vIFRyYW5zZm9ybSBTdHJlYW0gQWJzdHJhY3QgT3BlcmF0aW9uc1xuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlVHJhbnNmb3JtU3RyZWFtPEksIE8+KHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobTogKGNodW5rOiBJKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8ST4gPSAoKSA9PiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxPPiA9ICgpID0+IDEpIHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIod3JpdGFibGVIaWdoV2F0ZXJNYXJrKSk7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKHJlYWRhYmxlSGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+ID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmUhOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZDtcbiAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICBzdGFydFByb21pc2VfcmVzb2x2ZShzdGFydFJlc3VsdCk7XG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZTogUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPEk+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Tz4pIHtcbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHN0YXJ0UHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlQWxnb3JpdGhtKGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuayk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydEFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCByZWFzb24pO1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBzdHJlYW0uX3JlYWRhYmxlID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblxuICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IHVuZGVmaW5lZCE7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZCE7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkITtcbiAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG5cbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeDogdW5rbm93bik6IHggaXMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtO1xufVxuXG4vLyBUaGlzIGlzIGEgbm8tb3AgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBlcnJvcmVkLlxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGU6IGFueSkge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoXG4gICAgc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PixcbiAgICBlXG4gICk7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgZTogYW55KSB7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgIC8vIFByZXRlbmQgdGhhdCBwdWxsKCkgd2FzIGNhbGxlZCB0byBwZXJtaXQgYW55IHBlbmRpbmcgd3JpdGUoKSBjYWxscyB0byBjb21wbGV0ZS4gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKClcbiAgICAvLyBjYW5ub3QgYmUgY2FsbGVkIGZyb20gZW5xdWV1ZSgpIG9yIHB1bGwoKSBvbmNlIHRoZSBSZWFkYWJsZVN0cmVhbSBpcyBlcnJvcmVkLCBzbyB0aGlzIHdpbGwgd2lsbCBiZSB0aGUgZmluYWwgdGltZVxuICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGJhY2twcmVzc3VyZTogYm9vbGVhbikge1xuICAvLyBQYXNzZXMgYWxzbyB3aGVuIGNhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICBhc3NlcnQoc3RyZWFtLl9iYWNrcHJlc3N1cmUgIT09IGJhY2twcmVzc3VyZSk7XG5cbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcbiAgfVxuXG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbn1cblxuLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiB0aGUge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBhbmQge0BsaW5rIFdyaXRhYmxlU3RyZWFtfSBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgVHJhbnNmb3JtU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxhbnksIE8+O1xuICAvKiogQGludGVybmFsICovXG4gIF90cmFuc2Zvcm1BbGdvcml0aG06IChjaHVuazogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9mbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgcmVhZGFibGUgc2lkZeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUocmVhZGFibGVDb250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBgY2h1bmtgIGluIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBPKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogTyA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG4gICAqIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLiBBbnkgY2h1bmtzIHF1ZXVlZCBmb3IgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAqL1xuICBlcnJvcihyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHJlYWRhYmxlIHNpZGUgYW5kIGVycm9ycyB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICovXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XG4gICAgfVxuXG4gICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8TyA9IGFueT4oeDogYW55KTogeCBpcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IEkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gIGFzc2VydChJc1RyYW5zZm9ybVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHRyYW5zZm9ybUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcbn1cblxuZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcjxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZXI6IFZhbGlkYXRlZFRyYW5zZm9ybWVyPEksIE8+KSB7XG4gIGNvbnN0IGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+ID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bms6IEkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rIGFzIHVua25vd24gYXMgTyk7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH0gY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHRyYW5zZm9ybVJlc3VsdEUpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHRyYW5zZm9ybWVyLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4gdHJhbnNmb3JtZXIudHJhbnNmb3JtIShjaHVuaywgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVyLmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoIShjb250cm9sbGVyKTtcbiAgfVxuXG4gIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZTxPPihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiwgY2h1bms6IE8pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gIH1cblxuICAvLyBXZSB0aHJvdHRsZSB0cmFuc2Zvcm0gaW52b2NhdGlvbnMgYmFzZWQgb24gdGhlIGJhY2twcmVzc3VyZSBvZiB0aGUgUmVhZGFibGVTdHJlYW0sIGJ1dCB3ZSBzdGlsbFxuICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG5cbiAgdHJ5IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG5cbiAgICB0aHJvdyBzdHJlYW0uX3JlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IGJhY2twcmVzc3VyZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlKTtcbiAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGU6IGFueSkge1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtPEksIE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBJKSB7XG4gIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcbiAgICB0aHJvdyByO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGU8Tz4oY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG5cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHJlYWRhYmxlQ29udHJvbGxlcik7XG5cbiAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xufVxuXG4vLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sIGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRhYmxlLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblxuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBjb25zdCBiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuICAgIGFzc2VydChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICBjb25zdCBzdGF0ZSA9IHdyaXRhYmxlLl9zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICB9XG4gICAgICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScpO1xuICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyLCBjaHVuayk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtPEksIE8+KGNvbnRyb2xsZXIsIGNodW5rKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gYWJvcnQoKSBpcyBub3QgY2FsbGVkIHN5bmNocm9ub3VzbHksIHNvIGl0IGlzIHBvc3NpYmxlIGZvciBhYm9ydCgpIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gaXMgYWxyZWFkeVxuICAvLyBlcnJvcmVkLlxuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgY29uc3QgZmx1c2hQcm9taXNlID0gY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0oKTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cbiAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZCBvbiBzdWNjZXNzLlxuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoZmx1c2hQcm9taXNlLCAoKSA9PiB7XG4gICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pO1xuICB9LCByID0+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHIpO1xuICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfSk7XG59XG5cbi8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBJbnZhcmlhbnQuIEVuZm9yY2VkIGJ5IHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBzdGFydCgpIGFuZCBwdWxsKCkuXG4gIGFzc2VydChzdHJlYW0uX2JhY2twcmVzc3VyZSk7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcblxuICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG5cbiAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXG4gIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcbn1cbiIsIi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzZcblxuaWYgKCFnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSB7XG4gIC8vIGBub2RlOnN0cmVhbS93ZWJgIGdvdCBpbnRyb2R1Y2VkIGluIHYxNi41LjAgYXMgZXhwZXJpbWVudGFsXG4gIC8vIGFuZCBpdCdzIHByZWZlcnJlZCBvdmVyIHRoZSBwb2x5ZmlsbGVkIHZlcnNpb24uIFNvIHdlIGFsc29cbiAgLy8gc3VwcHJlc3MgdGhlIHdhcm5pbmcgdGhhdCBnZXRzIGVtaXR0ZWQgYnkgTm9kZUpTIGZvciB1c2luZyBpdC5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9jZXNzID0gcmVxdWlyZSgnbm9kZTpwcm9jZXNzJylcbiAgICBjb25zdCB7IGVtaXRXYXJuaW5nIH0gPSBwcm9jZXNzXG4gICAgdHJ5IHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSAoKSA9PiB7fVxuICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCByZXF1aXJlKCdub2RlOnN0cmVhbS93ZWInKSlcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZ1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmdcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIGZhbGxiYWNrIHRvIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uXG4gICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCByZXF1aXJlKCd3ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLmVzMjAxOC5qcycpKVxuICB9XG59XG5cbnRyeSB7XG4gIC8vIERvbid0IHVzZSBub2RlOiBwcmVmaXggZm9yIHRoaXMsIHJlcXVpcmUrbm9kZTogaXMgbm90IHN1cHBvcnRlZCB1bnRpbCBub2RlIHYxNC4xNFxuICAvLyBPbmx5IGBpbXBvcnQoKWAgY2FuIHVzZSBwcmVmaXggaW4gMTIuMjAgYW5kIGxhdGVyXG4gIGNvbnN0IHsgQmxvYiB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbiAgaWYgKEJsb2IgJiYgIUJsb2IucHJvdG90eXBlLnN0cmVhbSkge1xuICAgIEJsb2IucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uIG5hbWUgKHBhcmFtcykge1xuICAgICAgbGV0IHBvc2l0aW9uID0gMFxuICAgICAgY29uc3QgYmxvYiA9IHRoaXNcblxuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIGFzeW5jIHB1bGwgKGN0cmwpIHtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGJsb2Iuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGJsb2Iuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUpKVxuICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKClcbiAgICAgICAgICBwb3NpdGlvbiArPSBidWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIGN0cmwuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWZmZXIpKVxuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBibG9iLnNpemUpIHtcbiAgICAgICAgICAgIGN0cmwuY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0gY2F0Y2ggKGVycm9yKSB7fVxuLyogYzggaWdub3JlIGVuZCAqL1xuIixudWxsLCJpbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xuXG5jb25zdCBfRmlsZSA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBCbG9iIHtcbiAgI2xhc3RNb2RpZmllZCA9IDBcbiAgI25hbWUgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geypbXX0gZmlsZUJpdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lXG4gICAqIEBwYXJhbSB7e2xhc3RNb2RpZmllZD86IG51bWJlciwgdHlwZT86IHN0cmluZ319IG9wdGlvbnNcbiAgICovLy8gQHRzLWlnbm9yZVxuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmApXG4gICAgfVxuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIG9wdGlvbnMgPSB7fVxuXG4gICAgLy8gU2ltdWxhdGUgV2ViSURMIHR5cGUgY2FzdGluZyBmb3IgTmFOIHZhbHVlIGluIGxhc3RNb2RpZmllZCBvcHRpb24uXG4gICAgY29uc3QgbGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgPT09IHVuZGVmaW5lZCA/IERhdGUubm93KCkgOiBOdW1iZXIob3B0aW9ucy5sYXN0TW9kaWZpZWQpXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xuICAgICAgdGhpcy4jbGFzdE1vZGlmaWVkID0gbGFzdE1vZGlmaWVkXG4gICAgfVxuXG4gICAgdGhpcy4jbmFtZSA9IFN0cmluZyhmaWxlTmFtZSlcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy4jbmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKG9iamVjdCkge1xuICAgIHJldHVybiAhIW9iamVjdCAmJiBvYmplY3QgaW5zdGFuY2VvZiBCbG9iICYmXG4gICAgICAvXihGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gIH1cbn1cblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqLy8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBGaWxlID0gX0ZpbGVcbmV4cG9ydCBkZWZhdWx0IEZpbGVcbiIsImltcG9ydCB7IHN0YXRTeW5jLCBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBiYXNlbmFtZSB9IGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCBET01FeGNlcHRpb24gZnJvbSAnbm9kZS1kb21leGNlcHRpb24nXG5cbmltcG9ydCBGaWxlIGZyb20gJy4vZmlsZS5qcydcbmltcG9ydCBCbG9iIGZyb20gJy4vaW5kZXguanMnXG5cbmNvbnN0IHsgc3RhdCB9ID0gZnNcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgYmxvYkZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21CbG9iKHN0YXRTeW5jKHBhdGgpLCBwYXRoLCB0eXBlKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICogQHJldHVybnMge1Byb21pc2U8QmxvYj59XG4gKi9cbmNvbnN0IGJsb2JGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21CbG9iKHN0YXQsIHBhdGgsIHR5cGUpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmNvbnN0IGZpbGVGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21GaWxlKHN0YXQsIHBhdGgsIHR5cGUpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICovXG5jb25zdCBmaWxlRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUZpbGUoc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21CbG9iID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IEJsb2IoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCB7IHR5cGUgfSlcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZnJvbUZpbGUgPSAoc3RhdCwgcGF0aCwgdHlwZSA9ICcnKSA9PiBuZXcgRmlsZShbbmV3IEJsb2JEYXRhSXRlbSh7XG4gIHBhdGgsXG4gIHNpemU6IHN0YXQuc2l6ZSxcbiAgbGFzdE1vZGlmaWVkOiBzdGF0Lm10aW1lTXMsXG4gIHN0YXJ0OiAwXG59KV0sIGJhc2VuYW1lKHBhdGgpLCB7IHR5cGUsIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zIH0pXG5cbi8qKlxuICogVGhpcyBpcyBhIGJsb2IgYmFja2VkIHVwIGJ5IGEgZmlsZSBvbiB0aGUgZGlza1xuICogd2l0aCBtaW5pdW0gcmVxdWlyZW1lbnQuIEl0cyB3cmFwcGVkIGFyb3VuZCBhIEJsb2IgYXMgYSBibG9iUGFydFxuICogc28geW91IGhhdmUgbm8gZGlyZWN0IGFjY2VzcyB0byB0aGlzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEJsb2JEYXRhSXRlbSB7XG4gICNwYXRoXG4gICNzdGFydFxuXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy4jcGF0aCA9IG9wdGlvbnMucGF0aFxuICAgIHRoaXMuI3N0YXJ0ID0gb3B0aW9ucy5zdGFydFxuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZVxuICAgIHRoaXMubGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljaW5nIGFyZ3VtZW50cyBpcyBmaXJzdCB2YWxpZGF0ZWQgYW5kIGZvcm1hdHRlZFxuICAgKiB0byBub3QgYmUgb3V0IG9mIHJhbmdlIGJ5IEJsb2IucHJvdG90eXBlLnNsaWNlXG4gICAqL1xuICBzbGljZSAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgQmxvYkRhdGFJdGVtKHtcbiAgICAgIHBhdGg6IHRoaXMuI3BhdGgsXG4gICAgICBsYXN0TW9kaWZpZWQ6IHRoaXMubGFzdE1vZGlmaWVkLFxuICAgICAgc2l6ZTogZW5kIC0gc3RhcnQsXG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQgKyBzdGFydFxuICAgIH0pXG4gIH1cblxuICBhc3luYyAqIHN0cmVhbSAoKSB7XG4gICAgY29uc3QgeyBtdGltZU1zIH0gPSBhd2FpdCBzdGF0KHRoaXMuI3BhdGgpXG4gICAgaWYgKG10aW1lTXMgPiB0aGlzLmxhc3RNb2RpZmllZCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIHJlcXVlc3RlZCBmaWxlIGNvdWxkIG5vdCBiZSByZWFkLCB0eXBpY2FsbHkgZHVlIHRvIHBlcm1pc3Npb24gcHJvYmxlbXMgdGhhdCBoYXZlIG9jY3VycmVkIGFmdGVyIGEgcmVmZXJlbmNlIHRvIGEgZmlsZSB3YXMgYWNxdWlyZWQuJywgJ05vdFJlYWRhYmxlRXJyb3InKVxuICAgIH1cbiAgICB5aWVsZCAqIGNyZWF0ZVJlYWRTdHJlYW0odGhpcy4jcGF0aCwge1xuICAgICAgc3RhcnQ6IHRoaXMuI3N0YXJ0LFxuICAgICAgZW5kOiB0aGlzLiNzdGFydCArIHRoaXMuc2l6ZSAtIDFcbiAgICB9KVxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0Jsb2InXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmxvYkZyb21TeW5jXG5leHBvcnQgeyBGaWxlLCBCbG9iLCBibG9iRnJvbSwgYmxvYkZyb21TeW5jLCBmaWxlRnJvbSwgZmlsZUZyb21TeW5jIH1cbiIsIi8qISBmZXRjaC1ibG9iLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG4vLyBUT0RPIChqaW1teXdhcnRpbmcpOiBpbiB0aGUgZmVhdHVyZSB1c2UgY29uZGl0aW9uYWwgbG9hZGluZyB3aXRoIHRvcCBsZXZlbCBhd2FpdCAocmVxdWlyZXMgMTQueClcbi8vIE5vZGUgaGFzIHJlY2VudGx5IGFkZGVkIHdoYXR3ZyBzdHJlYW0gaW50byBjb3JlXG5cbmltcG9ydCAnLi9zdHJlYW1zLmNqcydcblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzZcblxuLyoqIEBwYXJhbSB7KEJsb2IgfCBVaW50OEFycmF5KVtdfSBwYXJ0cyAqL1xuYXN5bmMgZnVuY3Rpb24gKiB0b0l0ZXJhdG9yIChwYXJ0cywgY2xvbmUgPSB0cnVlKSB7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmICgnc3RyZWFtJyBpbiBwYXJ0KSB7XG4gICAgICB5aWVsZCAqICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gKi8gKHBhcnQuc3RyZWFtKCkpKVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydC5ieXRlT2Zmc2V0XG4gICAgICAgIGNvbnN0IGVuZCA9IHBhcnQuYnl0ZU9mZnNldCArIHBhcnQuYnl0ZUxlbmd0aFxuICAgICAgICB3aGlsZSAocG9zaXRpb24gIT09IGVuZCkge1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihlbmQgLSBwb3NpdGlvbiwgUE9PTF9TSVpFKVxuICAgICAgICAgIGNvbnN0IGNodW5rID0gcGFydC5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSlcbiAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHBhcnRcbiAgICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmxvYnMgdGhhdCBoYXZlIGFycmF5QnVmZmVyIGJ1dCBubyBzdHJlYW0gbWV0aG9kIChub2RlcyBidWZmZXIuQmxvYilcbiAgICAgIGxldCBwb3NpdGlvbiA9IDAsIGIgPSAoLyoqIEB0eXBlIHtCbG9ifSAqLyAocGFydCkpXG4gICAgICB3aGlsZSAocG9zaXRpb24gIT09IGIuc2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGIuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGIuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUpKVxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpXG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgX0Jsb2IgPSBjbGFzcyBCbG9iIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48KEJsb2J8VWludDhBcnJheSk+fSAqL1xuICAjcGFydHMgPSBbXVxuICAjdHlwZSA9ICcnXG4gICNzaXplID0gMFxuICAjZW5kaW5ncyA9ICd0cmFuc3BhcmVudCdcblxuICAvKipcbiAgICogVGhlIEJsb2IoKSBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbmV3IEJsb2Igb2JqZWN0LiBUaGUgY29udGVudFxuICAgKiBvZiB0aGUgYmxvYiBjb25zaXN0cyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdmFsdWVzIGdpdmVuXG4gICAqIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYmxvYlBhcnRzXG4gICAqIEBwYXJhbSB7eyB0eXBlPzogc3RyaW5nLCBlbmRpbmdzPzogc3RyaW5nIH19IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGJsb2JQYXJ0cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0cyAhPT0gJ29iamVjdCcgfHwgYmxvYlBhcnRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0c1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBvYmplY3QgbXVzdCBoYXZlIGEgY2FsbGFibGUgQEBpdGVyYXRvciBwcm9wZXJ0eS4nKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS4nKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBibG9iUGFydHMpIHtcbiAgICAgIGxldCBwYXJ0XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGVsZW1lbnQpKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlci5zbGljZShlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZU9mZnNldCArIGVsZW1lbnQuYnl0ZUxlbmd0aCkpXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5zbGljZSgwKSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcGFydCA9IGVsZW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBlbmNvZGVyLmVuY29kZShgJHtlbGVtZW50fWApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3NpemUgKz0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplXG4gICAgICB0aGlzLiNwYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gXG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcob3B0aW9ucy50eXBlKVxuICAgIHRoaXMuI3R5cGUgPSAvXltcXHgyMC1cXHg3RV0qJC8udGVzdCh0eXBlKSA/IHR5cGUgOiAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcbiAgICogc2l6ZSBvZiB0aGUgQmxvYiBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIHByb3BlcnR5IG9mIGEgQmxvYiBvYmplY3QgcmV0dXJucyB0aGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLiN0eXBlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZlxuICAgKiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIHRleHQgKCkge1xuICAgIC8vIE1vcmUgb3B0aW1pemVkIHRoYW4gdXNpbmcgdGhpcy5hcnJheUJ1ZmZlcigpXG4gICAgLy8gdGhhdCByZXF1aXJlcyB0d2ljZSBhcyBtdWNoIHJhbVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIGxldCBzdHIgPSAnJ1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCBmYWxzZSkpIHtcbiAgICAgIHN0ciArPSBkZWNvZGVyLmRlY29kZShwYXJ0LCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgIH1cbiAgICAvLyBSZW1haW5pbmdcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYVxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXNcbiAgICogYmluYXJ5IGRhdGEgY29udGFpbmVkIGluIGFuIEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICAvLyBFYXNpZXIgd2F5Li4uIEp1c3QgYSB1bm5lY2Vzc2FyeSBvdmVyaGVhZFxuICAgIC8vIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIC8vIGF3YWl0IHRoaXMuc3RyZWFtKCkuZ2V0UmVhZGVyKHttb2RlOiAnYnlvYid9KS5yZWFkKHZpZXcpO1xuICAgIC8vIHJldHVybiB2aWV3LmJ1ZmZlcjtcblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpXG4gICAgbGV0IG9mZnNldCA9IDBcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5idWZmZXJcbiAgfVxuXG4gIHN0cmVhbSAoKSB7XG4gICAgY29uc3QgaXQgPSB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCB0cnVlKVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgaXQubmV4dCgpXG4gICAgICAgIGNodW5rLmRvbmUgPyBjdHJsLmNsb3NlKCkgOiBjdHJsLmVucXVldWUoY2h1bmsudmFsdWUpXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjYW5jZWwgKCkge1xuICAgICAgICBhd2FpdCBpdC5yZXR1cm4oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXG4gICAqIG5ldyBCbG9iIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlXG4gICAqIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLnNpemUsIHR5cGUgPSAnJykge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpc1xuXG4gICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChzaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIHNpemUpXG4gICAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KHNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBzaXplKVxuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMClcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuI3BhcnRzXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBsZXQgYWRkZWQgPSAwXG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIC8vIGRvbid0IGFkZCB0aGUgb3ZlcmZsb3cgdG8gbmV3IGJsb2JQYXJ0c1xuICAgICAgaWYgKGFkZGVkID49IHNwYW4pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZVxuICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgJiYgc2l6ZSA8PSByZWxhdGl2ZVN0YXJ0KSB7XG4gICAgICAgIC8vIFNraXAgdGhlIGJlZ2lubmluZyBhbmQgY2hhbmdlIHRoZSByZWxhdGl2ZVxuICAgICAgICAvLyBzdGFydCAmIGVuZCBwb3NpdGlvbiBhcyB3ZSBza2lwIHRoZSB1bndhbnRlZCBwYXJ0c1xuICAgICAgICByZWxhdGl2ZVN0YXJ0IC09IHNpemVcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNodW5rXG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc3ViYXJyYXkocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc2xpY2UocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLnNpemVcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICByZWxhdGl2ZVN0YXJ0ID0gMCAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pXG4gICAgYmxvYi4jc2l6ZSA9IHNwYW5cbiAgICBibG9iLiNwYXJ0cyA9IGJsb2JQYXJ0c1xuXG4gICAgcmV0dXJuIGJsb2JcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICApICYmXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX0Jsb2IucHJvdG90eXBlLCB7XG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KVxuXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkJsb2J9ICovXG5leHBvcnQgY29uc3QgQmxvYiA9IF9CbG9iXG5leHBvcnQgZGVmYXVsdCBCbG9iXG4iLCIvKiEgZm9ybWRhdGEtcG9seWZpbGwuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG5cbmltcG9ydCBDIGZyb20gJ2ZldGNoLWJsb2InXG5pbXBvcnQgRiBmcm9tICdmZXRjaC1ibG9iL2ZpbGUuanMnXG5cbnZhciB7dG9TdHJpbmdUYWc6dCxpdGVyYXRvcjppLGhhc0luc3RhbmNlOmh9PVN5bWJvbCxcbnI9TWF0aC5yYW5kb20sXG5tPSdhcHBlbmQsc2V0LGdldCxnZXRBbGwsZGVsZXRlLGtleXMsdmFsdWVzLGVudHJpZXMsZm9yRWFjaCxjb25zdHJ1Y3Rvcicuc3BsaXQoJywnKSxcbmY9KGEsYixjKT0+KGErPScnLC9eKEJsb2J8RmlsZSkkLy50ZXN0KGIgJiYgYlt0XSk/WyhjPWMhPT12b2lkIDA/YysnJzpiW3RdPT0nRmlsZSc/Yi5uYW1lOidibG9iJyxhKSxiLm5hbWUhPT1jfHxiW3RdPT0nYmxvYic/bmV3IEYoW2JdLGMsYik6Yl06W2EsYisnJ10pLFxuZT0oYyxmKT0+KGY/YzpjLnJlcGxhY2UoL1xccj9cXG58XFxyL2csJ1xcclxcbicpKS5yZXBsYWNlKC9cXG4vZywnJTBBJykucmVwbGFjZSgvXFxyL2csJyUwRCcpLnJlcGxhY2UoL1wiL2csJyUyMicpLFxueD0obiwgYSwgZSk9PntpZihhLmxlbmd0aDxlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHtufScgb24gJ0Zvcm1EYXRhJzogJHtlfSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YS5sZW5ndGh9IHByZXNlbnQuYCl9fVxuXG5leHBvcnQgY29uc3QgRmlsZSA9IEZcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5Gb3JtRGF0YX0gKi9cbmV4cG9ydCBjb25zdCBGb3JtRGF0YSA9IGNsYXNzIEZvcm1EYXRhIHtcbiNkPVtdO1xuY29uc3RydWN0b3IoLi4uYSl7aWYoYS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnSFRNTEZvcm1FbGVtZW50Jy5gKX1cbmdldCBbdF0oKSB7cmV0dXJuICdGb3JtRGF0YSd9XG5baV0oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9XG5zdGF0aWMgW2hdKG8pIHtyZXR1cm4gbyYmdHlwZW9mIG89PT0nb2JqZWN0JyYmb1t0XT09PSdGb3JtRGF0YScmJiFtLnNvbWUobT0+dHlwZW9mIG9bbV0hPSdmdW5jdGlvbicpfVxuYXBwZW5kKC4uLmEpe3goJ2FwcGVuZCcsYXJndW1lbnRzLDIpO3RoaXMuI2QucHVzaChmKC4uLmEpKX1cbmRlbGV0ZShhKXt4KCdkZWxldGUnLGFyZ3VtZW50cywxKTthKz0nJzt0aGlzLiNkPXRoaXMuI2QuZmlsdGVyKChbYl0pPT5iIT09YSl9XG5nZXQoYSl7eCgnZ2V0Jyxhcmd1bWVudHMsMSk7YSs9Jyc7Zm9yKHZhciBiPXRoaXMuI2QsbD1iLmxlbmd0aCxjPTA7YzxsO2MrKylpZihiW2NdWzBdPT09YSlyZXR1cm4gYltjXVsxXTtyZXR1cm4gbnVsbH1cbmdldEFsbChhLGIpe3goJ2dldEFsbCcsYXJndW1lbnRzLDEpO2I9W107YSs9Jyc7dGhpcy4jZC5mb3JFYWNoKGM9PmNbMF09PT1hJiZiLnB1c2goY1sxXSkpO3JldHVybiBifVxuaGFzKGEpe3goJ2hhcycsYXJndW1lbnRzLDEpO2ErPScnO3JldHVybiB0aGlzLiNkLnNvbWUoYj0+YlswXT09PWEpfVxuZm9yRWFjaChhLGIpe3goJ2ZvckVhY2gnLGFyZ3VtZW50cywxKTtmb3IodmFyIFtjLGRdb2YgdGhpcylhLmNhbGwoYixkLGMsdGhpcyl9XG5zZXQoLi4uYSl7eCgnc2V0Jyxhcmd1bWVudHMsMik7dmFyIGI9W10sYz0hMDthPWYoLi4uYSk7dGhpcy4jZC5mb3JFYWNoKGQ9PntkWzBdPT09YVswXT9jJiYoYz0hYi5wdXNoKGEpKTpiLnB1c2goZCl9KTtjJiZiLnB1c2goYSk7dGhpcy4jZD1ifVxuKmVudHJpZXMoKXt5aWVsZCp0aGlzLiNkfVxuKmtleXMoKXtmb3IodmFyW2Fdb2YgdGhpcyl5aWVsZCBhfVxuKnZhbHVlcygpe2Zvcih2YXJbLGFdb2YgdGhpcyl5aWVsZCBhfX1cblxuLyoqIEBwYXJhbSB7Rm9ybURhdGF9IEYgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtRGF0YVRvQmxvYiAoRixCPUMpe1xudmFyIGI9YCR7cigpfSR7cigpfWAucmVwbGFjZSgvXFwuL2csICcnKS5zbGljZSgtMjgpLnBhZFN0YXJ0KDMyLCAnLScpLGM9W10scD1gLS0ke2J9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiYFxuRi5mb3JFYWNoKCh2LG4pPT50eXBlb2Ygdj09J3N0cmluZydcbj9jLnB1c2gocCtlKG4pK2BcIlxcclxcblxcclxcbiR7di5yZXBsYWNlKC9cXHIoPyFcXG4pfCg/PCFcXHIpXFxuL2csICdcXHJcXG4nKX1cXHJcXG5gKVxuOmMucHVzaChwK2UobikrYFwiOyBmaWxlbmFtZT1cIiR7ZSh2Lm5hbWUsIDEpfVwiXFxyXFxuQ29udGVudC1UeXBlOiAke3YudHlwZXx8XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn1cXHJcXG5cXHJcXG5gLCB2LCAnXFxyXFxuJykpXG5jLnB1c2goYC0tJHtifS0tYClcbnJldHVybiBuZXcgQihjLHt0eXBlOlwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9XCIrYn0pfVxuIiwiaW1wb3J0IGZldGNoLCB7SGVhZGVycywgUmVxdWVzdCwgUmVzcG9uc2V9IGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IEFib3J0Q29udHJvbGxlciBmcm9tICdhYm9ydC1jb250cm9sbGVyJztcblxuY29uc3QgVEVOX01FR0FCWVRFUyA9IDEwMDAgKiAxMDAwICogMTA7XG5cbmlmICghZ2xvYmFsVGhpcy5mZXRjaCkge1xuXHRnbG9iYWxUaGlzLmZldGNoID0gKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCB7aGlnaFdhdGVyTWFyazogVEVOX01FR0FCWVRFUywgLi4ub3B0aW9uc30pO1xufVxuXG5pZiAoIWdsb2JhbFRoaXMuSGVhZGVycykge1xuXHRnbG9iYWxUaGlzLkhlYWRlcnMgPSBIZWFkZXJzO1xufVxuXG5pZiAoIWdsb2JhbFRoaXMuUmVxdWVzdCkge1xuXHRnbG9iYWxUaGlzLlJlcXVlc3QgPSBSZXF1ZXN0O1xufVxuXG5pZiAoIWdsb2JhbFRoaXMuUmVzcG9uc2UpIHtcblx0Z2xvYmFsVGhpcy5SZXNwb25zZSA9IFJlc3BvbnNlO1xufVxuXG5pZiAoIWdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKSB7XG5cdGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyO1xufVxuXG5pZiAoIWdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHtcblx0dHJ5IHtcblx0XHRnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtID0gYXdhaXQgaW1wb3J0KCd3ZWItc3RyZWFtcy1wb2x5ZmlsbC9wb255ZmlsbC9lczIwMTgnKTtcblx0fSBjYXRjaCB7fVxufVxuXG5jb25zdCB7ZGVmYXVsdDoga3ksIEhUVFBFcnJvciwgVGltZW91dEVycm9yfSA9IGF3YWl0IGltcG9ydCgna3knKTtcblxuZXhwb3J0IGRlZmF1bHQga3k7XG5leHBvcnQge0hUVFBFcnJvciwgVGltZW91dEVycm9yfTtcbiIsIlxuLyoqXG4gKiBCb2R5LmpzXG4gKlxuICogQm9keSBpbnRlcmZhY2UgcHJvdmlkZXMgY29tbW9uIG1ldGhvZHMgZm9yIFJlcXVlc3QgYW5kIFJlc3BvbnNlXG4gKi9cblxuaW1wb3J0IFN0cmVhbSwge1Bhc3NUaHJvdWdofSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQge3R5cGVzLCBkZXByZWNhdGUsIHByb21pc2lmeX0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCB7QnVmZmVyfSBmcm9tICdub2RlOmJ1ZmZlcic7XG5cbmltcG9ydCBCbG9iIGZyb20gJ2ZldGNoLWJsb2InO1xuaW1wb3J0IHtGb3JtRGF0YSwgZm9ybURhdGFUb0Jsb2J9IGZyb20gJ2Zvcm1kYXRhLXBvbHlmaWxsL2VzbS5taW4uanMnO1xuXG5pbXBvcnQge0ZldGNoRXJyb3J9IGZyb20gJy4vZXJyb3JzL2ZldGNoLWVycm9yLmpzJztcbmltcG9ydCB7RmV0Y2hCYXNlRXJyb3J9IGZyb20gJy4vZXJyb3JzL2Jhc2UuanMnO1xuaW1wb3J0IHtpc0Jsb2IsIGlzVVJMU2VhcmNoUGFyYW1ldGVyc30gZnJvbSAnLi91dGlscy9pcy5qcyc7XG5cbmNvbnN0IHBpcGVsaW5lID0gcHJvbWlzaWZ5KFN0cmVhbS5waXBlbGluZSk7XG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ0JvZHkgaW50ZXJuYWxzJyk7XG5cbi8qKlxuICogQm9keSBtaXhpblxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlcbiAqXG4gKiBAcGFyYW0gICBTdHJlYW0gIGJvZHkgIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICAgT2JqZWN0ICBvcHRzICBSZXNwb25zZSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkge1xuXHRjb25zdHJ1Y3Rvcihib2R5LCB7XG5cdFx0c2l6ZSA9IDBcblx0fSA9IHt9KSB7XG5cdFx0bGV0IGJvdW5kYXJ5ID0gbnVsbDtcblxuXHRcdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0XHQvLyBCb2R5IGlzIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRib2R5ID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRcdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSk7XG5cdFx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgYmxvYlxuXHRcdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIEJ1ZmZlclxuXHRcdH0gZWxzZSBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIEFycmF5QnVmZmVyVmlld1xuXHRcdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0XHQvLyBCb2R5IGlzIHN0cmVhbVxuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHQvLyBCb2R5IGlzIEZvcm1EYXRhXG5cdFx0XHRib2R5ID0gZm9ybURhdGFUb0Jsb2IoYm9keSk7XG5cdFx0XHRib3VuZGFyeSA9IGJvZHkudHlwZS5zcGxpdCgnPScpWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBOb25lIG9mIHRoZSBhYm92ZVxuXHRcdFx0Ly8gY29lcmNlIHRvIHN0cmluZyB0aGVuIGJ1ZmZlclxuXHRcdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSk7XG5cdFx0fVxuXG5cdFx0bGV0IHN0cmVhbSA9IGJvZHk7XG5cblx0XHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0XHRzdHJlYW0gPSBTdHJlYW0uUmVhZGFibGUuZnJvbShib2R5KTtcblx0XHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdFx0c3RyZWFtID0gU3RyZWFtLlJlYWRhYmxlLmZyb20oYm9keS5zdHJlYW0oKSk7XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0Ym9keSxcblx0XHRcdHN0cmVhbSxcblx0XHRcdGJvdW5kYXJ5LFxuXHRcdFx0ZGlzdHVyYmVkOiBmYWxzZSxcblx0XHRcdGVycm9yOiBudWxsXG5cdFx0fTtcblx0XHR0aGlzLnNpemUgPSBzaXplO1xuXG5cdFx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRcdGJvZHkub24oJ2Vycm9yJywgZXJyb3JfID0+IHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBlcnJvcl8gaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvciA/XG5cdFx0XHRcdFx0ZXJyb3JfIDpcblx0XHRcdFx0XHRuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke3RoaXMudXJsfTogJHtlcnJvcl8ubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3JfKTtcblx0XHRcdFx0dGhpc1tJTlRFUk5BTFNdLmVycm9yID0gZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRnZXQgYm9keSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnN0cmVhbTtcblx0fVxuXG5cdGdldCBib2R5VXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgQXJyYXlCdWZmZXJcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgYXJyYXlCdWZmZXIoKSB7XG5cdFx0Y29uc3Qge2J1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aH0gPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcblx0fVxuXG5cdGFzeW5jIGZvcm1EYXRhKCkge1xuXHRcdGNvbnN0IGN0ID0gdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG5cblx0XHRpZiAoY3Quc3RhcnRzV2l0aCgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcblx0XHRcdGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCB0aGlzLnRleHQoKSk7XG5cblx0XHRcdGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtRGF0YTtcblx0XHR9XG5cblx0XHRjb25zdCB7dG9Gb3JtRGF0YX0gPSBhd2FpdCBpbXBvcnQoJy4vdXRpbHMvbXVsdGlwYXJ0LXBhcnNlci5qcycpO1xuXHRcdHJldHVybiB0b0Zvcm1EYXRhKHRoaXMuYm9keSwgY3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxuXHQgKlxuXHQgKiBAcmV0dXJuIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGJsb2IoKSB7XG5cdFx0Y29uc3QgY3QgPSAodGhpcy5oZWFkZXJzICYmIHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB8fCAodGhpc1tJTlRFUk5BTFNdLmJvZHkgJiYgdGhpc1tJTlRFUk5BTFNdLmJvZHkudHlwZSkgfHwgJyc7XG5cdFx0Y29uc3QgYnVmID0gYXdhaXQgdGhpcy5hcnJheUJ1ZmZlcigpO1xuXG5cdFx0cmV0dXJuIG5ldyBCbG9iKFtidWZdLCB7XG5cdFx0XHR0eXBlOiBjdFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSByZXNwb25zZSBhcyBqc29uXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGpzb24oKSB7XG5cdFx0Y29uc3QgdGV4dCA9IGF3YWl0IHRoaXMudGV4dCgpO1xuXHRcdHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0XG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIHRleHQoKSB7XG5cdFx0Y29uc3QgYnVmZmVyID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSByZXNwb25zZSBhcyBidWZmZXIgKG5vbi1zcGVjIGFwaSlcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keSh0aGlzKTtcblx0fVxufVxuXG5Cb2R5LnByb3RvdHlwZS5idWZmZXIgPSBkZXByZWNhdGUoQm9keS5wcm90b3R5cGUuYnVmZmVyLCAnUGxlYXNlIHVzZSBcXCdyZXNwb25zZS5hcnJheUJ1ZmZlcigpXFwnIGluc3RlYWQgb2YgXFwncmVzcG9uc2UuYnVmZmVyKClcXCcnLCAnbm9kZS1mZXRjaCNidWZmZXInKTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keToge2VudW1lcmFibGU6IHRydWV9LFxuXHRib2R5VXNlZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRhcnJheUJ1ZmZlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRibG9iOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGpzb246IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRkYXRhOiB7Z2V0OiBkZXByZWNhdGUoKCkgPT4ge30sXG5cdFx0J2RhdGEgZG9lc25cXCd0IGV4aXN0LCB1c2UganNvbigpLCB0ZXh0KCksIGFycmF5QnVmZmVyKCksIG9yIGJvZHkgaW5zdGVhZCcsXG5cdFx0J2h0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlc3BvbnNlKScpfVxufSk7XG5cbi8qKlxuICogQ29uc3VtZSBhbmQgY29udmVydCBhbiBlbnRpcmUgQm9keSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKlxuICogQHJldHVybiBQcm9taXNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVCb2R5KGRhdGEpIHtcblx0aWYgKGRhdGFbSU5URVJOQUxTXS5kaXN0dXJiZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBib2R5IHVzZWQgYWxyZWFkeSBmb3I6ICR7ZGF0YS51cmx9YCk7XG5cdH1cblxuXHRkYXRhW0lOVEVSTkFMU10uZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAoZGF0YVtJTlRFUk5BTFNdLmVycm9yKSB7XG5cdFx0dGhyb3cgZGF0YVtJTlRFUk5BTFNdLmVycm9yO1xuXHR9XG5cblx0Y29uc3Qge2JvZHl9ID0gZGF0YTtcblxuXHQvLyBCb2R5IGlzIG51bGxcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXHR9XG5cblx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRpZiAoIShib2R5IGluc3RhbmNlb2YgU3RyZWFtKSkge1xuXHRcdHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmVhbVxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxuXHRjb25zdCBhY2N1bSA9IFtdO1xuXHRsZXQgYWNjdW1CeXRlcyA9IDA7XG5cblx0dHJ5IHtcblx0XHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcblx0XHRcdGlmIChkYXRhLnNpemUgPiAwICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBkYXRhLnNpemUpIHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7ZGF0YS51cmx9IG92ZXIgbGltaXQ6ICR7ZGF0YS5zaXplfWAsICdtYXgtc2l6ZScpO1xuXHRcdFx0XHRib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc3QgZXJyb3JfID0gZXJyb3IgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvciA/IGVycm9yIDogbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdHRocm93IGVycm9yXztcblx0fVxuXG5cdGlmIChib2R5LnJlYWRhYmxlRW5kZWQgPT09IHRydWUgfHwgYm9keS5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9PT0gdHJ1ZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoYWNjdW0uZXZlcnkoYyA9PiB0eXBlb2YgYyA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRcdHJldHVybiBCdWZmZXIuZnJvbShhY2N1bS5qb2luKCcnKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBCdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgQnVmZmVyIGZyb20gcmVzcG9uc2UgYm9keSBmb3IgJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH1gKTtcblx0fVxufVxuXG4vKipcbiAqIENsb25lIGJvZHkgZ2l2ZW4gUmVzL1JlcSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5zdGFuY2UgICAgICAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgU3RyaW5nICBoaWdoV2F0ZXJNYXJrICBoaWdoV2F0ZXJNYXJrIGZvciBib3RoIFBhc3NUaHJvdWdoIGJvZHkgc3RyZWFtc1xuICogQHJldHVybiAgTWl4ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gKGluc3RhbmNlLCBoaWdoV2F0ZXJNYXJrKSA9PiB7XG5cdGxldCBwMTtcblx0bGV0IHAyO1xuXHRsZXQge2JvZHl9ID0gaW5zdGFuY2VbSU5URVJOQUxTXTtcblxuXHQvLyBEb24ndCBhbGxvdyBjbG9uaW5nIGEgdXNlZCBib2R5XG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZCcpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgdGhhdCBib2R5IGlzIGEgc3RyZWFtIGFuZCBub3QgZm9ybS1kYXRhIG9iamVjdFxuXHQvLyBub3RlOiB3ZSBjYW4ndCBjbG9uZSB0aGUgZm9ybS1kYXRhIG9iamVjdCB3aXRob3V0IGhhdmluZyBpdCBhcyBhIGRlcGVuZGVuY3lcblx0aWYgKChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSAmJiAodHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0Ly8gVGVlIGluc3RhbmNlIGJvZHlcblx0XHRwMSA9IG5ldyBQYXNzVGhyb3VnaCh7aGlnaFdhdGVyTWFya30pO1xuXHRcdHAyID0gbmV3IFBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrfSk7XG5cdFx0Ym9keS5waXBlKHAxKTtcblx0XHRib2R5LnBpcGUocDIpO1xuXHRcdC8vIFNldCBpbnN0YW5jZSBib2R5IHRvIHRlZWQgYm9keSBhbmQgcmV0dXJuIHRoZSBvdGhlciB0ZWVkIGJvZHlcblx0XHRpbnN0YW5jZVtJTlRFUk5BTFNdLnN0cmVhbSA9IHAxO1xuXHRcdGJvZHkgPSBwMjtcblx0fVxuXG5cdHJldHVybiBib2R5O1xufTtcblxuY29uc3QgZ2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkgPSBkZXByZWNhdGUoXG5cdGJvZHkgPT4gYm9keS5nZXRCb3VuZGFyeSgpLFxuXHQnZm9ybS1kYXRhIGRvZXNuXFwndCBmb2xsb3cgdGhlIHNwZWMgYW5kIHJlcXVpcmVzIHNwZWNpYWwgdHJlYXRtZW50LiBVc2UgYWx0ZXJuYXRpdmUgcGFja2FnZScsXG5cdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMTY3J1xuKTtcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gYm9keSBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RDb250ZW50VHlwZSA9IChib2R5LCByZXF1ZXN0KSA9PiB7XG5cdC8vIEJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWRcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyaW5nXG5cdGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdGlmIChpc1VSTFNlYXJjaFBhcmFtZXRlcnMoYm9keSkpIHtcblx0XHRyZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jztcblx0fVxuXG5cdC8vIEJvZHkgaXMgYmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkudHlwZSB8fCBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBhIEJ1ZmZlciAoQnVmZmVyLCBBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkgfHwgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7cmVxdWVzdFtJTlRFUk5BTFNdLmJvdW5kYXJ5fWA7XG5cdH1cblxuXHQvLyBEZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTtib3VuZGFyeT0ke2dldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5KGJvZHkpfWA7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmVhbSAtIGNhbid0IHJlYWxseSBkbyBtdWNoIGFib3V0IHRoaXNcblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgY29uc3RydWN0b3IgZGVmYXVsdHMgb3RoZXIgdGhpbmdzIHRvIHN0cmluZ1xuXHRyZXR1cm4gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG59O1xuXG4vKipcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cbiAqIEZvciB1cywgd2UgaGF2ZSB0byBleHBsaWNpdGx5IGdldCBpdCB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXG4gKlxuICogQHBhcmFtIHthbnl9IG9iai5ib2R5IEJvZHkgb2JqZWN0IGZyb20gdGhlIEJvZHkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRvdGFsQnl0ZXMgPSByZXF1ZXN0ID0+IHtcblx0Y29uc3Qge2JvZHl9ID0gcmVxdWVzdFtJTlRFUk5BTFNdO1xuXG5cdC8vIEJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWRcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkuc2l6ZTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQnVmZmVyXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH1cblxuXHQvLyBEZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRMZW5ndGhTeW5jID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGJvZHkuaGFzS25vd25MZW5ndGggJiYgYm9keS5oYXNLbm93bkxlbmd0aCgpID8gYm9keS5nZXRMZW5ndGhTeW5jKCkgOiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW1cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgQm9keSB0byBhIE5vZGUuanMgV3JpdGFibGVTdHJlYW0gKGUuZy4gaHR0cC5SZXF1ZXN0KSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJlYW0uV3JpdGFibGV9IGRlc3QgVGhlIHN0cmVhbSB0byB3cml0ZSB0by5cbiAqIEBwYXJhbSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVRvU3RyZWFtID0gYXN5bmMgKGRlc3QsIHtib2R5fSkgPT4ge1xuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIEJvZHkgaXMgbnVsbFxuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQm9keSBpcyBzdHJlYW1cblx0XHRhd2FpdCBwaXBlbGluZShib2R5LCBkZXN0KTtcblx0fVxufTtcbiIsImltcG9ydCB7RmV0Y2hCYXNlRXJyb3J9IGZyb20gJy4vYmFzZS5qcyc7XG5cbi8qKlxuICogQWJvcnRFcnJvciBpbnRlcmZhY2UgZm9yIGNhbmNlbGxlZCByZXF1ZXN0c1xuICovXG5leHBvcnQgY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEZldGNoQmFzZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSA9ICdhYm9ydGVkJykge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHR5cGUpO1xuXHR9XG59XG4iLCJleHBvcnQgY2xhc3MgRmV0Y2hCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHQvLyBIaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR9XG5cblx0Z2V0IG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHR9XG59XG4iLCJcbmltcG9ydCB7RmV0Y2hCYXNlRXJyb3J9IGZyb20gJy4vYmFzZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3sgYWRkcmVzcz86IHN0cmluZywgY29kZTogc3RyaW5nLCBkZXN0Pzogc3RyaW5nLCBlcnJubzogbnVtYmVyLCBpbmZvPzogb2JqZWN0LCBtZXNzYWdlOiBzdHJpbmcsIHBhdGg/OiBzdHJpbmcsIHBvcnQ/OiBudW1iZXIsIHN5c2NhbGw6IHN0cmluZ319IFN5c3RlbUVycm9yXG4qL1xuXG4vKipcbiAqIEZldGNoRXJyb3IgaW50ZXJmYWNlIGZvciBvcGVyYXRpb25hbCBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2UgLSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gW3R5cGVdIC0gICAgICAgIEVycm9yIHR5cGUgZm9yIG1hY2hpbmVcblx0ICogQHBhcmFtICB7U3lzdGVtRXJyb3J9IFtzeXN0ZW1FcnJvcl0gLSBGb3IgTm9kZS5qcyBzeXN0ZW0gZXJyb3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUsIHN5c3RlbUVycm9yKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgdHlwZSk7XG5cdFx0Ly8gV2hlbiBlcnIudHlwZSBpcyBgc3lzdGVtYCwgZXJyLmVycm9yZWRTeXNDYWxsIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBhbmQgZXJyLmNvZGUgY29udGFpbnMgc3lzdGVtIGVycm9yIGNvZGVcblx0XHRpZiAoc3lzdGVtRXJyb3IpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cblx0XHRcdHRoaXMuY29kZSA9IHRoaXMuZXJybm8gPSBzeXN0ZW1FcnJvci5jb2RlO1xuXHRcdFx0dGhpcy5lcnJvcmVkU3lzQ2FsbCA9IHN5c3RlbUVycm9yLnN5c2NhbGw7XG5cdFx0fVxuXHR9XG59XG4iLCIvKipcbiAqIEhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG5pbXBvcnQge3R5cGVzfSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IGh0dHAgZnJvbSAnbm9kZTpodHRwJztcblxuLyogYzggaWdub3JlIG5leHQgOSAqL1xuY29uc3QgdmFsaWRhdGVIZWFkZXJOYW1lID0gdHlwZW9mIGh0dHAudmFsaWRhdGVIZWFkZXJOYW1lID09PSAnZnVuY3Rpb24nID9cblx0aHR0cC52YWxpZGF0ZUhlYWRlck5hbWUgOlxuXHRuYW1lID0+IHtcblx0XHRpZiAoIS9eW1xcXmBcXC1cXHchIyQlJicqKy58fl0rJC8udGVzdChuYW1lKSkge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGBIZWFkZXIgbmFtZSBtdXN0IGJlIGEgdmFsaWQgSFRUUCB0b2tlbiBbJHtuYW1lfV1gKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJ30pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9O1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA5ICovXG5jb25zdCB2YWxpZGF0ZUhlYWRlclZhbHVlID0gdHlwZW9mIGh0dHAudmFsaWRhdGVIZWFkZXJWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdGh0dHAudmFsaWRhdGVIZWFkZXJWYWx1ZSA6XG5cdChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdGlmICgvW15cXHRcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgY29udGVudCBbXCIke25hbWV9XCJdYCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2RlJywge3ZhbHVlOiAnRVJSX0lOVkFMSURfQ0hBUid9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7SGVhZGVycyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBzdHJpbmddPiB8IEl0ZXJhYmxlPEl0ZXJhYmxlPHN0cmluZz4+fSBIZWFkZXJzSW5pdFxuICovXG5cbi8qKlxuICogVGhpcyBGZXRjaCBBUEkgaW50ZXJmYWNlIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB2YXJpb3VzIGFjdGlvbnMgb24gSFRUUCByZXF1ZXN0IGFuZCByZXNwb25zZSBoZWFkZXJzLlxuICogVGhlc2UgYWN0aW9ucyBpbmNsdWRlIHJldHJpZXZpbmcsIHNldHRpbmcsIGFkZGluZyB0bywgYW5kIHJlbW92aW5nLlxuICogQSBIZWFkZXJzIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBoZWFkZXIgbGlzdCwgd2hpY2ggaXMgaW5pdGlhbGx5IGVtcHR5IGFuZCBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgbmFtZSBhbmQgdmFsdWUgcGFpcnMuXG4gKiBZb3UgY2FuIGFkZCB0byB0aGlzIHVzaW5nIG1ldGhvZHMgbGlrZSBhcHBlbmQoKSAoc2VlIEV4YW1wbGVzLilcbiAqIEluIGFsbCBtZXRob2RzIG9mIHRoaXMgaW50ZXJmYWNlLCBoZWFkZXIgbmFtZXMgYXJlIG1hdGNoZWQgYnkgY2FzZS1pbnNlbnNpdGl2ZSBieXRlIHNlcXVlbmNlLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVycyBleHRlbmRzIFVSTFNlYXJjaFBhcmFtcyB7XG5cdC8qKlxuXHQgKiBIZWFkZXJzIGNsYXNzXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hlYWRlcnNJbml0fSBbaW5pdF0gLSBSZXNwb25zZSBoZWFkZXJzXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihpbml0KSB7XG5cdFx0Ly8gVmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSBpbml0IG9iamVjdCBpbiBbbmFtZSwgdmFsdWUocyldW11cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdW119ICovXG5cdFx0bGV0IHJlc3VsdCA9IFtdO1xuXHRcdGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVycykge1xuXHRcdFx0Y29uc3QgcmF3ID0gaW5pdC5yYXcoKTtcblx0XHRcdGZvciAoY29uc3QgW25hbWUsIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMocmF3KSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCguLi52YWx1ZXMubWFwKHZhbHVlID0+IFtuYW1lLCB2YWx1ZV0pKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGluaXQgPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdFx0Ly8gTm8gb3Bcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAhdHlwZXMuaXNCb3hlZFByaW1pdGl2ZShpbml0KSkge1xuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdFx0aWYgKG1ldGhvZCA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlxuXHRcdFx0XHRyZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlciBwYWlycyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdFx0Ly8gTm90ZTogcGVyIHNwZWMgd2UgaGF2ZSB0byBmaXJzdCBleGhhdXN0IHRoZSBsaXN0cyB0aGVuIHByb2Nlc3MgdGhlbVxuXHRcdFx0XHRyZXN1bHQgPSBbLi4uaW5pdF1cblx0XHRcdFx0XHQubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgdHlwZXMuaXNCb3hlZFByaW1pdGl2ZShwYWlyKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhbiBpdGVyYWJsZSBvYmplY3QnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0XHR9KS5tYXAocGFpciA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocGFpci5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gWy4uLnBhaXJdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0hlYWRlcnNcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSBcXCcoc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+IG9yIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiknKTtcblx0XHR9XG5cblx0XHQvLyBWYWxpZGF0ZSBhbmQgbG93ZXJjYXNlXG5cdFx0cmVzdWx0ID1cblx0XHRcdHJlc3VsdC5sZW5ndGggPiAwID9cblx0XHRcdFx0cmVzdWx0Lm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdHJldHVybiBbU3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCksIFN0cmluZyh2YWx1ZSldO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblxuXHRcdHN1cGVyKHJlc3VsdCk7XG5cblx0XHQvLyBSZXR1cm5pbmcgYSBQcm94eSB0aGF0IHdpbGwgbG93ZXJjYXNlIGtleSBuYW1lcywgdmFsaWRhdGUgcGFyYW1ldGVycyBhbmQgc29ydCBrZXlzXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuXHRcdHJldHVybiBuZXcgUHJveHkodGhpcywge1xuXHRcdFx0Z2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpIHtcblx0XHRcdFx0c3dpdGNoIChwKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYXBwZW5kJzpcblx0XHRcdFx0XHRjYXNlICdzZXQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdkZWxldGUnOlxuXHRcdFx0XHRcdGNhc2UgJ2hhcyc6XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0QWxsJzpcblx0XHRcdFx0XHRcdHJldHVybiBuYW1lID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtwXS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgJ2tleXMnOlxuXHRcdFx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnNvcnQoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBTZXQoVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzLmNhbGwodGFyZ2V0KSkua2V5cygpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwLCByZWNlaXZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAqL1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9XG5cblx0Z2V0KG5hbWUpIHtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChuYW1lKTtcblx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IHZhbHVlID0gdmFsdWVzLmpvaW4oJywgJyk7XG5cdFx0aWYgKC9eY29udGVudC1lbmNvZGluZyQvaS50ZXN0KG5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Zm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyA9IHVuZGVmaW5lZCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0UmVmbGVjdC5hcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3RoaXMuZ2V0KG5hbWUpLCBuYW1lLCB0aGlzXSk7XG5cdFx0fVxuXHR9XG5cblx0KiB2YWx1ZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHR5aWVsZCB0aGlzLmdldChuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IEl0ZXJhYmxlSXRlcmF0b3I8W3N0cmluZywgc3RyaW5nXT59XG5cdCAqL1xuXHQqIGVudHJpZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHR5aWVsZCBbbmFtZSwgdGhpcy5nZXQobmFtZSldO1xuXHRcdH1cblx0fVxuXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb2RlLWZldGNoIG5vbi1zcGVjIG1ldGhvZFxuXHQgKiByZXR1cm5pbmcgYWxsIGhlYWRlcnMgYW5kIHRoZWlyIHZhbHVlcyBhcyBhcnJheVxuXHQgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nW10+fVxuXHQgKi9cblx0cmF3KCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdHJlc3VsdFtrZXldID0gdGhpcy5nZXRBbGwoa2V5KTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvciBiZXR0ZXIgY29uc29sZS5sb2coaGVhZGVycykgYW5kIGFsc28gdG8gY29udmVydCBIZWFkZXJzIGludG8gTm9kZS5qcyBSZXF1ZXN0IGNvbXBhdGlibGUgZm9ybWF0XG5cdCAqL1xuXHRbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwoa2V5KTtcblx0XHRcdC8vIEh0dHAucmVxdWVzdCgpIG9ubHkgc3VwcG9ydHMgc3RyaW5nIGFzIEhvc3QgaGVhZGVyLlxuXHRcdFx0Ly8gVGhpcyBoYWNrIG1ha2VzIHNwZWNpZnlpbmcgY3VzdG9tIEhvc3QgaGVhZGVyIHBvc3NpYmxlLlxuXHRcdFx0aWYgKGtleSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZXMubGVuZ3RoID4gMSA/IHZhbHVlcyA6IHZhbHVlc1swXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCB7fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZS1zaGFwaW5nIG9iamVjdCBmb3IgV2ViIElETCB0ZXN0c1xuICogT25seSBuZWVkIHRvIGRvIGl0IGZvciBvdmVycmlkZGVuIG1ldGhvZHNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG5cdEhlYWRlcnMucHJvdG90eXBlLFxuXHRbJ2dldCcsICdlbnRyaWVzJywgJ2ZvckVhY2gnLCAndmFsdWVzJ10ucmVkdWNlKChyZXN1bHQsIHByb3BlcnR5KSA9PiB7XG5cdFx0cmVzdWx0W3Byb3BlcnR5XSA9IHtlbnVtZXJhYmxlOiB0cnVlfTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LCB7fSlcbik7XG5cbi8qKlxuICogQ3JlYXRlIGEgSGVhZGVycyBvYmplY3QgZnJvbSBhbiBodHRwLkluY29taW5nTWVzc2FnZS5yYXdIZWFkZXJzLCBpZ25vcmluZyB0aG9zZSB0aGF0IGRvXG4gKiBub3QgY29uZm9ybSB0byBIVFRQIGdyYW1tYXIgcHJvZHVjdGlvbnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnaHR0cCcpLkluY29taW5nTWVzc2FnZVsncmF3SGVhZGVycyddfSBoZWFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmF3SGVhZGVycyhoZWFkZXJzID0gW10pIHtcblx0cmV0dXJuIG5ldyBIZWFkZXJzKFxuXHRcdGhlYWRlcnNcblx0XHRcdC8vIFNwbGl0IGludG8gcGFpcnNcblx0XHRcdC5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuXHRcdFx0XHRpZiAoaW5kZXggJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaW5kZXgsIGluZGV4ICsgMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sIFtdKVxuXHRcdFx0LmZpbHRlcigoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0KTtcbn1cbiIsIi8qKlxuICogSW5kZXguanNcbiAqXG4gKiBhIHJlcXVlc3QgQVBJIGNvbXBhdGlibGUgd2l0aCB3aW5kb3cuZmV0Y2hcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmltcG9ydCBodHRwIGZyb20gJ25vZGU6aHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnbm9kZTpodHRwcyc7XG5pbXBvcnQgemxpYiBmcm9tICdub2RlOnpsaWInO1xuaW1wb3J0IFN0cmVhbSwge1Bhc3NUaHJvdWdoLCBwaXBlbGluZSBhcyBwdW1wfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnbm9kZTpidWZmZXInO1xuXG5pbXBvcnQgZGF0YVVyaVRvQnVmZmVyIGZyb20gJ2RhdGEtdXJpLXRvLWJ1ZmZlcic7XG5cbmltcG9ydCB7d3JpdGVUb1N0cmVhbSwgY2xvbmV9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQgUmVzcG9uc2UgZnJvbSAnLi9yZXNwb25zZS5qcyc7XG5pbXBvcnQgSGVhZGVycywge2Zyb21SYXdIZWFkZXJzfSBmcm9tICcuL2hlYWRlcnMuanMnO1xuaW1wb3J0IFJlcXVlc3QsIHtnZXROb2RlUmVxdWVzdE9wdGlvbnN9IGZyb20gJy4vcmVxdWVzdC5qcyc7XG5pbXBvcnQge0ZldGNoRXJyb3J9IGZyb20gJy4vZXJyb3JzL2ZldGNoLWVycm9yLmpzJztcbmltcG9ydCB7QWJvcnRFcnJvcn0gZnJvbSAnLi9lcnJvcnMvYWJvcnQtZXJyb3IuanMnO1xuaW1wb3J0IHtpc1JlZGlyZWN0fSBmcm9tICcuL3V0aWxzL2lzLXJlZGlyZWN0LmpzJztcbmltcG9ydCB7Rm9ybURhdGF9IGZyb20gJ2Zvcm1kYXRhLXBvbHlmaWxsL2VzbS5taW4uanMnO1xuaW1wb3J0IHtpc0RvbWFpbk9yU3ViZG9tYWluLCBpc1NhbWVQcm90b2NvbH0gZnJvbSAnLi91dGlscy9pcy5qcyc7XG5pbXBvcnQge3BhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyfSBmcm9tICcuL3V0aWxzL3JlZmVycmVyLmpzJztcbmltcG9ydCB7XG5cdEJsb2IsXG5cdEZpbGUsXG5cdGZpbGVGcm9tU3luYyxcblx0ZmlsZUZyb20sXG5cdGJsb2JGcm9tU3luYyxcblx0YmxvYkZyb21cbn0gZnJvbSAnZmV0Y2gtYmxvYi9mcm9tLmpzJztcblxuZXhwb3J0IHtGb3JtRGF0YSwgSGVhZGVycywgUmVxdWVzdCwgUmVzcG9uc2UsIEZldGNoRXJyb3IsIEFib3J0RXJyb3IsIGlzUmVkaXJlY3R9O1xuZXhwb3J0IHtCbG9iLCBGaWxlLCBmaWxlRnJvbVN5bmMsIGZpbGVGcm9tLCBibG9iRnJvbVN5bmMsIGJsb2JGcm9tfTtcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1hcyA9IG5ldyBTZXQoWydkYXRhOicsICdodHRwOicsICdodHRwczonXSk7XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nIHwgVVJMIHwgaW1wb3J0KCcuL3JlcXVlc3QnKS5kZWZhdWx0fSB1cmwgLSBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgeyp9IFtvcHRpb25zX10gLSBGZXRjaCBvcHRpb25zXG4gKiBAcmV0dXJuICB7UHJvbWlzZTxpbXBvcnQoJy4vcmVzcG9uc2UnKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmV0Y2godXJsLCBvcHRpb25zXykge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdC8vIEJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9uc18pO1xuXHRcdGNvbnN0IHtwYXJzZWRVUkwsIG9wdGlvbnN9ID0gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpO1xuXHRcdGlmICghc3VwcG9ydGVkU2NoZW1hcy5oYXMocGFyc2VkVVJMLnByb3RvY29sKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgbm9kZS1mZXRjaCBjYW5ub3QgbG9hZCAke3VybH0uIFVSTCBzY2hlbWUgXCIke3BhcnNlZFVSTC5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKX1cIiBpcyBub3Qgc3VwcG9ydGVkLmApO1xuXHRcdH1cblxuXHRcdGlmIChwYXJzZWRVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBkYXRhVXJpVG9CdWZmZXIocmVxdWVzdC51cmwpO1xuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZGF0YSwge2hlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogZGF0YS50eXBlRnVsbH19KTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdyYXAgaHR0cC5yZXF1ZXN0IGludG8gZmV0Y2hcblx0XHRjb25zdCBzZW5kID0gKHBhcnNlZFVSTC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Q7XG5cdFx0Y29uc3Qge3NpZ25hbH0gPSByZXF1ZXN0O1xuXHRcdGxldCByZXNwb25zZSA9IG51bGw7XG5cblx0XHRjb25zdCBhYm9ydCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEFib3J0RXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJyk7XG5cdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0aWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUpIHtcblx0XHRcdFx0cmVxdWVzdC5ib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5ib2R5KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fTtcblxuXHRcdC8vIFNlbmQgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcXVlc3RfID0gc2VuZChwYXJzZWRVUkwudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG5cblx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHR9XG5cblx0XHRjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcblx0XHRcdHJlcXVlc3RfLmFib3J0KCk7XG5cdFx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRcdHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXF1ZXN0Xy5vbignZXJyb3InLCBlcnJvciA9PiB7XG5cdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gZmFpbGVkLCByZWFzb246ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fSk7XG5cblx0XHRmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyhyZXF1ZXN0XywgZXJyb3IgPT4ge1xuXHRcdFx0aWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0cmVzcG9uc2UuYm9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIGM4IGlnbm9yZSBuZXh0IDE4ICovXG5cdFx0aWYgKHByb2Nlc3MudmVyc2lvbiA8ICd2MTQnKSB7XG5cdFx0XHQvLyBCZWZvcmUgTm9kZS5qcyAxNCwgcGlwZWxpbmUoKSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycyBhbmQgZG9lcyBub3QgYWx3YXlzXG5cdFx0XHQvLyBwcm9wZXJseSBoYW5kbGUgd2hlbiB0aGUgc29ja2V0IGNsb3NlL2VuZCBldmVudHMgYXJlIG91dCBvZiBvcmRlci5cblx0XHRcdHJlcXVlc3RfLm9uKCdzb2NrZXQnLCBzID0+IHtcblx0XHRcdFx0bGV0IGVuZGVkV2l0aEV2ZW50c0NvdW50O1xuXHRcdFx0XHRzLnByZXBlbmRMaXN0ZW5lcignZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdGVuZGVkV2l0aEV2ZW50c0NvdW50ID0gcy5fZXZlbnRzQ291bnQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzLnByZXBlbmRMaXN0ZW5lcignY2xvc2UnLCBoYWRFcnJvciA9PiB7XG5cdFx0XHRcdFx0Ly8gaWYgZW5kIGhhcHBlbmVkIGJlZm9yZSBjbG9zZSBidXQgdGhlIHNvY2tldCBkaWRuJ3QgZW1pdCBhbiBlcnJvciwgZG8gaXQgbm93XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlICYmIGVuZGVkV2l0aEV2ZW50c0NvdW50IDwgcy5fZXZlbnRzQ291bnQgJiYgIWhhZEVycm9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdFx0XHRlcnJvci5jb2RlID0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJztcblx0XHRcdFx0XHRcdHJlc3BvbnNlLmJvZHkuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3RfLm9uKCdyZXNwb25zZScsIHJlc3BvbnNlXyA9PiB7XG5cdFx0XHRyZXF1ZXN0Xy5zZXRUaW1lb3V0KDApO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IGZyb21SYXdIZWFkZXJzKHJlc3BvbnNlXy5yYXdIZWFkZXJzKTtcblxuXHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDVcblx0XHRcdGlmIChpc1JlZGlyZWN0KHJlc3BvbnNlXy5zdGF0dXNDb2RlKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRsZXQgbG9jYXRpb25VUkwgPSBudWxsO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxvY2F0aW9uVVJMID0gbG9jYXRpb24gPT09IG51bGwgPyBudWxsIDogbmV3IFVSTChsb2NhdGlvbiwgcmVxdWVzdC51cmwpO1xuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHQvLyBlcnJvciBoZXJlIGNhbiBvbmx5IGJlIGludmFsaWQgVVJMIGluIExvY2F0aW9uOiBoZWFkZXJcblx0XHRcdFx0XHQvLyBkbyBub3QgdGhyb3cgd2hlbiBvcHRpb25zLnJlZGlyZWN0ID09IG1hbnVhbFxuXHRcdFx0XHRcdC8vIGxldCB0aGUgdXNlciBleHRyYWN0IHRoZSBlcnJvcm5lb3VzIHJlZGlyZWN0IFVSTFxuXHRcdFx0XHRcdGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnbWFudWFsJykge1xuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGB1cmkgcmVxdWVzdGVkIHJlc3BvbmRzIHdpdGggYW4gaW52YWxpZCByZWRpcmVjdCBVUkw6ICR7bG9jYXRpb259YCwgJ2ludmFsaWQtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjVcblx0XHRcdFx0c3dpdGNoIChyZXF1ZXN0LnJlZGlyZWN0KSB7XG5cdFx0XHRcdFx0Y2FzZSAnZXJyb3InOlxuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGB1cmkgcmVxdWVzdGVkIHJlc3BvbmRzIHdpdGggYSByZWRpcmVjdCwgcmVkaXJlY3QgbW9kZSBpcyBzZXQgdG8gZXJyb3I6ICR7cmVxdWVzdC51cmx9YCwgJ25vLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRjYXNlICdtYW51YWwnOlxuXHRcdFx0XHRcdFx0Ly8gTm90aGluZyB0byBkb1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZm9sbG93Jzoge1xuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHRib2R5OiBjbG9uZShyZXF1ZXN0KSxcblx0XHRcdFx0XHRcdFx0c2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcblx0XHRcdFx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHRcdFx0XHRyZWZlcnJlcjogcmVxdWVzdC5yZWZlcnJlcixcblx0XHRcdFx0XHRcdFx0cmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QucmVmZXJyZXJQb2xpY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIHdoZW4gZm9yd2FyZGluZyBzZW5zaXRpdmUgaGVhZGVycyBsaWtlIFwiQXV0aG9yaXphdGlvblwiLFxuXHRcdFx0XHRcdFx0Ly8gXCJXV1ctQXV0aGVudGljYXRlXCIsIGFuZCBcIkNvb2tpZVwiIHRvIHVudHJ1c3RlZCB0YXJnZXRzLFxuXHRcdFx0XHRcdFx0Ly8gaGVhZGVycyB3aWxsIGJlIGlnbm9yZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIGRvbWFpblxuXHRcdFx0XHRcdFx0Ly8gdGhhdCBpcyBub3QgYSBzdWJkb21haW4gbWF0Y2ggb3IgZXhhY3QgbWF0Y2ggb2YgdGhlIGluaXRpYWwgZG9tYWluLlxuXHRcdFx0XHRcdFx0Ly8gRm9yIGV4YW1wbGUsIGEgcmVkaXJlY3QgZnJvbSBcImZvby5jb21cIiB0byBlaXRoZXIgXCJmb28uY29tXCIgb3IgXCJzdWIuZm9vLmNvbVwiXG5cdFx0XHRcdFx0XHQvLyB3aWxsIGZvcndhcmQgdGhlIHNlbnNpdGl2ZSBoZWFkZXJzLCBidXQgYSByZWRpcmVjdCB0byBcImJhci5jb21cIiB3aWxsIG5vdC5cblx0XHRcdFx0XHRcdC8vIGhlYWRlcnMgd2lsbCBhbHNvIGJlIGlnbm9yZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIGRvbWFpbiB1c2luZ1xuXHRcdFx0XHRcdFx0Ly8gYSBkaWZmZXJlbnQgcHJvdG9jb2wuIEZvciBleGFtcGxlLCBhIHJlZGlyZWN0IGZyb20gXCJodHRwczovL2Zvby5jb21cIiB0byBcImh0dHA6Ly9mb28uY29tXCJcblx0XHRcdFx0XHRcdC8vIHdpbGwgbm90IGZvcndhcmQgdGhlIHNlbnNpdGl2ZSBoZWFkZXJzXG5cdFx0XHRcdFx0XHRpZiAoIWlzRG9tYWluT3JTdWJkb21haW4ocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSB8fCAhaXNTYW1lUHJvdG9jb2wocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgWydhdXRob3JpemF0aW9uJywgJ3d3dy1hdXRoZW50aWNhdGUnLCAnY29va2llJywgJ2Nvb2tpZTInXSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuZGVsZXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA5XG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VfLnN0YXR1c0NvZGUgIT09IDMwMyAmJiByZXF1ZXN0LmJvZHkgJiYgb3B0aW9uc18uYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoJ0Nhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtJywgJ3Vuc3VwcG9ydGVkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxMVxuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDMgfHwgKChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDIpICYmIHJlcXVlc3QubWV0aG9kID09PSAnUE9TVCcpKSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5ib2R5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLmRlbGV0ZSgnY29udGVudC1sZW5ndGgnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDE0XG5cdFx0XHRcdFx0XHRjb25zdCByZXNwb25zZVJlZmVycmVyUG9saWN5ID0gcGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoaGVhZGVycyk7XG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VSZWZlcnJlclBvbGljeSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5yZWZlcnJlclBvbGljeSA9IHJlc3BvbnNlUmVmZXJyZXJQb2xpY3k7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShmZXRjaChuZXcgUmVxdWVzdChsb2NhdGlvblVSTCwgcmVxdWVzdE9wdGlvbnMpKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoYFJlZGlyZWN0IG9wdGlvbiAnJHtyZXF1ZXN0LnJlZGlyZWN0fScgaXMgbm90IGEgdmFsaWQgdmFsdWUgb2YgUmVxdWVzdFJlZGlyZWN0YCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uY2UoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBib2R5ID0gcHVtcChyZXNwb25zZV8sIG5ldyBQYXNzVGhyb3VnaCgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzI5Mzc2XG5cdFx0XHQvKiBjOCBpZ25vcmUgbmV4dCAzICovXG5cdFx0XHRpZiAocHJvY2Vzcy52ZXJzaW9uIDwgJ3YxMi4xMCcpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uKCdhYm9ydGVkJywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3BvbnNlT3B0aW9ucyA9IHtcblx0XHRcdFx0dXJsOiByZXF1ZXN0LnVybCxcblx0XHRcdFx0c3RhdHVzOiByZXNwb25zZV8uc3RhdHVzQ29kZSxcblx0XHRcdFx0c3RhdHVzVGV4dDogcmVzcG9uc2VfLnN0YXR1c01lc3NhZ2UsXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyLFxuXHRcdFx0XHRoaWdoV2F0ZXJNYXJrOiByZXF1ZXN0LmhpZ2hXYXRlck1hcmtcblx0XHRcdH07XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS4zXG5cdFx0XHRjb25zdCBjb2RpbmdzID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtRW5jb2RpbmcnKTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjQ6IGhhbmRsZSBjb250ZW50IGNvZGluZ3NcblxuXHRcdFx0Ly8gaW4gZm9sbG93aW5nIHNjZW5hcmlvcyB3ZSBpZ25vcmUgY29tcHJlc3Npb24gc3VwcG9ydFxuXHRcdFx0Ly8gMS4gY29tcHJlc3Npb24gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXHRcdFx0Ly8gMi4gSEVBRCByZXF1ZXN0XG5cdFx0XHQvLyAzLiBubyBDb250ZW50LUVuY29kaW5nIGhlYWRlclxuXHRcdFx0Ly8gNC4gbm8gY29udGVudCByZXNwb25zZSAoMjA0KVxuXHRcdFx0Ly8gNS4gY29udGVudCBub3QgbW9kaWZpZWQgcmVzcG9uc2UgKDMwNClcblx0XHRcdGlmICghcmVxdWVzdC5jb21wcmVzcyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8IGNvZGluZ3MgPT09IG51bGwgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDIwNCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBOb2RlIHY2K1xuXHRcdFx0Ly8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcblx0XHRcdC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cblx0XHRcdC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuXHRcdFx0XHRmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcblx0XHRcdH07XG5cblx0XHRcdC8vIEZvciBnemlwXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2d6aXAnIHx8IGNvZGluZ3MgPT09ICd4LWd6aXAnKSB7XG5cdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgZGVmbGF0ZVxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdkZWZsYXRlJyB8fCBjb2RpbmdzID09PSAneC1kZWZsYXRlJykge1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGluZmFtb3VzIHJhdyBkZWZsYXRlIHJlc3BvbnNlIGZyb20gb2xkIHNlcnZlcnNcblx0XHRcdFx0Ly8gYSBoYWNrIGZvciBvbGQgSUlTIGFuZCBBcGFjaGUgc2VydmVyc1xuXHRcdFx0XHRjb25zdCByYXcgPSBwdW1wKHJlc3BvbnNlXywgbmV3IFBhc3NUaHJvdWdoKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZSgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHQvLyBTb21lIG9sZCBJSVMgc2VydmVycyByZXR1cm4gemVyby1sZW5ndGggT0sgZGVmbGF0ZSByZXNwb25zZXMsIHNvXG5cdFx0XHRcdFx0Ly8gJ2RhdGEnIGlzIG5ldmVyIGVtaXR0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL3B1bGwvOTAzXG5cdFx0XHRcdFx0aWYgKCFyZXNwb25zZSkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGJyXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2JyJykge1xuXHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIHVzZSByZXNwb25zZSBhcy1pc1xuXHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW5cblx0XHR3cml0ZVRvU3RyZWFtKHJlcXVlc3RfLCByZXF1ZXN0KS5jYXRjaChyZWplY3QpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdCwgZXJyb3JDYWxsYmFjaykge1xuXHRjb25zdCBMQVNUX0NIVU5LID0gQnVmZmVyLmZyb20oJzBcXHJcXG5cXHJcXG4nKTtcblxuXHRsZXQgaXNDaHVua2VkVHJhbnNmZXIgPSBmYWxzZTtcblx0bGV0IHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gZmFsc2U7XG5cdGxldCBwcmV2aW91c0NodW5rO1xuXG5cdHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgcmVzcG9uc2UgPT4ge1xuXHRcdGNvbnN0IHtoZWFkZXJzfSA9IHJlc3BvbnNlO1xuXHRcdGlzQ2h1bmtlZFRyYW5zZmVyID0gaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSA9PT0gJ2NodW5rZWQnICYmICFoZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuXHR9KTtcblxuXHRyZXF1ZXN0Lm9uKCdzb2NrZXQnLCBzb2NrZXQgPT4ge1xuXHRcdGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoKSA9PiB7XG5cdFx0XHRpZiAoaXNDaHVua2VkVHJhbnNmZXIgJiYgIXByb3Blckxhc3RDaHVua1JlY2VpdmVkKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQcmVtYXR1cmUgY2xvc2UnKTtcblx0XHRcdFx0ZXJyb3IuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBvbkRhdGEgPSBidWYgPT4ge1xuXHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBCdWZmZXIuY29tcGFyZShidWYuc2xpY2UoLTUpLCBMQVNUX0NIVU5LKSA9PT0gMDtcblxuXHRcdFx0Ly8gU29tZXRpbWVzIGZpbmFsIDAtbGVuZ3RoIGNodW5rIGFuZCBlbmQgb2YgbWVzc2FnZSBjb2RlIGFyZSBpbiBzZXBhcmF0ZSBwYWNrZXRzXG5cdFx0XHRpZiAoIXByb3Blckxhc3RDaHVua1JlY2VpdmVkICYmIHByZXZpb3VzQ2h1bmspIHtcblx0XHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSAoXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUocHJldmlvdXNDaHVuay5zbGljZSgtMyksIExBU1RfQ0hVTksuc2xpY2UoMCwgMykpID09PSAwICYmXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC0yKSwgTEFTVF9DSFVOSy5zbGljZSgzKSkgPT09IDBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXNDaHVuayA9IGJ1Zjtcblx0XHR9O1xuXG5cdFx0c29ja2V0LnByZXBlbmRMaXN0ZW5lcignY2xvc2UnLCBvblNvY2tldENsb3NlKTtcblx0XHRzb2NrZXQub24oJ2RhdGEnLCBvbkRhdGEpO1xuXG5cdFx0cmVxdWVzdC5vbignY2xvc2UnLCAoKSA9PiB7XG5cdFx0XHRzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0XHRzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuXHRcdH0pO1xuXHR9KTtcbn1cbiIsIi8qKlxuICogUmVxdWVzdC5qc1xuICpcbiAqIFJlcXVlc3QgY2xhc3MgY29udGFpbnMgc2VydmVyIG9ubHkgb3B0aW9uc1xuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxuaW1wb3J0IHtmb3JtYXQgYXMgZm9ybWF0VXJsfSBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQge2RlcHJlY2F0ZX0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGUsIGdldFRvdGFsQnl0ZXN9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzQWJvcnRTaWduYWx9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtnZXRTZWFyY2h9IGZyb20gJy4vdXRpbHMvZ2V0LXNlYXJjaC5qcyc7XG5pbXBvcnQge1xuXHR2YWxpZGF0ZVJlZmVycmVyUG9saWN5LCBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLCBERUZBVUxUX1JFRkVSUkVSX1BPTElDWVxufSBmcm9tICcuL3V0aWxzL3JlZmVycmVyLmpzJztcblxuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdSZXF1ZXN0IGludGVybmFscycpO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QuXG4gKlxuICogQHBhcmFtICB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1JlcXVlc3QgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdFtJTlRFUk5BTFNdID09PSAnb2JqZWN0J1xuXHQpO1xufTtcblxuY29uc3QgZG9CYWREYXRhV2FybiA9IGRlcHJlY2F0ZSgoKSA9PiB7fSxcblx0Jy5kYXRhIGlzIG5vdCBhIHZhbGlkIFJlcXVlc3RJbml0IHByb3BlcnR5LCB1c2UgLmJvZHkgaW5zdGVhZCcsXG5cdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXF1ZXN0KScpO1xuXG4vKipcbiAqIFJlcXVlc3QgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dCAgVXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIE9iamVjdCAgaW5pdCAgIEN1c3RvbSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3QgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoaW5wdXQsIGluaXQgPSB7fSkge1xuXHRcdGxldCBwYXJzZWRVUkw7XG5cblx0XHQvLyBOb3JtYWxpemUgaW5wdXQgYW5kIGZvcmNlIFVSTCB0byBiZSBlbmNvZGVkIGFzIFVURi04IChodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yNDUpXG5cdFx0aWYgKGlzUmVxdWVzdChpbnB1dCkpIHtcblx0XHRcdHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQudXJsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCk7XG5cdFx0XHRpbnB1dCA9IHt9O1xuXHRcdH1cblxuXHRcdGlmIChwYXJzZWRVUkwudXNlcm5hbWUgIT09ICcnIHx8IHBhcnNlZFVSTC5wYXNzd29yZCAhPT0gJycpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cGFyc2VkVVJMfSBpcyBhbiB1cmwgd2l0aCBlbWJlZGRlZCBjcmVkZW50aWFscy5gKTtcblx0XHR9XG5cblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgaW5wdXQubWV0aG9kIHx8ICdHRVQnO1xuXHRcdGlmICgvXihkZWxldGV8Z2V0fGhlYWR8b3B0aW9uc3xwb3N0fHB1dCkkL2kudGVzdChtZXRob2QpKSB7XG5cdFx0XHRtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cblx0XHRpZiAoIWlzUmVxdWVzdChpbml0KSAmJiAnZGF0YScgaW4gaW5pdCkge1xuXHRcdFx0ZG9CYWREYXRhV2FybigpO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoKGluaXQuYm9keSAhPSBudWxsIHx8IChpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwpKSAmJlxuXHRcdFx0KG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCcpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHknKTtcblx0XHR9XG5cblx0XHRjb25zdCBpbnB1dEJvZHkgPSBpbml0LmJvZHkgP1xuXHRcdFx0aW5pdC5ib2R5IDpcblx0XHRcdChpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwgP1xuXHRcdFx0XHRjbG9uZShpbnB1dCkgOlxuXHRcdFx0XHRudWxsKTtcblxuXHRcdHN1cGVyKGlucHV0Qm9keSwge1xuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IGlucHV0LnNpemUgfHwgMFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KTtcblxuXHRcdGlmIChpbnB1dEJvZHkgIT09IG51bGwgJiYgIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoaW5wdXRCb2R5LCB0aGlzKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBzaWduYWwgPSBpc1JlcXVlc3QoaW5wdXQpID9cblx0XHRcdGlucHV0LnNpZ25hbCA6XG5cdFx0XHRudWxsO1xuXHRcdGlmICgnc2lnbmFsJyBpbiBpbml0KSB7XG5cdFx0XHRzaWduYWwgPSBpbml0LnNpZ25hbDtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0aWYgKHNpZ25hbCAhPSBudWxsICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNpZ25hbCB0byBiZSBhbiBpbnN0YW5jZW9mIEFib3J0U2lnbmFsIG9yIEV2ZW50VGFyZ2V0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTUuMVxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRsZXQgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyID09IG51bGwgPyBpbnB1dC5yZWZlcnJlciA6IGluaXQucmVmZXJyZXI7XG5cdFx0aWYgKHJlZmVycmVyID09PSAnJykge1xuXHRcdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTUuMlxuXHRcdFx0cmVmZXJyZXIgPSAnbm8tcmVmZXJyZXInO1xuXHRcdH0gZWxzZSBpZiAocmVmZXJyZXIpIHtcblx0XHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjMuMSwgMTUuMy4yXG5cdFx0XHRjb25zdCBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIpO1xuXHRcdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTUuMy4zLCAxNS4zLjRcblx0XHRcdHJlZmVycmVyID0gL15hYm91dDooXFwvXFwvKT9jbGllbnQkLy50ZXN0KHBhcnNlZFJlZmVycmVyKSA/ICdjbGllbnQnIDogcGFyc2VkUmVmZXJyZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlZmVycmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0IHx8IGlucHV0LnJlZGlyZWN0IHx8ICdmb2xsb3cnLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHBhcnNlZFVSTCxcblx0XHRcdHNpZ25hbCxcblx0XHRcdHJlZmVycmVyXG5cdFx0fTtcblxuXHRcdC8vIE5vZGUtZmV0Y2gtb25seSBvcHRpb25zXG5cdFx0dGhpcy5mb2xsb3cgPSBpbml0LmZvbGxvdyA9PT0gdW5kZWZpbmVkID8gKGlucHV0LmZvbGxvdyA9PT0gdW5kZWZpbmVkID8gMjAgOiBpbnB1dC5mb2xsb3cpIDogaW5pdC5mb2xsb3c7XG5cdFx0dGhpcy5jb21wcmVzcyA9IGluaXQuY29tcHJlc3MgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5jb21wcmVzcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlucHV0LmNvbXByZXNzKSA6IGluaXQuY29tcHJlc3M7XG5cdFx0dGhpcy5jb3VudGVyID0gaW5pdC5jb3VudGVyIHx8IGlucHV0LmNvdW50ZXIgfHwgMDtcblx0XHR0aGlzLmFnZW50ID0gaW5pdC5hZ2VudCB8fCBpbnB1dC5hZ2VudDtcblx0XHR0aGlzLmhpZ2hXYXRlck1hcmsgPSBpbml0LmhpZ2hXYXRlck1hcmsgfHwgaW5wdXQuaGlnaFdhdGVyTWFyayB8fCAxNjM4NDtcblx0XHR0aGlzLmluc2VjdXJlSFRUUFBhcnNlciA9IGluaXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGlucHV0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBmYWxzZTtcblxuXHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE2LlxuXHRcdC8vIERlZmF1bHQgaXMgZW1wdHkgc3RyaW5nIHBlciBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LXJlZmVycmVyLXBvbGljeVxuXHRcdHRoaXMucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5IHx8IGlucHV0LnJlZmVycmVyUG9saWN5IHx8ICcnO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5cdGdldCBtZXRob2QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5tZXRob2Q7XG5cdH1cblxuXHQvKiogQHJldHVybnMge3N0cmluZ30gKi9cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gZm9ybWF0VXJsKHRoaXNbSU5URVJOQUxTXS5wYXJzZWRVUkwpO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtIZWFkZXJzfSAqL1xuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWRpcmVjdDtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7QWJvcnRTaWduYWx9ICovXG5cdGdldCBzaWduYWwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zaWduYWw7XG5cdH1cblxuXHQvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QtcmVmZXJyZXJcblx0Z2V0IHJlZmVycmVyKCkge1xuXHRcdGlmICh0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIgPT09ICduby1yZWZlcnJlcicpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyID09PSAnY2xpZW50Jykge1xuXHRcdFx0cmV0dXJuICdhYm91dDpjbGllbnQnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIpIHtcblx0XHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Z2V0IHJlZmVycmVyUG9saWN5KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXJQb2xpY3k7XG5cdH1cblxuXHRzZXQgcmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpIHtcblx0XHR0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXJQb2xpY3kgPSB2YWxpZGF0ZVJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlcXVlc3Rcblx0ICpcblx0ICogQHJldHVybiAgUmVxdWVzdFxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiAnUmVxdWVzdCc7XG5cdH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcblx0bWV0aG9kOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHVybDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0OiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHNpZ25hbDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWZlcnJlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWZlcnJlclBvbGljeToge2VudW1lcmFibGU6IHRydWV9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgUmVxdWVzdCB0byBOb2RlLmpzIGh0dHAgcmVxdWVzdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdCAtIEEgUmVxdWVzdCBpbnN0YW5jZVxuICogQHJldHVybiBUaGUgb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIGh0dHAucmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgZ2V0Tm9kZVJlcXVlc3RPcHRpb25zID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtwYXJzZWRVUkx9ID0gcmVxdWVzdFtJTlRFUk5BTFNdO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVxdWVzdFtJTlRFUk5BTFNdLmhlYWRlcnMpO1xuXG5cdC8vIEZldGNoIHN0ZXAgMS4zXG5cdGlmICghaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdCcsICcqLyonKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwcyAyLjQtMi43XG5cdGxldCBjb250ZW50TGVuZ3RoVmFsdWUgPSBudWxsO1xuXHRpZiAocmVxdWVzdC5ib2R5ID09PSBudWxsICYmIC9eKHBvc3R8cHV0KSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuXHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9ICcwJztcblx0fVxuXG5cdGlmIChyZXF1ZXN0LmJvZHkgIT09IG51bGwpIHtcblx0XHRjb25zdCB0b3RhbEJ5dGVzID0gZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KTtcblx0XHQvLyBTZXQgQ29udGVudC1MZW5ndGggaWYgdG90YWxCeXRlcyBpcyBhIG51bWJlciAodGhhdCBpcyBub3QgTmFOKVxuXHRcdGlmICh0eXBlb2YgdG90YWxCeXRlcyA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc05hTih0b3RhbEJ5dGVzKSkge1xuXHRcdFx0Y29udGVudExlbmd0aFZhbHVlID0gU3RyaW5nKHRvdGFsQnl0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb250ZW50TGVuZ3RoVmFsdWUpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1MZW5ndGgnLCBjb250ZW50TGVuZ3RoVmFsdWUpO1xuXHR9XG5cblx0Ly8gNC4xLiBNYWluIGZldGNoLCBzdGVwIDIuNlxuXHQvLyA+IElmIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeSB0byB0aGVcblx0Ly8gPiBkZWZhdWx0IHJlZmVycmVyIHBvbGljeS5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG5cdFx0cmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZO1xuXHR9XG5cblx0Ly8gNC4xLiBNYWluIGZldGNoLCBzdGVwIDIuN1xuXHQvLyA+IElmIHJlcXVlc3QncyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCBzZXQgcmVxdWVzdCdzIHJlZmVycmVyIHRvIHRoZSByZXN1bHQgb2YgaW52b2tpbmdcblx0Ly8gPiBkZXRlcm1pbmUgcmVxdWVzdCdzIHJlZmVycmVyLlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciAmJiByZXF1ZXN0LnJlZmVycmVyICE9PSAnbm8tcmVmZXJyZXInKSB7XG5cdFx0cmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KTtcblx0fSBlbHNlIHtcblx0XHRyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgPSAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0Ly8gNC41LiBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2gsIHN0ZXAgNi45XG5cdC8vID4gSWYgaHR0cFJlcXVlc3QncyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmQgYFJlZmVyZXJgL2h0dHBSZXF1ZXN0J3MgcmVmZXJyZXIsIHNlcmlhbGl6ZWRcblx0Ly8gPiAgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCwgdG8gaHR0cFJlcXVlc3QncyBoZWFkZXIgbGlzdC5cblx0aWYgKHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCkge1xuXHRcdGhlYWRlcnMuc2V0KCdSZWZlcmVyJywgcmVxdWVzdC5yZWZlcnJlcik7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjExXG5cdGlmICghaGVhZGVycy5oYXMoJ1VzZXItQWdlbnQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ25vZGUtZmV0Y2gnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTVcblx0aWYgKHJlcXVlc3QuY29tcHJlc3MgJiYgIWhlYWRlcnMuaGFzKCdBY2NlcHQtRW5jb2RpbmcnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQtRW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZSwgYnInKTtcblx0fVxuXG5cdGxldCB7YWdlbnR9ID0gcmVxdWVzdDtcblx0aWYgKHR5cGVvZiBhZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDQuMlxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xuXG5cdGNvbnN0IHNlYXJjaCA9IGdldFNlYXJjaChwYXJzZWRVUkwpO1xuXG5cdC8vIFBhc3MgdGhlIGZ1bGwgVVJMIGRpcmVjdGx5IHRvIHJlcXVlc3QoKSwgYnV0IG92ZXJ3cml0ZSB0aGUgZm9sbG93aW5nXG5cdC8vIG9wdGlvbnM6XG5cdGNvbnN0IG9wdGlvbnMgPSB7XG5cdFx0Ly8gT3ZlcndyaXRlIHNlYXJjaCB0byByZXRhaW4gdHJhaWxpbmcgPyAoaXNzdWUgIzc3Nilcblx0XHRwYXRoOiBwYXJzZWRVUkwucGF0aG5hbWUgKyBzZWFyY2gsXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBub3QgZXhwcmVzc2VkIGluIHRoZSBVUkxcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdGhlYWRlcnM6IGhlYWRlcnNbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSxcblx0XHRpbnNlY3VyZUhUVFBQYXJzZXI6IHJlcXVlc3QuaW5zZWN1cmVIVFRQUGFyc2VyLFxuXHRcdGFnZW50XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHQvKiogQHR5cGUge1VSTH0gKi9cblx0XHRwYXJzZWRVUkwsXG5cdFx0b3B0aW9uc1xuXHR9O1xufTtcbiIsIi8qKlxuICogUmVzcG9uc2UuanNcbiAqXG4gKiBSZXNwb25zZSBjbGFzcyBwcm92aWRlcyBjb250ZW50IGRlY29kaW5nXG4gKi9cblxuaW1wb3J0IEhlYWRlcnMgZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCBCb2R5LCB7Y2xvbmUsIGV4dHJhY3RDb250ZW50VHlwZX0gZnJvbSAnLi9ib2R5LmpzJztcbmltcG9ydCB7aXNSZWRpcmVjdH0gZnJvbSAnLi91dGlscy9pcy1yZWRpcmVjdC5qcyc7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKGJvZHksIG9wdGlvbnMpO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcSwgbm8tbmVnYXRlZC1jb25kaXRpb25cblx0XHRjb25zdCBzdGF0dXMgPSBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0dHlwZTogJ2RlZmF1bHQnLFxuXHRcdFx0dXJsOiBvcHRpb25zLnVybCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IG9wdGlvbnMuc3RhdHVzVGV4dCB8fCAnJyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRjb3VudGVyOiBvcHRpb25zLmNvdW50ZXIsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmtcblx0XHR9O1xuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS50eXBlO1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnVybCB8fCAnJztcblx0fVxuXG5cdGdldCBzdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgcHJvcGVydHkgcmVwcmVzZW50aW5nIGlmIHRoZSByZXF1ZXN0IGVuZGVkIG5vcm1hbGx5XG5cdCAqL1xuXHRnZXQgb2soKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNbSU5URVJOQUxTXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNvdW50ZXIgPiAwO1xuXHR9XG5cblx0Z2V0IHN0YXR1c1RleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdGF0dXNUZXh0O1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oaWdoV2F0ZXJNYXJrO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoaXMgcmVzcG9uc2Vcblx0ICpcblx0ICogQHJldHVybiAgUmVzcG9uc2Vcblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoY2xvbmUodGhpcywgdGhpcy5oaWdoV2F0ZXJNYXJrKSwge1xuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRvazogdGhpcy5vayxcblx0XHRcdHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcblx0XHRcdHNpemU6IHRoaXMuc2l6ZSxcblx0XHRcdGhpZ2hXYXRlck1hcms6IHRoaXMuaGlnaFdhdGVyTWFya1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgVGhlIFVSTCB0aGF0IHRoZSBuZXcgcmVzcG9uc2UgaXMgdG8gb3JpZ2luYXRlIGZyb20uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgZm9yIHRoZSByZXNwb25zZSAoZS5nLiwgMzAyLilcblx0ICogQHJldHVybnMge1Jlc3BvbnNlfSAgICBBIFJlc3BvbnNlIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyByZWRpcmVjdCh1cmwsIHN0YXR1cyA9IDMwMikge1xuXHRcdGlmICghaXNSZWRpcmVjdChzdGF0dXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXCJyZWRpcmVjdFwiIG9uIFwicmVzcG9uc2VcIjogSW52YWxpZCBzdGF0dXMgY29kZScpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRsb2NhdGlvbjogbmV3IFVSTCh1cmwpLnRvU3RyaW5nKClcblx0XHRcdH0sXG5cdFx0XHRzdGF0dXNcblx0XHR9KTtcblx0fVxuXG5cdHN0YXRpYyBlcnJvcigpIHtcblx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuXHRcdHJlc3BvbnNlW0lOVEVSTkFMU10udHlwZSA9ICdlcnJvcic7XG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9XG5cblx0c3RhdGljIGpzb24oZGF0YSA9IHVuZGVmaW5lZCwgaW5pdCA9IHt9KSB7XG5cdFx0Y29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG5cdFx0aWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKTtcblx0XHR9XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCAmJiBpbml0LmhlYWRlcnMpO1xuXG5cdFx0aWYgKCFoZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcblx0XHRcdGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdFx0Li4uaW5pdCxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1Jlc3BvbnNlJztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcblx0dHlwZToge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdG9rOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0ZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzVGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuIiwiZXhwb3J0IGNvbnN0IGdldFNlYXJjaCA9IHBhcnNlZFVSTCA9PiB7XG5cdGlmIChwYXJzZWRVUkwuc2VhcmNoKSB7XG5cdFx0cmV0dXJuIHBhcnNlZFVSTC5zZWFyY2g7XG5cdH1cblxuXHRjb25zdCBsYXN0T2Zmc2V0ID0gcGFyc2VkVVJMLmhyZWYubGVuZ3RoIC0gMTtcblx0Y29uc3QgaGFzaCA9IHBhcnNlZFVSTC5oYXNoIHx8IChwYXJzZWRVUkwuaHJlZltsYXN0T2Zmc2V0XSA9PT0gJyMnID8gJyMnIDogJycpO1xuXHRyZXR1cm4gcGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldCAtIGhhc2gubGVuZ3RoXSA9PT0gJz8nID8gJz8nIDogJyc7XG59O1xuIiwiY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuXG4vKipcbiAqIFJlZGlyZWN0IGNvZGUgbWF0Y2hpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNSZWRpcmVjdCA9IGNvZGUgPT4ge1xuXHRyZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKGNvZGUpO1xufTtcbiIsIi8qKlxuICogSXMuanNcbiAqXG4gKiBPYmplY3QgdHlwZSBjaGVja3MuXG4gKi9cblxuY29uc3QgTkFNRSA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMjk2I2lzc3VlY29tbWVudC0zMDc1OTgxNDNcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVVJMU2VhcmNoUGFyYW1ldGVycyA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZGVsZXRlID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXQgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuaGFzID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zZXQgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNvcnQgPT09ICdmdW5jdGlvbicgJiZcblx0XHRvYmplY3RbTkFNRV0gPT09ICdVUkxTZWFyY2hQYXJhbXMnXG5cdCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmplY3RgIGlzIGEgVzNDIGBCbG9iYCBvYmplY3QgKHdoaWNoIGBGaWxlYCBpbmhlcml0cyBmcm9tKVxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNCbG9iID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHRvYmplY3QgJiZcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnR5cGUgPT09ICdzdHJpbmcnICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG5cdFx0L14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W05BTUVdKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQWJvcnRTaWduYWwgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIChcblx0XHRcdG9iamVjdFtOQU1FXSA9PT0gJ0Fib3J0U2lnbmFsJyB8fFxuXHRcdFx0b2JqZWN0W05BTUVdID09PSAnRXZlbnRUYXJnZXQnXG5cdFx0KVxuXHQpO1xufTtcblxuLyoqXG4gKiBpc0RvbWFpbk9yU3ViZG9tYWluIHJlcG9ydHMgd2hldGhlciBzdWIgaXMgYSBzdWJkb21haW4gKG9yIGV4YWN0IG1hdGNoKSBvZlxuICogdGhlIHBhcmVudCBkb21haW4uXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRG9tYWluT3JTdWJkb21haW4gPSAoZGVzdGluYXRpb24sIG9yaWdpbmFsKSA9PiB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5ob3N0bmFtZTtcblx0Y29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLmhvc3RuYW1lO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0IHx8IG9yaWcuZW5kc1dpdGgoYC4ke2Rlc3R9YCk7XG59O1xuXG4vKipcbiAqIGlzU2FtZVByb3RvY29sIHJlcG9ydHMgd2hldGhlciB0aGUgdHdvIHByb3ZpZGVkIFVSTHMgdXNlIHRoZSBzYW1lIHByb3RvY29sLlxuICpcbiAqIEJvdGggZG9tYWlucyBtdXN0IGFscmVhZHkgYmUgaW4gY2Fub25pY2FsIGZvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IG9yaWdpbmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IGRlc3RpbmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc1NhbWVQcm90b2NvbCA9IChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpID0+IHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwob3JpZ2luYWwpLnByb3RvY29sO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTChkZXN0aW5hdGlvbikucHJvdG9jb2w7XG5cblx0cmV0dXJuIG9yaWcgPT09IGRlc3Q7XG59O1xuIiwiaW1wb3J0IHtpc0lQfSBmcm9tICdub2RlOm5ldCc7XG5cbi8qKlxuICogQGV4dGVybmFsIFVSTFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTHxVUkx9XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHV0aWxzL3JlZmVycmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3N0cmlwLXVybHxSZWZlcnJlciBQb2xpY3kgwqc4LjQuIFN0cmlwIHVybCBmb3IgdXNlIGFzIGEgcmVmZXJyZXJ9XG4gKiBAcGFyYW0ge3N0cmluZ30gVVJMXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmlnaW5Pbmx5PWZhbHNlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcih1cmwsIG9yaWdpbk9ubHkgPSBmYWxzZSkge1xuXHQvLyAxLiBJZiB1cmwgaXMgbnVsbCwgcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRpZiAodXJsID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdHVybCA9IG5ldyBVUkwodXJsKTtcblxuXHQvLyAyLiBJZiB1cmwncyBzY2hlbWUgaXMgYSBsb2NhbCBzY2hlbWUsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRpZiAoL14oYWJvdXR8YmxvYnxkYXRhKTokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIDMuIFNldCB1cmwncyB1c2VybmFtZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuXHR1cmwudXNlcm5hbWUgPSAnJztcblxuXHQvLyA0LiBTZXQgdXJsJ3MgcGFzc3dvcmQgdG8gbnVsbC5cblx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcGFzc3dvcmQgYmVpbmcgYFwibnVsbFwiYC5cblx0dXJsLnBhc3N3b3JkID0gJyc7XG5cblx0Ly8gNS4gU2V0IHVybCdzIGZyYWdtZW50IHRvIG51bGwuXG5cdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIGZyYWdtZW50IGJlaW5nIGBcIiNudWxsXCJgLlxuXHR1cmwuaGFzaCA9ICcnO1xuXG5cdC8vIDYuIElmIHRoZSBvcmlnaW4tb25seSBmbGFnIGlzIHRydWUsIHRoZW46XG5cdGlmIChvcmlnaW5Pbmx5KSB7XG5cdFx0Ly8gNi4xLiBTZXQgdXJsJ3MgcGF0aCB0byBudWxsLlxuXHRcdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHBhdGggYmVpbmcgYFwiL251bGxcImAuXG5cdFx0dXJsLnBhdGhuYW1lID0gJyc7XG5cblx0XHQvLyA2LjIuIFNldCB1cmwncyBxdWVyeSB0byBudWxsLlxuXHRcdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHF1ZXJ5IGJlaW5nIGBcIj9udWxsXCJgLlxuXHRcdHVybC5zZWFyY2ggPSAnJztcblx0fVxuXG5cdC8vIDcuIFJldHVybiB1cmwuXG5cdHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2VudW1kZWYtcmVmZXJyZXJwb2xpY3l8ZW51bSBSZWZlcnJlclBvbGljeX1cbiAqL1xuZXhwb3J0IGNvbnN0IFJlZmVycmVyUG9saWN5ID0gbmV3IFNldChbXG5cdCcnLFxuXHQnbm8tcmVmZXJyZXInLFxuXHQnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuXHQnc2FtZS1vcmlnaW4nLFxuXHQnb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4nLFxuXHQnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuXHQndW5zYWZlLXVybCdcbl0pO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZWZhdWx0LXJlZmVycmVyLXBvbGljeXxkZWZhdWx0IHJlZmVycmVyIHBvbGljeX1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZID0gJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc3xSZWZlcnJlciBQb2xpY3kgwqczLiBSZWZlcnJlciBQb2xpY2llc31cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWZlcnJlclBvbGljeVxuICogQHJldHVybnMge3N0cmluZ30gcmVmZXJyZXJQb2xpY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpIHtcblx0aWYgKCFSZWZlcnJlclBvbGljeS5oYXMocmVmZXJyZXJQb2xpY3kpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWZlcnJlclBvbGljeTogJHtyZWZlcnJlclBvbGljeX1gKTtcblx0fVxuXG5cdHJldHVybiByZWZlcnJlclBvbGljeTtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXNlY3VyZS1jb250ZXh0cy8jaXMtb3JpZ2luLXRydXN0d29ydGh5fFJlZmVycmVyIFBvbGljeSDCpzMuMi4gSXMgb3JpZ2luIHBvdGVudGlhbGx5IHRydXN0d29ydGh5P31cbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSB1cmxcbiAqIEByZXR1cm5zIGB0cnVlYDogXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLCBgZmFsc2VgOiBcIk5vdCBUcnVzdHdvcnRoeVwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsKSB7XG5cdC8vIDEuIElmIG9yaWdpbiBpcyBhbiBvcGFxdWUgb3JpZ2luLCByZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IGFwcGxpY2FibGVcblxuXHQvLyAyLiBBc3NlcnQ6IG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbi5cblx0Ly8gTm90IGZvciBpbXBsZW1lbnRhdGlvbnNcblxuXHQvLyAzLiBJZiBvcmlnaW4ncyBzY2hlbWUgaXMgZWl0aGVyIFwiaHR0cHNcIiBvciBcIndzc1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL14oaHR0cHx3cylzOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNC4gSWYgb3JpZ2luJ3MgaG9zdCBjb21wb25lbnQgbWF0Y2hlcyBvbmUgb2YgdGhlIENJRFIgbm90YXRpb25zIDEyNy4wLjAuMC84IG9yIDo6MS8xMjggW1JGQzQ2MzJdLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRjb25zdCBob3N0SXAgPSB1cmwuaG9zdC5yZXBsYWNlKC8oXlxcWyl8KF0kKS9nLCAnJyk7XG5cdGNvbnN0IGhvc3RJUFZlcnNpb24gPSBpc0lQKGhvc3RJcCk7XG5cblx0aWYgKGhvc3RJUFZlcnNpb24gPT09IDQgJiYgL14xMjdcXC4vLnRlc3QoaG9zdElwKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGhvc3RJUFZlcnNpb24gPT09IDYgJiYgL14oKCgwKzopezd9KXwoOjooMCs6KXswLDZ9KSkwKjEkLy50ZXN0KGhvc3RJcCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDUuIElmIG9yaWdpbidzIGhvc3QgY29tcG9uZW50IGlzIFwibG9jYWxob3N0XCIgb3IgZmFsbHMgd2l0aGluIFwiLmxvY2FsaG9zdFwiLCBhbmQgdGhlIHVzZXIgYWdlbnQgY29uZm9ybXMgdG8gdGhlIG5hbWUgcmVzb2x1dGlvbiBydWxlcyBpbiBbbGV0LWxvY2FsaG9zdC1iZS1sb2NhbGhvc3RdLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBXZSBhcmUgcmV0dXJuaW5nIEZBTFNFIGhlcmUgYmVjYXVzZSB3ZSBjYW5ub3QgZW5zdXJlIGNvbmZvcm1hbmNlIHRvXG5cdC8vIGxldC1sb2NhbGhvc3QtYmUtbG9hbGhvc3QgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC13ZXN0LWxldC1sb2NhbGhvc3QtYmUtbG9jYWxob3N0KVxuXHRpZiAodXJsLmhvc3QgPT09ICdsb2NhbGhvc3QnIHx8IHVybC5ob3N0LmVuZHNXaXRoKCcubG9jYWxob3N0JykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyA2LiBJZiBvcmlnaW4ncyBzY2hlbWUgY29tcG9uZW50IGlzIGZpbGUsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDcuIElmIG9yaWdpbidzIHNjaGVtZSBjb21wb25lbnQgaXMgb25lIHdoaWNoIHRoZSB1c2VyIGFnZW50IGNvbnNpZGVycyB0byBiZSBhdXRoZW50aWNhdGVkLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3Qgc3VwcG9ydGVkXG5cblx0Ly8gOC4gSWYgb3JpZ2luIGhhcyBiZWVuIGNvbmZpZ3VyZWQgYXMgYSB0cnVzdHdvcnRoeSBvcmlnaW4sIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBzdXBwb3J0ZWRcblxuXHQvLyA5LiBSZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy11cmwtdHJ1c3R3b3J0aHl8UmVmZXJyZXIgUG9saWN5IMKnMy4zLiBJcyB1cmwgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIFwiYWJvdXQ6YmxhbmtcIiBvciBcImFib3V0OnNyY2RvY1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL15hYm91dDooYmxhbmt8c3JjZG9jKSQvLnRlc3QodXJsKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIFwiZGF0YVwiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IGFuZCBmaWxlc3lzdGVtOiBVUkxzIGlzIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgaW4gd2hpY2ggdGhleSB3ZXJlXG5cdC8vIGNyZWF0ZWQuIFRoZXJlZm9yZSwgYmxvYnMgY3JlYXRlZCBpbiBhIHRydXN0d29ydGh5IG9yaWdpbiB3aWxsIHRoZW1zZWx2ZXMgYmUgcG90ZW50aWFsbHlcblx0Ly8gdHJ1c3R3b3J0aHkuXG5cdGlmICgvXihibG9ifGZpbGVzeXN0ZW0pOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnMy4yIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT8gb24gdXJsJ3Mgb3JpZ2luLlxuXHRyZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHJlZmVycmVyVVJMIHRvIGVuZm9yY2UgYW55IGV4dHJhIHNlY3VyaXR5IHBvbGljeSBjb25zaWRlcmF0aW9ucy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4zLiBEZXRlcm1pbmUgcmVxdWVzdCdzIFJlZmVycmVyfSwgc3RlcCA3XG4gKiBAY2FsbGJhY2sgbW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSByZWZlcnJlclVSTFxuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gbW9kaWZpZWQgcmVmZXJyZXJVUkxcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSByZWZlcnJlck9yaWdpbiB0byBlbmZvcmNlIGFueSBleHRyYSBzZWN1cml0eSBwb2xpY3kgY29uc2lkZXJhdGlvbnMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn0sIHN0ZXAgN1xuICogQGNhbGxiYWNrIG1vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gcmVmZXJyZXJPcmlnaW5cbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IG1vZGlmaWVkIHJlZmVycmVyT3JpZ2luXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn1cbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2t9IG8ucmVmZXJyZXJVUkxDYWxsYmFja1xuICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJPcmlnaW5DYWxsYmFja30gby5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBSZXF1ZXN0J3MgcmVmZXJyZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdCwge3JlZmVycmVyVVJMQ2FsbGJhY2ssIHJlZmVycmVyT3JpZ2luQ2FsbGJhY2t9ID0ge30pIHtcblx0Ly8gVGhlcmUgYXJlIDIgbm90ZXMgaW4gdGhlIHNwZWNpZmljYXRpb24gYWJvdXQgaW52YWxpZCBwcmUtY29uZGl0aW9ucy4gIFdlIHJldHVybiBudWxsLCBoZXJlLCBmb3Jcblx0Ly8gdGhlc2UgY2FzZXM6XG5cdC8vID4gTm90ZTogSWYgcmVxdWVzdCdzIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgRmV0Y2ggd2lsbCBub3QgY2FsbCBpbnRvIHRoaXMgYWxnb3JpdGhtLlxuXHQvLyA+IE5vdGU6IElmIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgRmV0Y2ggd2lsbCBub3QgY2FsbCBpbnRvIHRoaXNcblx0Ly8gPiBhbGdvcml0aG0uXG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyID09PSAnbm8tcmVmZXJyZXInIHx8IHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyAxLiBMZXQgcG9saWN5IGJlIHJlcXVlc3QncyBhc3NvY2lhdGVkIHJlZmVycmVyIHBvbGljeS5cblx0Y29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeTtcblxuXHQvLyAyLiBMZXQgZW52aXJvbm1lbnQgYmUgcmVxdWVzdCdzIGNsaWVudC5cblx0Ly8gbm90IGFwcGxpY2FibGUgdG8gbm9kZS5qc1xuXG5cdC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN0J3MgcmVmZXJyZXI6XG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyID09PSAnYWJvdXQ6Y2xpZW50Jykge1xuXHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0Ly8gXCJhIFVSTFwiOiBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdCdzIHJlZmVycmVyLlxuXHRjb25zdCByZWZlcnJlclNvdXJjZSA9IHJlcXVlc3QucmVmZXJyZXI7XG5cblx0Ly8gNC4gTGV0IHJlcXVlc3QncyByZWZlcnJlclVSTCBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzIGEgcmVmZXJyZXIuXG5cdGxldCByZWZlcnJlclVSTCA9IHN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UpO1xuXG5cdC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzIGEgcmVmZXJyZXIsIHdpdGggdGhlXG5cdC8vICAgIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG5cdGxldCByZWZlcnJlck9yaWdpbiA9IHN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpO1xuXG5cdC8vIDYuIElmIHRoZSByZXN1bHQgb2Ygc2VyaWFsaXppbmcgcmVmZXJyZXJVUkwgaXMgYSBzdHJpbmcgd2hvc2UgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiA0MDk2LCBzZXRcblx0Ly8gICAgcmVmZXJyZXJVUkwgdG8gcmVmZXJyZXJPcmlnaW4uXG5cdGlmIChyZWZlcnJlclVSTC50b1N0cmluZygpLmxlbmd0aCA+IDQwOTYpIHtcblx0XHRyZWZlcnJlclVSTCA9IHJlZmVycmVyT3JpZ2luO1xuXHR9XG5cblx0Ly8gNy4gVGhlIHVzZXIgYWdlbnQgTUFZIGFsdGVyIHJlZmVycmVyVVJMIG9yIHJlZmVycmVyT3JpZ2luIGF0IHRoaXMgcG9pbnQgdG8gZW5mb3JjZSBhcmJpdHJhcnlcblx0Ly8gICAgcG9saWN5IGNvbnNpZGVyYXRpb25zIGluIHRoZSBpbnRlcmVzdHMgb2YgbWluaW1pemluZyBkYXRhIGxlYWthZ2UuIEZvciBleGFtcGxlLCB0aGUgdXNlclxuXHQvLyAgICBhZ2VudCBjb3VsZCBzdHJpcCB0aGUgVVJMIGRvd24gdG8gYW4gb3JpZ2luLCBtb2RpZnkgaXRzIGhvc3QsIHJlcGxhY2UgaXQgd2l0aCBhbiBlbXB0eVxuXHQvLyAgICBzdHJpbmcsIGV0Yy5cblx0aWYgKHJlZmVycmVyVVJMQ2FsbGJhY2spIHtcblx0XHRyZWZlcnJlclVSTCA9IHJlZmVycmVyVVJMQ2FsbGJhY2socmVmZXJyZXJVUkwpO1xuXHR9XG5cblx0aWYgKHJlZmVycmVyT3JpZ2luQ2FsbGJhY2spIHtcblx0XHRyZWZlcnJlck9yaWdpbiA9IHJlZmVycmVyT3JpZ2luQ2FsbGJhY2socmVmZXJyZXJPcmlnaW4pO1xuXHR9XG5cblx0Ly8gOC5FeGVjdXRlIHRoZSBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcblx0Y29uc3QgY3VycmVudFVSTCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuXG5cdHN3aXRjaCAocG9saWN5KSB7XG5cdFx0Y2FzZSAnbm8tcmVmZXJyZXInOlxuXHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cblx0XHRjYXNlICdvcmlnaW4nOlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAndW5zYWZlLXVybCc6XG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cblx0XHRjYXNlICdzdHJpY3Qtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN0J3MgY3VycmVudCBVUkwgaXMgbm90IGFcblx0XHRcdC8vICAgIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdFx0XHRpZiAoaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG5cdFx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW4udG9TdHJpbmcoKTtcblxuXHRcdGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN0J3MgY3VycmVudCBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuXG5cdFx0XHQvLyAgICByZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN0J3MgY3VycmVudCBVUkwgaXMgbm90IGFcblx0XHRcdC8vICAgIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdFx0XHRpZiAoaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG5cdFx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICdzYW1lLW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3QncyBjdXJyZW50IFVSTCBhcmUgdGhlIHNhbWUsIHRoZW5cblx0XHRcdC8vICAgIHJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdGlmIChyZWZlcnJlclVSTC5vcmlnaW4gPT09IGN1cnJlbnRVUkwub3JpZ2luKSB7XG5cdFx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cblx0XHRjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN0J3MgY3VycmVudCBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuXG5cdFx0XHQvLyAgICByZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiByZWZlcnJlck9yaWdpbi5cblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzpcblx0XHRcdC8vIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN0J3MgY3VycmVudCBVUkwgaXMgbm90IGFcblx0XHRcdC8vICAgIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdFx0XHRpZiAoaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG5cdFx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBSZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWZlcnJlclBvbGljeTogJHtwb2xpY3l9YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcGFyc2UtcmVmZXJyZXItcG9saWN5LWZyb20taGVhZGVyfFJlZmVycmVyIFBvbGljeSDCpzguMS4gUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJ9XG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnMgUmVzcG9uc2UgaGVhZGVyc1xuICogQHJldHVybnMge3N0cmluZ30gcG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcihoZWFkZXJzKSB7XG5cdC8vIDEuIExldCBwb2xpY3ktdG9rZW5zIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFJlZmVycmVyLVBvbGljeWBcblx0Ly8gICAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cblx0Y29uc3QgcG9saWN5VG9rZW5zID0gKGhlYWRlcnMuZ2V0KCdyZWZlcnJlci1wb2xpY3knKSB8fCAnJykuc3BsaXQoL1ssXFxzXSsvKTtcblxuXHQvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdGxldCBwb2xpY3kgPSAnJztcblxuXHQvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eVxuXHQvLyAgICBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cblx0Ly8gTm90ZTogVGhpcyBhbGdvcml0aG0gbG9vcHMgb3ZlciBtdWx0aXBsZSBwb2xpY3kgdmFsdWVzIHRvIGFsbG93IGRlcGxveW1lbnQgb2YgbmV3IHBvbGljeVxuXHQvLyB2YWx1ZXMgd2l0aCBmYWxsYmFja3MgZm9yIG9sZGVyIHVzZXIgYWdlbnRzLCBhcyBkZXNjcmliZWQgaW4gwqcgMTEuMSBVbmtub3duIFBvbGljeSBWYWx1ZXMuXG5cdGZvciAoY29uc3QgdG9rZW4gb2YgcG9saWN5VG9rZW5zKSB7XG5cdFx0aWYgKHRva2VuICYmIFJlZmVycmVyUG9saWN5Lmhhcyh0b2tlbikpIHtcblx0XHRcdHBvbGljeSA9IHRva2VuO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQuIFJldHVybiBwb2xpY3kuXG5cdHJldHVybiBwb2xpY3k7XG59XG4iXSwibmFtZXMiOlsiQWJvcnRTaWduYWwiLCJldmVudFRhcmdldFNoaW0iLCJFdmVudFRhcmdldCIsImNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiYWJvcnRlZCIsImFib3J0ZWRGbGFncyIsImdldCIsImRlZmluZUV2ZW50QXR0cmlidXRlIiwicHJvdG90eXBlIiwiY3JlYXRlQWJvcnRTaWduYWwiLCJzaWduYWwiLCJPYmplY3QiLCJjcmVhdGUiLCJjYWxsIiwic2V0IiwiYWJvcnRTaWduYWwiLCJkaXNwYXRjaEV2ZW50IiwidHlwZSIsIldlYWtNYXAiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bWVyYWJsZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ2YWx1ZSIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbHMiLCJnZXRTaWduYWwiLCJhYm9ydCIsImNvbnRyb2xsZXIiLCJwcml2YXRlRGF0YSIsIndyYXBwZXJzIiwicGQiLCJldmVudCIsInJldHYiLCJjb25zb2xlIiwiYXNzZXJ0Iiwic2V0Q2FuY2VsRmxhZyIsImRhdGEiLCJwYXNzaXZlTGlzdGVuZXIiLCJlcnJvciIsImNhbmNlbGFibGUiLCJjYW5jZWxlZCIsInByZXZlbnREZWZhdWx0IiwiRXZlbnQiLCJldmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJjdXJyZW50VGFyZ2V0Iiwic3RvcHBlZCIsImltbWVkaWF0ZVN0b3BwZWQiLCJ0aW1lU3RhbXAiLCJEYXRlIiwibm93Iiwia2V5cyIsImkiLCJsZW5ndGgiLCJrZXkiLCJkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IiLCJ0YXJnZXQiLCJjb21wb3NlZFBhdGgiLCJOT05FIiwiQ0FQVFVSSU5HX1BIQVNFIiwiQVRfVEFSR0VUIiwiQlVCQkxJTkdfUEhBU0UiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJidWJibGVzIiwiQm9vbGVhbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb21wb3NlZCIsInNyY0VsZW1lbnQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImluaXRFdmVudCIsIndyaXRhYmxlIiwid2luZG93Iiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVDYWxsRGVzY3JpcHRvciIsImFwcGx5IiwiYXJndW1lbnRzIiwiZGVmaW5lV3JhcHBlciIsIkJhc2VFdmVudCIsInByb3RvIiwiQ3VzdG9tRXZlbnQiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNGdW5jIiwiZ2V0V3JhcHBlciIsIndyYXBwZXIiLCJnZXRQcm90b3R5cGVPZiIsIndyYXBFdmVudCIsIldyYXBwZXIiLCJpc1N0b3BwZWQiLCJzZXRFdmVudFBoYXNlIiwic2V0Q3VycmVudFRhcmdldCIsInNldFBhc3NpdmVMaXN0ZW5lciIsImxpc3RlbmVyc01hcCIsIkNBUFRVUkUiLCJCVUJCTEUiLCJBVFRSSUJVVEUiLCJpc09iamVjdCIsIngiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IiLCJldmVudE5hbWUiLCJub2RlIiwibGlzdGVuZXJUeXBlIiwibGlzdGVuZXIiLCJuZXh0IiwicHJldiIsImRlbGV0ZSIsIm5ld05vZGUiLCJwYXNzaXZlIiwib25jZSIsImV2ZW50VGFyZ2V0UHJvdG90eXBlIiwiZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQiLCJldmVudE5hbWVzIiwiQ3VzdG9tRXZlbnRUYXJnZXQiLCJNYXAiLCJBcnJheSIsImlzQXJyYXkiLCJ0eXBlcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvcHRpb25zIiwib3B0aW9uc0lzT2JqIiwiY2FwdHVyZSIsInVuZGVmaW5lZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ3cmFwcGVkRXZlbnQiLCJlcnIiLCJoYW5kbGVFdmVudCIsImdsb2JhbFRoaXMiLCJET01FeGNlcHRpb24iLCJNZXNzYWdlQ2hhbm5lbCIsInJlcXVpcmUiLCJwb3J0IiwicG9ydDEiLCJhYiIsIkFycmF5QnVmZmVyIiwicG9zdE1lc3NhZ2UiLCJuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN5bWJvbFBvbHlmaWxsIiwiaXRlcmF0b3IiLCJkZXNjcmlwdGlvbiIsIm5vb3AiLCJnZXRHbG9iYWxzIiwic2VsZiIsImdsb2JhbCIsImdsb2JhbHMiLCJ0eXBlSXNPYmplY3QiLCJyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24iLCJvcmlnaW5hbFByb21pc2UiLCJQcm9taXNlIiwib3JpZ2luYWxQcm9taXNlVGhlbiIsInRoZW4iLCJvcmlnaW5hbFByb21pc2VSZXNvbHZlIiwicmVzb2x2ZSIsImJpbmQiLCJvcmlnaW5hbFByb21pc2VSZWplY3QiLCJyZWplY3QiLCJuZXdQcm9taXNlIiwiZXhlY3V0b3IiLCJwcm9taXNlUmVzb2x2ZWRXaXRoIiwicHJvbWlzZVJlamVjdGVkV2l0aCIsInJlYXNvbiIsIlBlcmZvcm1Qcm9taXNlVGhlbiIsInByb21pc2UiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJ1cG9uUHJvbWlzZSIsInVwb25GdWxmaWxsbWVudCIsInVwb25SZWplY3Rpb24iLCJ0cmFuc2Zvcm1Qcm9taXNlV2l0aCIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlIiwicXVldWVNaWNyb3Rhc2siLCJnbG9iYWxRdWV1ZU1pY3JvdGFzayIsInJlc29sdmVkUHJvbWlzZSIsImZuIiwicmVmbGVjdENhbGwiLCJGIiwiViIsImFyZ3MiLCJGdW5jdGlvbiIsInByb21pc2VDYWxsIiwiUVVFVUVfTUFYX0FSUkFZX1NJWkUiLCJTaW1wbGVRdWV1ZSIsIl9jdXJzb3IiLCJfc2l6ZSIsIl9mcm9udCIsIl9lbGVtZW50cyIsIl9uZXh0IiwiX2JhY2siLCJwdXNoIiwiZWxlbWVudCIsIm9sZEJhY2siLCJuZXdCYWNrIiwic2hpZnQiLCJvbGRGcm9udCIsIm5ld0Zyb250Iiwib2xkQ3Vyc29yIiwibmV3Q3Vyc29yIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJwZWVrIiwiZnJvbnQiLCJjdXJzb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplIiwicmVhZGVyIiwic3RyZWFtIiwiX293bmVyUmVhZGFibGVTdHJlYW0iLCJfcmVhZGVyIiwiX3N0YXRlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJfc3RvcmVkRXJyb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwiLCJSZWFkYWJsZVN0cmVhbUNhbmNlbCIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwicmVhZGVyTG9ja0V4Y2VwdGlvbiIsIl9jbG9zZWRQcm9taXNlIiwiX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSIsIl9jbG9zZWRQcm9taXNlX3JlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSIsIkFib3J0U3RlcHMiLCJFcnJvclN0ZXBzIiwiQ2FuY2VsU3RlcHMiLCJQdWxsU3RlcHMiLCJOdW1iZXJJc0Zpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiTWF0aFRydW5jIiwiTWF0aCIsInRydW5jIiwidiIsImNlaWwiLCJmbG9vciIsImlzRGljdGlvbmFyeSIsImFzc2VydERpY3Rpb25hcnkiLCJvYmoiLCJjb250ZXh0IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRPYmplY3QiLCJhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IiwicG9zaXRpb24iLCJhc3NlcnRSZXF1aXJlZEZpZWxkIiwiZmllbGQiLCJjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIiwiY2Vuc29yTmVnYXRpdmVaZXJvIiwiaW50ZWdlclBhcnQiLCJjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhc3NlcnRSZWFkYWJsZVN0cmVhbSIsIklzUmVhZGFibGVTdHJlYW0iLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdCIsInJlYWRSZXF1ZXN0IiwiX3JlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0IiwiY2h1bmsiLCJkb25lIiwiX2Nsb3NlU3RlcHMiLCJfY2h1bmtTdGVwcyIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzIiwiUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJJc1JlYWRhYmxlU3RyZWFtTG9ja2VkIiwiY2xvc2VkIiwiZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjYW5jZWwiLCJyZWFkIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwiX2Vycm9yU3RlcHMiLCJlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCIsInJlbGVhc2VMb2NrIiwiaGFzT3duUHJvcGVydHkiLCJfZGlzdHVyYmVkIiwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciIsIkFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIiwicHJldmVudENhbmNlbCIsIl9vbmdvaW5nUHJvbWlzZSIsIl9pc0ZpbmlzaGVkIiwiX3ByZXZlbnRDYW5jZWwiLCJuZXh0U3RlcHMiLCJfbmV4dFN0ZXBzIiwicmV0dXJuIiwicmV0dXJuU3RlcHMiLCJfcmV0dXJuU3RlcHMiLCJyZXN1bHQiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsInN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uIiwiX2FzeW5jSXRlcmF0b3JJbXBsIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImltcGwiLCJfYSIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJDcmVhdGVBcnJheUZyb21MaXN0Iiwic2xpY2UiLCJDb3B5RGF0YUJsb2NrQnl0ZXMiLCJkZXN0IiwiZGVzdE9mZnNldCIsInNyYyIsInNyY09mZnNldCIsIm4iLCJVaW50OEFycmF5IiwiVHJhbnNmZXJBcnJheUJ1ZmZlciIsIk8iLCJJc0RldGFjaGVkQnVmZmVyIiwiQXJyYXlCdWZmZXJTbGljZSIsImJ1ZmZlciIsImJlZ2luIiwiZW5kIiwiSXNOb25OZWdhdGl2ZU51bWJlciIsIkNsb25lQXNVaW50OEFycmF5IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJEZXF1ZXVlVmFsdWUiLCJjb250YWluZXIiLCJwYWlyIiwiX3F1ZXVlIiwiX3F1ZXVlVG90YWxTaXplIiwic2l6ZSIsIkVucXVldWVWYWx1ZVdpdGhTaXplIiwiSW5maW5pdHkiLCJSYW5nZUVycm9yIiwiUGVla1F1ZXVlVmFsdWUiLCJSZXNldFF1ZXVlIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsInZpZXciLCJJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfdmlldyIsInJlc3BvbmQiLCJieXRlc1dyaXR0ZW4iLCJfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCIsInJlc3BvbmRXaXRoTmV3VmlldyIsImlzVmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiYnlvYlJlcXVlc3QiLCJJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QiLCJkZXNpcmVkU2l6ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsImNsb3NlIiwiX2Nsb3NlUmVxdWVzdGVkIiwic3RhdGUiLCJfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSIsImVucXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MiLCJfY2FuY2VsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsImVudHJ5IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4iLCJhdXRvQWxsb2NhdGVDaHVua1NpemUiLCJfYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiYnVmZmVyRSIsInB1bGxJbnRvRGVzY3JpcHRvciIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJieXRlc0ZpbGxlZCIsImVsZW1lbnRTaXplIiwidmlld0NvbnN0cnVjdG9yIiwicmVhZGVyVHlwZSIsIl9wZW5kaW5nUHVsbEludG9zIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJzaG91bGRQdWxsIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsIiwiX3B1bGxpbmciLCJfcHVsbEFnYWluIiwicHVsbFByb21pc2UiLCJfcHVsbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yIiwiZmlsbGVkVmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yIiwiUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZSIsImN1cnJlbnRBbGlnbmVkQnl0ZXMiLCJtYXhCeXRlc1RvQ29weSIsIm1pbiIsIm1heEJ5dGVzRmlsbGVkIiwibWF4QWxpZ25lZEJ5dGVzIiwidG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyIsInJlYWR5IiwicXVldWUiLCJoZWFkT2ZRdWV1ZSIsImJ5dGVzVG9Db3B5IiwiZGVzdFN0YXJ0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yIiwiUmVhZGFibGVTdHJlYW1DbG9zZSIsIl9ieW9iUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8iLCJyZWFkSW50b1JlcXVlc3QiLCJEYXRhVmlldyIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiY3RvciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0IiwiZW1wdHlWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlIiwiZmlyc3REZXNjcmlwdG9yIiwiUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUiLCJyZW1haW5kZXJTaXplIiwicmVtYWluZGVyIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbCIsIl9zdGFydGVkIiwiZmlyc3RQZW5kaW5nUHVsbEludG8iLCJ0cmFuc2ZlcnJlZEJ1ZmZlciIsInRyYW5zZmVycmVkVmlldyIsIlJlYWRhYmxlU3RyZWFtRXJyb3IiLCJTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJfc3RyYXRlZ3lIV00iLCJ2aWV3Qnl0ZUxlbmd0aCIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsInN0YXJ0QWxnb3JpdGhtIiwicHVsbEFsZ29yaXRobSIsImNhbmNlbEFsZ29yaXRobSIsImhpZ2hXYXRlck1hcmsiLCJzdGFydFJlc3VsdCIsInIiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdCeXRlU291cmNlIiwic3RhcnQiLCJwdWxsIiwicmVxdWVzdCIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJfcmVhZEludG9SZXF1ZXN0cyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkIiwiRXh0cmFjdEhpZ2hXYXRlck1hcmsiLCJzdHJhdGVneSIsImRlZmF1bHRIV00iLCJFeHRyYWN0U2l6ZUFsZ29yaXRobSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kiLCJpbml0IiwiY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmsiLCJvcmlnaW5hbCIsIndyaXRlIiwiY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayIsImFzc2VydFdyaXRhYmxlU3RyZWFtIiwiSXNXcml0YWJsZVN0cmVhbSIsImlzQWJvcnRTaWduYWwiLCJzdXBwb3J0c0Fib3J0Q29udHJvbGxlciIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NpbmsiLCJyYXdTdHJhdGVneSIsInVuZGVybHlpbmdTaW5rIiwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtIiwic2l6ZUFsZ29yaXRobSIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayIsImxvY2tlZCIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsIklzV3JpdGFibGVTdHJlYW1Mb2NrZWQiLCJXcml0YWJsZVN0cmVhbUFib3J0IiwiV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbUNsb3NlIiwiZ2V0V3JpdGVyIiwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIkNyZWF0ZVdyaXRhYmxlU3RyZWFtIiwid3JpdGVBbGdvcml0aG0iLCJjbG9zZUFsZ29yaXRobSIsImFib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwid2FzQWxyZWFkeUVycm9yaW5nIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3JpbmciLCJjbG9zZVJlcXVlc3QiLCJ3cml0ZXIiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0Iiwid3JpdGVSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbiIsIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQiLCJzdG9yZWRFcnJvciIsIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQiLCJhYm9ydFJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2UiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlIiwiYmFja3ByZXNzdXJlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0IiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUiLCJfcmVhZHlQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQiLCJfY2xvc2VkUHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZHlQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsInJlbGVhc2VkRXJyb3IiLCJjaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlIiwiY2xvc2VTZW50aW5lbCIsImFib3J0UmVhc29uIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiX2Fib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlIiwic3RhcnRQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkIiwiY2h1bmtTaXplRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkIiwiZW5xdWV1ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZSIsInNpbmtDbG9zZVByb21pc2UiLCJzaW5rV3JpdGVQcm9taXNlIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9yZWFkeVByb21pc2VfcmVzb2x2ZSIsIl9yZWFkeVByb21pc2VfcmVqZWN0IiwiTmF0aXZlRE9NRXhjZXB0aW9uIiwiaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvciIsImNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsIiwibWVzc2FnZSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJET01FeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtUGlwZVRvIiwic291cmNlIiwicHJldmVudENsb3NlIiwicHJldmVudEFib3J0Iiwic2h1dHRpbmdEb3duIiwiY3VycmVudFdyaXRlIiwiYWN0aW9ucyIsInNodXRkb3duV2l0aEFjdGlvbiIsImFsbCIsIm1hcCIsImFjdGlvbiIsInBpcGVMb29wIiwicmVzb2x2ZUxvb3AiLCJyZWplY3RMb29wIiwicGlwZVN0ZXAiLCJyZXNvbHZlUmVhZCIsInJlamVjdFJlYWQiLCJpc09yQmVjb21lc0Vycm9yZWQiLCJzaHV0ZG93biIsImlzT3JCZWNvbWVzQ2xvc2VkIiwiZGVzdENsb3NlZCIsIndhaXRGb3JXcml0ZXNUb0ZpbmlzaCIsIm9sZEN1cnJlbnRXcml0ZSIsIm9yaWdpbmFsSXNFcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJkb1RoZVJlc3QiLCJmaW5hbGl6ZSIsIm5ld0Vycm9yIiwiaXNFcnJvciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbVRlZSIsImNsb25lRm9yQnJhbmNoMiIsIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZSIsInJlYWRpbmciLCJyZWFkQWdhaW4iLCJjYW5jZWxlZDEiLCJjYW5jZWxlZDIiLCJyZWFzb24xIiwicmVhc29uMiIsImJyYW5jaDEiLCJicmFuY2gyIiwicmVzb2x2ZUNhbmNlbFByb21pc2UiLCJjYW5jZWxQcm9taXNlIiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FuY2VsMUFsZ29yaXRobSIsImNvbXBvc2l0ZVJlYXNvbiIsImNhbmNlbFJlc3VsdCIsImNhbmNlbDJBbGdvcml0aG0iLCJDcmVhdGVSZWFkYWJsZVN0cmVhbSIsInJlYWRBZ2FpbkZvckJyYW5jaDEiLCJyZWFkQWdhaW5Gb3JCcmFuY2gyIiwiZm9yd2FyZFJlYWRlckVycm9yIiwidGhpc1JlYWRlciIsInB1bGxXaXRoRGVmYXVsdFJlYWRlciIsImNsb25lRSIsInB1bGwxQWxnb3JpdGhtIiwicHVsbDJBbGdvcml0aG0iLCJwdWxsV2l0aEJZT0JSZWFkZXIiLCJmb3JCcmFuY2gyIiwiYnlvYkJyYW5jaCIsIm90aGVyQnJhbmNoIiwiYnlvYkNhbmNlbGVkIiwib3RoZXJDYW5jZWxlZCIsImNsb25lZENodW5rIiwiQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtIiwiY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrIiwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSIsImNvbnZlcnRSZWFkZXJPcHRpb25zIiwibW9kZSIsImNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUiLCJjb252ZXJ0SXRlcmF0b3JPcHRpb25zIiwiY29udmVydFBpcGVPcHRpb25zIiwiYXNzZXJ0QWJvcnRTaWduYWwiLCJjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIiLCJyZWFkYWJsZSIsIlJlYWRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NvdXJjZSIsIkluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsImdldFJlYWRlciIsInJhd09wdGlvbnMiLCJwaXBlVGhyb3VnaCIsInJhd1RyYW5zZm9ybSIsInRyYW5zZm9ybSIsInBpcGVUbyIsImRlc3RpbmF0aW9uIiwidGVlIiwiYnJhbmNoZXMiLCJ2YWx1ZXMiLCJhc3luY0l0ZXJhdG9yIiwic291cmNlQ2FuY2VsUHJvbWlzZSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IiwiYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiIsIkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvdW50U2l6ZUZ1bmN0aW9uIiwiQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNDb3VudFF1ZXVpbmdTdHJhdGVneSIsImNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvbnZlcnRUcmFuc2Zvcm1lciIsImZsdXNoIiwicmVhZGFibGVUeXBlIiwid3JpdGFibGVUeXBlIiwiY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayIsIlRyYW5zZm9ybVN0cmVhbSIsInJhd1RyYW5zZm9ybWVyIiwicmF3V3JpdGFibGVTdHJhdGVneSIsInJhd1JlYWRhYmxlU3RyYXRlZ3kiLCJ3cml0YWJsZVN0cmF0ZWd5IiwicmVhZGFibGVTdHJhdGVneSIsInRyYW5zZm9ybWVyIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwicmVhZGFibGVTaXplQWxnb3JpdGhtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwid3JpdGFibGVTaXplQWxnb3JpdGhtIiwic3RhcnRQcm9taXNlX3Jlc29sdmUiLCJJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lciIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW0iLCJfcmVhZGFibGUiLCJfd3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvciIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwicmVhZGFibGVDb250cm9sbGVyIiwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwidGVybWluYXRlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUiLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwidHJhbnNmb3JtQWxnb3JpdGhtIiwiZmx1c2hBbGdvcml0aG0iLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwidHJhbnNmb3JtUmVzdWx0RSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybSIsInRyYW5zZm9ybVByb21pc2UiLCJiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiZmx1c2hQcm9taXNlIiwiZGF0YVVyaVRvQnVmZmVyIiwidXJpIiwidGVzdCIsInJlcGxhY2UiLCJmaXJzdENvbW1hIiwiaW5kZXhPZiIsIm1ldGEiLCJzdWJzdHJpbmciLCJzcGxpdCIsImNoYXJzZXQiLCJiYXNlNjQiLCJ0eXBlRnVsbCIsImVuY29kaW5nIiwidW5lc2NhcGUiLCJCdWZmZXIiLCJmcm9tIiwiQmxvYiIsIl9GaWxlIiwiRmlsZSIsImxhc3RNb2RpZmllZCIsImZpbGVCaXRzIiwiZmlsZU5hbWUiLCJTdHJpbmciLCJoYXNJbnN0YW5jZSIsIm9iamVjdCIsInN0YXRTeW5jIiwiY3JlYXRlUmVhZFN0cmVhbSIsInByb21pc2VzIiwiZnMiLCJiYXNlbmFtZSIsInN0YXQiLCJibG9iRnJvbVN5bmMiLCJwYXRoIiwiZnJvbUJsb2IiLCJibG9iRnJvbSIsImZpbGVGcm9tIiwiZnJvbUZpbGUiLCJmaWxlRnJvbVN5bmMiLCJCbG9iRGF0YUl0ZW0iLCJtdGltZU1zIiwiUE9PTF9TSVpFIiwidG9JdGVyYXRvciIsInBhcnRzIiwiY2xvbmUiLCJwYXJ0IiwiYiIsImFycmF5QnVmZmVyIiwiX0Jsb2IiLCJlbmRpbmdzIiwiYmxvYlBhcnRzIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwidGV4dCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInN0ciIsImRlY29kZSIsIm9mZnNldCIsIml0IiwiY3RybCIsInJlbGF0aXZlU3RhcnQiLCJtYXgiLCJyZWxhdGl2ZUVuZCIsInNwYW4iLCJhZGRlZCIsInN1YmFycmF5IiwiYmxvYiIsInRvTG93ZXJDYXNlIiwiQyIsInQiLCJoIiwicmFuZG9tIiwibSIsImYiLCJhIiwiYyIsIkZvcm1EYXRhIiwiZCIsImVudHJpZXMiLCJvIiwic29tZSIsImFwcGVuZCIsImZpbHRlciIsImwiLCJnZXRBbGwiLCJoYXMiLCJmb3JtRGF0YVRvQmxvYiIsIkIiLCJwYWRTdGFydCIsInAiLCJmZXRjaCIsIkhlYWRlcnMiLCJSZXF1ZXN0IiwiUmVzcG9uc2UiLCJURU5fTUVHQUJZVEVTIiwidXJsIiwiZGVmYXVsdCIsImt5IiwiSFRUUEVycm9yIiwiVGltZW91dEVycm9yIiwiU3RyZWFtIiwiUGFzc1Rocm91Z2giLCJkZXByZWNhdGUiLCJwcm9taXNpZnkiLCJGZXRjaEVycm9yIiwiRmV0Y2hCYXNlRXJyb3IiLCJpc0Jsb2IiLCJpc1VSTFNlYXJjaFBhcmFtZXRlcnMiLCJwaXBlbGluZSIsIklOVEVSTkFMUyIsIkJvZHkiLCJib2R5IiwiYm91bmRhcnkiLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwiaXNBbnlBcnJheUJ1ZmZlciIsIlJlYWRhYmxlIiwiZGlzdHVyYmVkIiwib24iLCJlcnJvcl8iLCJib2R5VXNlZCIsImNvbnN1bWVCb2R5IiwiZm9ybURhdGEiLCJjdCIsImhlYWRlcnMiLCJzdGFydHNXaXRoIiwicGFyYW1ldGVycyIsIlVSTFNlYXJjaFBhcmFtcyIsInRvRm9ybURhdGEiLCJidWYiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwiYWxsb2MiLCJhY2N1bSIsImFjY3VtQnl0ZXMiLCJkZXN0cm95IiwicmVhZGFibGVFbmRlZCIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kZWQiLCJldmVyeSIsImpvaW4iLCJjb25jYXQiLCJpbnN0YW5jZSIsInAxIiwicDIiLCJnZXRCb3VuZGFyeSIsInBpcGUiLCJnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeSIsImV4dHJhY3RDb250ZW50VHlwZSIsImdldFRvdGFsQnl0ZXMiLCJnZXRMZW5ndGhTeW5jIiwiaGFzS25vd25MZW5ndGgiLCJ3cml0ZVRvU3RyZWFtIiwiQWJvcnRFcnJvciIsInN5c3RlbUVycm9yIiwiY29kZSIsImVycm5vIiwiZXJyb3JlZFN5c0NhbGwiLCJzeXNjYWxsIiwiaHR0cCIsInZhbGlkYXRlSGVhZGVyTmFtZSIsInZhbGlkYXRlSGVhZGVyVmFsdWUiLCJyYXciLCJpc0JveGVkUHJpbWl0aXZlIiwibWV0aG9kIiwiUHJveHkiLCJyZWNlaXZlciIsInNvcnQiLCJTZXQiLCJSZWZsZWN0IiwidGhpc0FyZyIsInJlZHVjZSIsImZvciIsInByb3BlcnR5IiwiZnJvbVJhd0hlYWRlcnMiLCJpbmRleCIsImFycmF5IiwiaHR0cHMiLCJ6bGliIiwicHVtcCIsImdldE5vZGVSZXF1ZXN0T3B0aW9ucyIsImlzUmVkaXJlY3QiLCJpc0RvbWFpbk9yU3ViZG9tYWluIiwiaXNTYW1lUHJvdG9jb2wiLCJwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlciIsInN1cHBvcnRlZFNjaGVtYXMiLCJvcHRpb25zXyIsInBhcnNlZFVSTCIsInByb3RvY29sIiwicmVzcG9uc2UiLCJzZW5kIiwiZW1pdCIsImFib3J0QW5kRmluYWxpemUiLCJyZXF1ZXN0XyIsImZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nIiwicHJvY2VzcyIsInZlcnNpb24iLCJzIiwiZW5kZWRXaXRoRXZlbnRzQ291bnQiLCJwcmVwZW5kTGlzdGVuZXIiLCJfZXZlbnRzQ291bnQiLCJoYWRFcnJvciIsInJlc3BvbnNlXyIsInNldFRpbWVvdXQiLCJyYXdIZWFkZXJzIiwic3RhdHVzQ29kZSIsImxvY2F0aW9uIiwibG9jYXRpb25VUkwiLCJVUkwiLCJyZWRpcmVjdCIsImNvdW50ZXIiLCJmb2xsb3ciLCJyZXF1ZXN0T3B0aW9ucyIsImFnZW50IiwiY29tcHJlc3MiLCJyZWZlcnJlciIsInJlZmVycmVyUG9saWN5IiwicmVzcG9uc2VSZWZlcnJlclBvbGljeSIsInJlc3BvbnNlT3B0aW9ucyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJzdGF0dXNNZXNzYWdlIiwiY29kaW5ncyIsInpsaWJPcHRpb25zIiwiWl9TWU5DX0ZMVVNIIiwiZmluaXNoRmx1c2giLCJjcmVhdGVHdW56aXAiLCJjcmVhdGVJbmZsYXRlIiwiY3JlYXRlSW5mbGF0ZVJhdyIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJjYXRjaCIsImVycm9yQ2FsbGJhY2siLCJMQVNUX0NIVU5LIiwiaXNDaHVua2VkVHJhbnNmZXIiLCJwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCIsInByZXZpb3VzQ2h1bmsiLCJzb2NrZXQiLCJvblNvY2tldENsb3NlIiwib25EYXRhIiwiY29tcGFyZSIsInJlbW92ZUxpc3RlbmVyIiwiZm9ybWF0IiwiZm9ybWF0VXJsIiwiZ2V0U2VhcmNoIiwidmFsaWRhdGVSZWZlcnJlclBvbGljeSIsImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIiLCJERUZBVUxUX1JFRkVSUkVSX1BPTElDWSIsImlzUmVxdWVzdCIsImRvQmFkRGF0YVdhcm4iLCJpbnB1dCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ0b1VwcGVyQ2FzZSIsImlucHV0Qm9keSIsImNvbnRlbnRUeXBlIiwicGFyc2VkUmVmZXJyZXIiLCJpbnNlY3VyZUhUVFBQYXJzZXIiLCJjb250ZW50TGVuZ3RoVmFsdWUiLCJ0b3RhbEJ5dGVzIiwic2VhcmNoIiwicGF0aG5hbWUiLCJvayIsInJlZGlyZWN0ZWQiLCJzdHJpbmdpZnkiLCJsYXN0T2Zmc2V0IiwiaHJlZiIsImhhc2giLCJyZWRpcmVjdFN0YXR1cyIsIk5BTUUiLCJvcmlnIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImlzSVAiLCJzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyIiwib3JpZ2luT25seSIsIlJlZmVycmVyUG9saWN5IiwiaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IiwiaG9zdElwIiwiaG9zdCIsImhvc3RJUFZlcnNpb24iLCJpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJyZWZlcnJlclVSTENhbGxiYWNrIiwicmVmZXJyZXJPcmlnaW5DYWxsYmFjayIsInBvbGljeSIsInJlZmVycmVyU291cmNlIiwicmVmZXJyZXJVUkwiLCJyZWZlcnJlck9yaWdpbiIsImN1cnJlbnRVUkwiLCJvcmlnaW4iLCJwb2xpY3lUb2tlbnMiLCJ0b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=