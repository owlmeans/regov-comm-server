exports.id = "vendors-node_modules_ky-universal_index_js";
exports.ids = ["vendors-node_modules_ky-universal_index_js"];
exports.modules = {

/***/ "./node_modules/abort-controller/dist/abort-controller.js":
/*!****************************************************************!*\
  !*** ./node_modules/abort-controller/dist/abort-controller.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var eventTargetShim = __webpack_require__(/*! event-target-shim */ "./node_modules/event-target-shim/dist/event-target-shim.js");

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
class AbortSignal extends eventTargetShim.EventTarget {
  /**
   * AbortSignal cannot be constructed directly.
   */
  constructor() {
    super();
    throw new TypeError("AbortSignal cannot be constructed directly");
  }
  /**
   * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
   */
  get aborted() {
    const aborted = abortedFlags.get(this);
    if (typeof aborted !== "boolean") {
      throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
    }
    return aborted;
  }
}
eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
  const signal = Object.create(AbortSignal.prototype);
  eventTargetShim.EventTarget.call(signal);
  abortedFlags.set(signal, false);
  return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
  if (abortedFlags.get(signal) !== false) {
    return;
  }
  abortedFlags.set(signal, true);
  signal.dispatchEvent({
    type: "abort"
  });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal.prototype, {
  aborted: {
    enumerable: true
  }
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortSignal"
  });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
class AbortController {
  /**
   * Initialize this controller.
   */
  constructor() {
    signals.set(this, createAbortSignal());
  }
  /**
   * Returns the `AbortSignal` object associated with this object.
   */
  get signal() {
    return getSignal(this);
  }
  /**
   * Abort and signal to any observers that the associated activity is to be aborted.
   */
  abort() {
    abortSignal(getSignal(this));
  }
}
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
  const signal = signals.get(controller);
  if (signal == null) {
    throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
  }
  return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController.prototype, {
  signal: {
    enumerable: true
  },
  abort: {
    enumerable: true
  }
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortController"
  });
}
exports.AbortController = AbortController;
exports.AbortSignal = AbortSignal;
exports["default"] = AbortController;
module.exports = AbortController;
module.exports.AbortController = module.exports["default"] = AbortController;
module.exports.AbortSignal = AbortSignal;

/***/ }),

/***/ "./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
  const retv = privateData.get(event);
  console.assert(retv != null, "'this' is expected an Event object, but got", event);
  return retv;
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
  if (data.passiveListener != null) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
    }
    return;
  }
  if (!data.event.cancelable) {
    return;
  }
  data.canceled = true;
  if (typeof data.event.preventDefault === "function") {
    data.event.preventDefault();
  }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
  privateData.set(this, {
    eventTarget,
    event,
    eventPhase: 2,
    currentTarget: eventTarget,
    canceled: false,
    stopped: false,
    immediateStopped: false,
    passiveListener: null,
    timeStamp: event.timeStamp || Date.now()
  });

  // https://heycam.github.io/webidl/#Unforgeable
  Object.defineProperty(this, "isTrusted", {
    value: false,
    enumerable: true
  });

  // Define accessors
  const keys = Object.keys(event);
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in this)) {
      Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return pd(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return pd(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return pd(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const currentTarget = pd(this).currentTarget;
    if (currentTarget == null) {
      return [];
    }
    return [currentTarget];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return pd(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.stopPropagation === "function") {
      data.event.stopPropagation();
    }
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const data = pd(this);
    data.stopped = true;
    data.immediateStopped = true;
    if (typeof data.event.stopImmediatePropagation === "function") {
      data.event.stopImmediatePropagation();
    }
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return Boolean(pd(this).event.bubbles);
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return Boolean(pd(this).event.cancelable);
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    setCancelFlag(pd(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return pd(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return Boolean(pd(this).event.composed);
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return pd(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return pd(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return pd(this).stopped;
  },
  set cancelBubble(value) {
    if (!value) {
      return;
    }
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.cancelBubble === "boolean") {
      data.event.cancelBubble = true;
    }
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !pd(this).canceled;
  },
  set returnValue(value) {
    if (!value) {
      setCancelFlag(pd(this));
    }
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
    // Do nothing.
  }
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
  value: Event,
  configurable: true,
  writable: true
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
  Object.setPrototypeOf(Event.prototype, window.Event.prototype);

  // Make association for wrappers.
  wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
  return {
    get() {
      return pd(this).event[key];
    },
    set(value) {
      pd(this).event[key] = value;
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
  return {
    value() {
      const event = pd(this).event;
      return event[key].apply(event, arguments);
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
  const keys = Object.keys(proto);
  if (keys.length === 0) {
    return BaseEvent;
  }

  /** CustomEvent */
  function CustomEvent(eventTarget, event) {
    BaseEvent.call(this, eventTarget, event);
  }
  CustomEvent.prototype = Object.create(BaseEvent.prototype, {
    constructor: {
      value: CustomEvent,
      configurable: true,
      writable: true
    }
  });

  // Define accessors.
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in BaseEvent.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      const isFunc = typeof descriptor.value === "function";
      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
    }
  }
  return CustomEvent;
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
  if (proto == null || proto === Object.prototype) {
    return Event;
  }
  let wrapper = wrappers.get(proto);
  if (wrapper == null) {
    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
    wrappers.set(proto, wrapper);
  }
  return wrapper;
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
  const Wrapper = getWrapper(Object.getPrototypeOf(event));
  return new Wrapper(eventTarget, event);
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
  return pd(event).immediateStopped;
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
  pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
  pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
  pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
  return x !== null && typeof x === "object"; //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
  const listeners = listenersMap.get(eventTarget);
  if (listeners == null) {
    throw new TypeError("'this' is expected an EventTarget object, but got another value.");
  }
  return listeners;
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
  return {
    get() {
      const listeners = getListeners(this);
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          return node.listener;
        }
        node = node.next;
      }
      return null;
    },
    set(listener) {
      if (typeof listener !== "function" && !isObject(listener)) {
        listener = null; // eslint-disable-line no-param-reassign
      }

      const listeners = getListeners(this);

      // Traverse to the tail while removing old value.
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          // Remove old value.
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        node = node.next;
      }

      // Add new value.
      if (listener !== null) {
        const newNode = {
          listener,
          listenerType: ATTRIBUTE,
          passive: false,
          once: false,
          next: null
        };
        if (prev === null) {
          listeners.set(eventName, newNode);
        } else {
          prev.next = newNode;
        }
      }
    },
    configurable: true,
    enumerable: true
  };
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
  /** CustomEventTarget */
  function CustomEventTarget() {
    EventTarget.call(this);
  }
  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
    constructor: {
      value: CustomEventTarget,
      configurable: true,
      writable: true
    }
  });
  for (let i = 0; i < eventNames.length; ++i) {
    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  }
  return CustomEventTarget;
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
  /*eslint-disable consistent-return */
  if (this instanceof EventTarget) {
    listenersMap.set(this, new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return defineCustomEventTarget(arguments[0]);
  }
  if (arguments.length > 0) {
    const types = new Array(arguments.length);
    for (let i = 0; i < arguments.length; ++i) {
      types[i] = arguments[i];
    }
    return defineCustomEventTarget(types);
  }
  throw new TypeError("Cannot call a class as a function");
  /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    if (typeof listener !== "function" && !isObject(listener)) {
      throw new TypeError("'listener' should be a function or an object.");
    }
    const listeners = getListeners(this);
    const optionsIsObj = isObject(options);
    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    const newNode = {
      listener,
      listenerType,
      passive: optionsIsObj && Boolean(options.passive),
      once: optionsIsObj && Boolean(options.once),
      next: null
    };

    // Set it as the first node if the first node is null.
    let node = listeners.get(eventName);
    if (node === undefined) {
      listeners.set(eventName, newNode);
      return;
    }

    // Traverse to the tail while checking duplication..
    let prev = null;
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        // Should ignore duplication.
        return;
      }
      prev = node;
      node = node.next;
    }

    // Add it.
    prev.next = newNode;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    const listeners = getListeners(this);
    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    let prev = null;
    let node = listeners.get(eventName);
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
        return;
      }
      prev = node;
      node = node.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(event) {
    if (event == null || typeof event.type !== "string") {
      throw new TypeError('"event.type" should be a string.');
    }

    // If listeners aren't registered, terminate.
    const listeners = getListeners(this);
    const eventName = event.type;
    let node = listeners.get(eventName);
    if (node == null) {
      return true;
    }

    // Since we cannot rewrite several properties, so wrap object.
    const wrappedEvent = wrapEvent(this, event);

    // This doesn't process capturing phase and bubbling phase.
    // This isn't participating in a tree.
    let prev = null;
    while (node != null) {
      // Remove this listener if it's once
      if (node.once) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
      } else {
        prev = node;
      }

      // Call this listener
      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
      if (typeof node.listener === "function") {
        try {
          node.listener.call(this, wrappedEvent);
        } catch (err) {
          if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(err);
          }
        }
      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
        node.listener.handleEvent(wrappedEvent);
      }

      // Break if `event.stopImmediatePropagation` was called.
      if (isStopped(wrappedEvent)) {
        break;
      }
      node = node.next;
    }
    setPassiveListener(wrappedEvent, null);
    setEventPhase(wrappedEvent, 0);
    setCurrentTarget(wrappedEvent, null);
    return !wrappedEvent.defaultPrevented;
  }
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
  value: EventTarget,
  configurable: true,
  writable: true
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}
exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports["default"] = EventTarget;
module.exports = EventTarget;
module.exports.EventTarget = module.exports["default"] = EventTarget;
module.exports.defineEventAttribute = defineEventAttribute;

/***/ }),

/***/ "./node_modules/node-domexception/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-domexception/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

if (!globalThis.DOMException) {
  try {
    const {
        MessageChannel
      } = __webpack_require__(/*! worker_threads */ "worker_threads"),
      port = new MessageChannel().port1,
      ab = new ArrayBuffer();
    port.postMessage(ab, [ab, ab]);
  } catch (err) {
    err.constructor.name === 'DOMException' && (globalThis.DOMException = err.constructor);
  }
}
module.exports = globalThis.DOMException;

/***/ }),

/***/ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * web-streams-polyfill v3.2.1
 */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  /// <reference lib="es2015.symbol" />
  const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : description => `Symbol(${description})`;

  /// <reference lib="dom" />
  function noop() {
    return undefined;
  }
  function getGlobals() {
    if (typeof self !== 'undefined') {
      return self;
    } else if (typeof window !== 'undefined') {
      return window;
    } else if (typeof global !== 'undefined') {
      return global;
    }
    return undefined;
  }
  const globals = getGlobals();
  function typeIsObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }
  const rethrowAssertionErrorRejection = noop;
  const originalPromise = Promise;
  const originalPromiseThen = Promise.prototype.then;
  const originalPromiseResolve = Promise.resolve.bind(originalPromise);
  const originalPromiseReject = Promise.reject.bind(originalPromise);
  function newPromise(executor) {
    return new originalPromise(executor);
  }
  function promiseResolvedWith(value) {
    return originalPromiseResolve(value);
  }
  function promiseRejectedWith(reason) {
    return originalPromiseReject(reason);
  }
  function PerformPromiseThen(promise, onFulfilled, onRejected) {
    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
    // approximation.
    return originalPromiseThen.call(promise, onFulfilled, onRejected);
  }
  function uponPromise(promise, onFulfilled, onRejected) {
    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
  }
  function uponFulfillment(promise, onFulfilled) {
    uponPromise(promise, onFulfilled);
  }
  function uponRejection(promise, onRejected) {
    uponPromise(promise, undefined, onRejected);
  }
  function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
  }
  function setPromiseIsHandledToTrue(promise) {
    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
  }
  const queueMicrotask = (() => {
    const globalQueueMicrotask = globals && globals.queueMicrotask;
    if (typeof globalQueueMicrotask === 'function') {
      return globalQueueMicrotask;
    }
    const resolvedPromise = promiseResolvedWith(undefined);
    return fn => PerformPromiseThen(resolvedPromise, fn);
  })();
  function reflectCall(F, V, args) {
    if (typeof F !== 'function') {
      throw new TypeError('Argument is not a function');
    }
    return Function.prototype.apply.call(F, V, args);
  }
  function promiseCall(F, V, args) {
    try {
      return promiseResolvedWith(reflectCall(F, V, args));
    } catch (value) {
      return promiseRejectedWith(value);
    }
  }

  // Original from Chromium
  // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
  const QUEUE_MAX_ARRAY_SIZE = 16384;
  /**
   * Simple queue structure.
   *
   * Avoids scalability issues with using a packed array directly by using
   * multiple arrays in a linked list and keeping the array size bounded.
   */
  class SimpleQueue {
    constructor() {
      this._cursor = 0;
      this._size = 0;
      // _front and _back are always defined.
      this._front = {
        _elements: [],
        _next: undefined
      };
      this._back = this._front;
      // The cursor is used to avoid calling Array.shift().
      // It contains the index of the front element of the array inside the
      // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
      this._cursor = 0;
      // When there is only one node, size === elements.length - cursor.
      this._size = 0;
    }
    get length() {
      return this._size;
    }
    // For exception safety, this method is structured in order:
    // 1. Read state
    // 2. Calculate required state mutations
    // 3. Perform state mutations
    push(element) {
      const oldBack = this._back;
      let newBack = oldBack;
      if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
        newBack = {
          _elements: [],
          _next: undefined
        };
      }
      // push() is the mutation most likely to throw an exception, so it
      // goes first.
      oldBack._elements.push(element);
      if (newBack !== oldBack) {
        this._back = newBack;
        oldBack._next = newBack;
      }
      ++this._size;
    }
    // Like push(), shift() follows the read -> calculate -> mutate pattern for
    // exception safety.
    shift() {
      // must not be called on an empty queue
      const oldFront = this._front;
      let newFront = oldFront;
      const oldCursor = this._cursor;
      let newCursor = oldCursor + 1;
      const elements = oldFront._elements;
      const element = elements[oldCursor];
      if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
        newFront = oldFront._next;
        newCursor = 0;
      }
      // No mutations before this point.
      --this._size;
      this._cursor = newCursor;
      if (oldFront !== newFront) {
        this._front = newFront;
      }
      // Permit shifted element to be garbage collected.
      elements[oldCursor] = undefined;
      return element;
    }
    // The tricky thing about forEach() is that it can be called
    // re-entrantly. The queue may be mutated inside the callback. It is easy to
    // see that push() within the callback has no negative effects since the end
    // of the queue is checked for on every iteration. If shift() is called
    // repeatedly within the callback then the next iteration may return an
    // element that has been removed. In this case the callback will be called
    // with undefined values until we either "catch up" with elements that still
    // exist or reach the back of the queue.
    forEach(callback) {
      let i = this._cursor;
      let node = this._front;
      let elements = node._elements;
      while (i !== elements.length || node._next !== undefined) {
        if (i === elements.length) {
          node = node._next;
          elements = node._elements;
          i = 0;
          if (elements.length === 0) {
            break;
          }
        }
        callback(elements[i]);
        ++i;
      }
    }
    // Return the element that would be returned if shift() was called now,
    // without modifying the queue.
    peek() {
      // must not be called on an empty queue
      const front = this._front;
      const cursor = this._cursor;
      return front._elements[cursor];
    }
  }
  function ReadableStreamReaderGenericInitialize(reader, stream) {
    reader._ownerReadableStream = stream;
    stream._reader = reader;
    if (stream._state === 'readable') {
      defaultReaderClosedPromiseInitialize(reader);
    } else if (stream._state === 'closed') {
      defaultReaderClosedPromiseInitializeAsResolved(reader);
    } else {
      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
    }
  }
  // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
  // check.
  function ReadableStreamReaderGenericCancel(reader, reason) {
    const stream = reader._ownerReadableStream;
    return ReadableStreamCancel(stream, reason);
  }
  function ReadableStreamReaderGenericRelease(reader) {
    if (reader._ownerReadableStream._state === 'readable') {
      defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
    } else {
      defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
    }
    reader._ownerReadableStream._reader = undefined;
    reader._ownerReadableStream = undefined;
  }
  // Helper functions for the readers.
  function readerLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released reader');
  }
  // Helper functions for the ReadableStreamDefaultReader.
  function defaultReaderClosedPromiseInitialize(reader) {
    reader._closedPromise = newPromise((resolve, reject) => {
      reader._closedPromise_resolve = resolve;
      reader._closedPromise_reject = reject;
    });
  }
  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseReject(reader, reason);
  }
  function defaultReaderClosedPromiseInitializeAsResolved(reader) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseResolve(reader);
  }
  function defaultReaderClosedPromiseReject(reader, reason) {
    if (reader._closedPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(reader._closedPromise);
    reader._closedPromise_reject(reason);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }
  function defaultReaderClosedPromiseResetToRejected(reader, reason) {
    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
  }
  function defaultReaderClosedPromiseResolve(reader) {
    if (reader._closedPromise_resolve === undefined) {
      return;
    }
    reader._closedPromise_resolve(undefined);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }
  const AbortSteps = SymbolPolyfill('[[AbortSteps]]');
  const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
  const CancelSteps = SymbolPolyfill('[[CancelSteps]]');
  const PullSteps = SymbolPolyfill('[[PullSteps]]');

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
  const NumberIsFinite = Number.isFinite || function (x) {
    return typeof x === 'number' && isFinite(x);
  };

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
  const MathTrunc = Math.trunc || function (v) {
    return v < 0 ? Math.ceil(v) : Math.floor(v);
  };

  // https://heycam.github.io/webidl/#idl-dictionaries
  function isDictionary(x) {
    return typeof x === 'object' || typeof x === 'function';
  }
  function assertDictionary(obj, context) {
    if (obj !== undefined && !isDictionary(obj)) {
      throw new TypeError(`${context} is not an object.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-callback-functions
  function assertFunction(x, context) {
    if (typeof x !== 'function') {
      throw new TypeError(`${context} is not a function.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-object
  function isObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }
  function assertObject(x, context) {
    if (!isObject(x)) {
      throw new TypeError(`${context} is not an object.`);
    }
  }
  function assertRequiredArgument(x, position, context) {
    if (x === undefined) {
      throw new TypeError(`Parameter ${position} is required in '${context}'.`);
    }
  }
  function assertRequiredField(x, field, context) {
    if (x === undefined) {
      throw new TypeError(`${field} is required in '${context}'.`);
    }
  }
  // https://heycam.github.io/webidl/#idl-unrestricted-double
  function convertUnrestrictedDouble(value) {
    return Number(value);
  }
  function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
  }
  function integerPart(x) {
    return censorNegativeZero(MathTrunc(x));
  }
  // https://heycam.github.io/webidl/#idl-unsigned-long-long
  function convertUnsignedLongLongWithEnforceRange(value, context) {
    const lowerBound = 0;
    const upperBound = Number.MAX_SAFE_INTEGER;
    let x = Number(value);
    x = censorNegativeZero(x);
    if (!NumberIsFinite(x)) {
      throw new TypeError(`${context} is not a finite number`);
    }
    x = integerPart(x);
    if (x < lowerBound || x > upperBound) {
      throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
    }
    if (!NumberIsFinite(x) || x === 0) {
      return 0;
    }
    // TODO Use BigInt if supported?
    // let xBigInt = BigInt(integerPart(x));
    // xBigInt = BigInt.asUintN(64, xBigInt);
    // return Number(xBigInt);
    return x;
  }
  function assertReadableStream(x, context) {
    if (!IsReadableStream(x)) {
      throw new TypeError(`${context} is not a ReadableStream.`);
    }
  }

  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamDefaultReader(stream) {
    return new ReadableStreamDefaultReader(stream);
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamAddReadRequest(stream, readRequest) {
    stream._reader._readRequests.push(readRequest);
  }
  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
    const reader = stream._reader;
    const readRequest = reader._readRequests.shift();
    if (done) {
      readRequest._closeSteps();
    } else {
      readRequest._chunkSteps(chunk);
    }
  }
  function ReadableStreamGetNumReadRequests(stream) {
    return stream._reader._readRequests.length;
  }
  function ReadableStreamHasDefaultReader(stream) {
    const reader = stream._reader;
    if (reader === undefined) {
      return false;
    }
    if (!IsReadableStreamDefaultReader(reader)) {
      return false;
    }
    return true;
  }
  /**
   * A default reader vended by a {@link ReadableStream}.
   *
   * @public
   */
  class ReadableStreamDefaultReader {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
      assertReadableStream(stream, 'First parameter');
      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }
      ReadableStreamReaderGenericInitialize(this, stream);
      this._readRequests = new SimpleQueue();
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed,
     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */
    cancel(reason = undefined) {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }
      return ReadableStreamReaderGenericCancel(this, reason);
    }
    /**
     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */
    read() {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('read'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readRequest = {
        _chunkSteps: chunk => resolvePromise({
          value: chunk,
          done: false
        }),
        _closeSteps: () => resolvePromise({
          value: undefined,
          done: true
        }),
        _errorSteps: e => rejectPromise(e)
      };
      ReadableStreamDefaultReaderRead(this, readRequest);
      return promise;
    }
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */
    releaseLock() {
      if (!IsReadableStreamDefaultReader(this)) {
        throw defaultReaderBrandCheckException('releaseLock');
      }
      if (this._ownerReadableStream === undefined) {
        return;
      }
      if (this._readRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }
      ReadableStreamReaderGenericRelease(this);
    }
  }
  Object.defineProperties(ReadableStreamDefaultReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultReader',
      configurable: true
    });
  }
  // Abstract operations for the readers.
  function IsReadableStreamDefaultReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
      return false;
    }
    return x instanceof ReadableStreamDefaultReader;
  }
  function ReadableStreamDefaultReaderRead(reader, readRequest) {
    const stream = reader._ownerReadableStream;
    stream._disturbed = true;
    if (stream._state === 'closed') {
      readRequest._closeSteps();
    } else if (stream._state === 'errored') {
      readRequest._errorSteps(stream._storedError);
    } else {
      stream._readableStreamController[PullSteps](readRequest);
    }
  }
  // Helper functions for the ReadableStreamDefaultReader.
  function defaultReaderBrandCheckException(name) {
    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
  }

  /// <reference lib="es2018.asynciterable" />
  /* eslint-disable @typescript-eslint/no-empty-function */
  const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);

  /// <reference lib="es2018.asynciterable" />
  class ReadableStreamAsyncIteratorImpl {
    constructor(reader, preventCancel) {
      this._ongoingPromise = undefined;
      this._isFinished = false;
      this._reader = reader;
      this._preventCancel = preventCancel;
    }
    next() {
      const nextSteps = () => this._nextSteps();
      this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
      return this._ongoingPromise;
    }
    return(value) {
      const returnSteps = () => this._returnSteps(value);
      return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
    }
    _nextSteps() {
      if (this._isFinished) {
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }
      const reader = this._reader;
      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('iterate'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readRequest = {
        _chunkSteps: chunk => {
          this._ongoingPromise = undefined;
          // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
          // FIXME Is this a bug in the specification, or in the test?
          queueMicrotask(() => resolvePromise({
            value: chunk,
            done: false
          }));
        },
        _closeSteps: () => {
          this._ongoingPromise = undefined;
          this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          resolvePromise({
            value: undefined,
            done: true
          });
        },
        _errorSteps: reason => {
          this._ongoingPromise = undefined;
          this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          rejectPromise(reason);
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promise;
    }
    _returnSteps(value) {
      if (this._isFinished) {
        return Promise.resolve({
          value,
          done: true
        });
      }
      this._isFinished = true;
      const reader = this._reader;
      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('finish iterating'));
      }
      if (!this._preventCancel) {
        const result = ReadableStreamReaderGenericCancel(reader, value);
        ReadableStreamReaderGenericRelease(reader);
        return transformPromiseWith(result, () => ({
          value,
          done: true
        }));
      }
      ReadableStreamReaderGenericRelease(reader);
      return promiseResolvedWith({
        value,
        done: true
      });
    }
  }
  const ReadableStreamAsyncIteratorPrototype = {
    next() {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
      }
      return this._asyncIteratorImpl.next();
    },
    return(value) {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
      }
      return this._asyncIteratorImpl.return(value);
    }
  };
  if (AsyncIteratorPrototype !== undefined) {
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
  }
  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
    const reader = AcquireReadableStreamDefaultReader(stream);
    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
    iterator._asyncIteratorImpl = impl;
    return iterator;
  }
  function IsReadableStreamAsyncIterator(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
      return false;
    }
    try {
      // noinspection SuspiciousTypeOfGuard
      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
    } catch (_a) {
      return false;
    }
  }
  // Helper functions for the ReadableStream.
  function streamAsyncIteratorBrandCheckException(name) {
    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
  }

  /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
  const NumberIsNaN = Number.isNaN || function (x) {
    // eslint-disable-next-line no-self-compare
    return x !== x;
  };
  function CreateArrayFromList(elements) {
    // We use arrays to represent lists, so this is basically a no-op.
    // Do a slice though just in case we happen to depend on the unique-ness.
    return elements.slice();
  }
  function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  }
  // Not implemented correctly
  function TransferArrayBuffer(O) {
    return O;
  }
  // Not implemented correctly
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function IsDetachedBuffer(O) {
    return false;
  }
  function ArrayBufferSlice(buffer, begin, end) {
    // ArrayBuffer.prototype.slice is not available on IE10
    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
    if (buffer.slice) {
      return buffer.slice(begin, end);
    }
    const length = end - begin;
    const slice = new ArrayBuffer(length);
    CopyDataBlockBytes(slice, 0, buffer, begin, length);
    return slice;
  }
  function IsNonNegativeNumber(v) {
    if (typeof v !== 'number') {
      return false;
    }
    if (NumberIsNaN(v)) {
      return false;
    }
    if (v < 0) {
      return false;
    }
    return true;
  }
  function CloneAsUint8Array(O) {
    const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
    return new Uint8Array(buffer);
  }
  function DequeueValue(container) {
    const pair = container._queue.shift();
    container._queueTotalSize -= pair.size;
    if (container._queueTotalSize < 0) {
      container._queueTotalSize = 0;
    }
    return pair.value;
  }
  function EnqueueValueWithSize(container, value, size) {
    if (!IsNonNegativeNumber(size) || size === Infinity) {
      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
    }
    container._queue.push({
      value,
      size
    });
    container._queueTotalSize += size;
  }
  function PeekQueueValue(container) {
    const pair = container._queue.peek();
    return pair.value;
  }
  function ResetQueue(container) {
    container._queue = new SimpleQueue();
    container._queueTotalSize = 0;
  }

  /**
   * A pull-into request in a {@link ReadableByteStreamController}.
   *
   * @public
   */
  class ReadableStreamBYOBRequest {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
     */
    get view() {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('view');
      }
      return this._view;
    }
    respond(bytesWritten) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respond');
      }
      assertRequiredArgument(bytesWritten, 1, 'respond');
      bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }
      if (IsDetachedBuffer(this._view.buffer)) ;
      ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
    }
    respondWithNewView(view) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respondWithNewView');
      }
      assertRequiredArgument(view, 1, 'respondWithNewView');
      if (!ArrayBuffer.isView(view)) {
        throw new TypeError('You can only respond with array buffer views');
      }
      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }
      if (IsDetachedBuffer(view.buffer)) ;
      ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
    }
  }
  Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
    respond: {
      enumerable: true
    },
    respondWithNewView: {
      enumerable: true
    },
    view: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBRequest',
      configurable: true
    });
  }
  /**
   * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
   *
   * @public
   */
  class ReadableByteStreamController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the current BYOB pull request, or `null` if there isn't one.
     */
    get byobRequest() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('byobRequest');
      }
      return ReadableByteStreamControllerGetBYOBRequest(this);
    }
    /**
     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
     */
    get desiredSize() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('desiredSize');
      }
      return ReadableByteStreamControllerGetDesiredSize(this);
    }
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */
    close() {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('close');
      }
      if (this._closeRequested) {
        throw new TypeError('The stream has already been closed; do not close it again!');
      }
      const state = this._controlledReadableByteStream._state;
      if (state !== 'readable') {
        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
      }
      ReadableByteStreamControllerClose(this);
    }
    enqueue(chunk) {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('enqueue');
      }
      assertRequiredArgument(chunk, 1, 'enqueue');
      if (!ArrayBuffer.isView(chunk)) {
        throw new TypeError('chunk must be an array buffer view');
      }
      if (chunk.byteLength === 0) {
        throw new TypeError('chunk must have non-zero byteLength');
      }
      if (chunk.buffer.byteLength === 0) {
        throw new TypeError(`chunk's buffer must have non-zero byteLength`);
      }
      if (this._closeRequested) {
        throw new TypeError('stream is closed or draining');
      }
      const state = this._controlledReadableByteStream._state;
      if (state !== 'readable') {
        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
      }
      ReadableByteStreamControllerEnqueue(this, chunk);
    }
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */
    error(e = undefined) {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('error');
      }
      ReadableByteStreamControllerError(this, e);
    }
    /** @internal */
    [CancelSteps](reason) {
      ReadableByteStreamControllerClearPendingPullIntos(this);
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      ReadableByteStreamControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [PullSteps](readRequest) {
      const stream = this._controlledReadableByteStream;
      if (this._queueTotalSize > 0) {
        const entry = this._queue.shift();
        this._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(this);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
        return;
      }
      const autoAllocateChunkSize = this._autoAllocateChunkSize;
      if (autoAllocateChunkSize !== undefined) {
        let buffer;
        try {
          buffer = new ArrayBuffer(autoAllocateChunkSize);
        } catch (bufferE) {
          readRequest._errorSteps(bufferE);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: autoAllocateChunkSize,
          byteOffset: 0,
          byteLength: autoAllocateChunkSize,
          bytesFilled: 0,
          elementSize: 1,
          viewConstructor: Uint8Array,
          readerType: 'default'
        };
        this._pendingPullIntos.push(pullIntoDescriptor);
      }
      ReadableStreamAddReadRequest(stream, readRequest);
      ReadableByteStreamControllerCallPullIfNeeded(this);
    }
  }
  Object.defineProperties(ReadableByteStreamController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    byobRequest: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableByteStreamController',
      configurable: true
    });
  }
  // Abstract operations for the ReadableByteStreamController.
  function IsReadableByteStreamController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
      return false;
    }
    return x instanceof ReadableByteStreamController;
  }
  function IsReadableStreamBYOBRequest(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
      return false;
    }
    return x instanceof ReadableStreamBYOBRequest;
  }
  function ReadableByteStreamControllerCallPullIfNeeded(controller) {
    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
    if (!shouldPull) {
      return;
    }
    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }
    controller._pulling = true;
    // TODO: Test controller argument
    const pullPromise = controller._pullAlgorithm();
    uponPromise(pullPromise, () => {
      controller._pulling = false;
      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }, e => {
      ReadableByteStreamControllerError(controller, e);
    });
  }
  function ReadableByteStreamControllerClearPendingPullIntos(controller) {
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    controller._pendingPullIntos = new SimpleQueue();
  }
  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
    let done = false;
    if (stream._state === 'closed') {
      done = true;
    }
    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
    if (pullIntoDescriptor.readerType === 'default') {
      ReadableStreamFulfillReadRequest(stream, filledView, done);
    } else {
      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
    }
  }
  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
    const bytesFilled = pullIntoDescriptor.bytesFilled;
    const elementSize = pullIntoDescriptor.elementSize;
    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
  }
  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
    controller._queue.push({
      buffer,
      byteOffset,
      byteLength
    });
    controller._queueTotalSize += byteLength;
  }
  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
    const elementSize = pullIntoDescriptor.elementSize;
    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
    let totalBytesToCopyRemaining = maxBytesToCopy;
    let ready = false;
    if (maxAlignedBytes > currentAlignedBytes) {
      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
      ready = true;
    }
    const queue = controller._queue;
    while (totalBytesToCopyRemaining > 0) {
      const headOfQueue = queue.peek();
      const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
      const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
      if (headOfQueue.byteLength === bytesToCopy) {
        queue.shift();
      } else {
        headOfQueue.byteOffset += bytesToCopy;
        headOfQueue.byteLength -= bytesToCopy;
      }
      controller._queueTotalSize -= bytesToCopy;
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
      totalBytesToCopyRemaining -= bytesToCopy;
    }
    return ready;
  }
  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
    pullIntoDescriptor.bytesFilled += size;
  }
  function ReadableByteStreamControllerHandleQueueDrain(controller) {
    if (controller._queueTotalSize === 0 && controller._closeRequested) {
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(controller._controlledReadableByteStream);
    } else {
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }
  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
    if (controller._byobRequest === null) {
      return;
    }
    controller._byobRequest._associatedReadableByteStreamController = undefined;
    controller._byobRequest._view = null;
    controller._byobRequest = null;
  }
  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
    while (controller._pendingPullIntos.length > 0) {
      if (controller._queueTotalSize === 0) {
        return;
      }
      const pullIntoDescriptor = controller._pendingPullIntos.peek();
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      }
    }
  }
  function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
    const stream = controller._controlledReadableByteStream;
    let elementSize = 1;
    if (view.constructor !== DataView) {
      elementSize = view.constructor.BYTES_PER_ELEMENT;
    }
    const ctor = view.constructor;
    // try {
    const buffer = TransferArrayBuffer(view.buffer);
    // } catch (e) {
    //   readIntoRequest._errorSteps(e);
    //   return;
    // }
    const pullIntoDescriptor = {
      buffer,
      bufferByteLength: buffer.byteLength,
      byteOffset: view.byteOffset,
      byteLength: view.byteLength,
      bytesFilled: 0,
      elementSize,
      viewConstructor: ctor,
      readerType: 'byob'
    };
    if (controller._pendingPullIntos.length > 0) {
      controller._pendingPullIntos.push(pullIntoDescriptor);
      // No ReadableByteStreamControllerCallPullIfNeeded() call since:
      // - No change happens on desiredSize
      // - The source has already been notified of that there's at least 1 pending read(view)
      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      return;
    }
    if (stream._state === 'closed') {
      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
      readIntoRequest._closeSteps(emptyView);
      return;
    }
    if (controller._queueTotalSize > 0) {
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        ReadableByteStreamControllerHandleQueueDrain(controller);
        readIntoRequest._chunkSteps(filledView);
        return;
      }
      if (controller._closeRequested) {
        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        readIntoRequest._errorSteps(e);
        return;
      }
    }
    controller._pendingPullIntos.push(pullIntoDescriptor);
    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
    const stream = controller._controlledReadableByteStream;
    if (ReadableStreamHasBYOBReader(stream)) {
      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
      }
    }
  }
  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
      return;
    }
    ReadableByteStreamControllerShiftPendingPullInto(controller);
    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
    if (remainderSize > 0) {
      const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
    }
    pullIntoDescriptor.bytesFilled -= remainderSize;
    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  }
  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      ReadableByteStreamControllerRespondInClosedState(controller);
    } else {
      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
    }
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerShiftPendingPullInto(controller) {
    const descriptor = controller._pendingPullIntos.shift();
    return descriptor;
  }
  function ReadableByteStreamControllerShouldCallPull(controller) {
    const stream = controller._controlledReadableByteStream;
    if (stream._state !== 'readable') {
      return false;
    }
    if (controller._closeRequested) {
      return false;
    }
    if (!controller._started) {
      return false;
    }
    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }
    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      return true;
    }
    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
    if (desiredSize > 0) {
      return true;
    }
    return false;
  }
  function ReadableByteStreamControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
  }
  // A client of ReadableByteStreamController may use these functions directly to bypass state check.
  function ReadableByteStreamControllerClose(controller) {
    const stream = controller._controlledReadableByteStream;
    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }
    if (controller._queueTotalSize > 0) {
      controller._closeRequested = true;
      return;
    }
    if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      if (firstPendingPullInto.bytesFilled > 0) {
        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        throw e;
      }
    }
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }
  function ReadableByteStreamControllerEnqueue(controller, chunk) {
    const stream = controller._controlledReadableByteStream;
    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }
    const buffer = chunk.buffer;
    const byteOffset = chunk.byteOffset;
    const byteLength = chunk.byteLength;
    const transferredBuffer = TransferArrayBuffer(buffer);
    if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
    }
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    if (ReadableStreamHasDefaultReader(stream)) {
      if (ReadableStreamGetNumReadRequests(stream) === 0) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      } else {
        if (controller._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
        ReadableStreamFulfillReadRequest(stream, transferredView, false);
      }
    } else if (ReadableStreamHasBYOBReader(stream)) {
      // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    } else {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    }
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
  function ReadableByteStreamControllerError(controller, e) {
    const stream = controller._controlledReadableByteStream;
    if (stream._state !== 'readable') {
      return;
    }
    ReadableByteStreamControllerClearPendingPullIntos(controller);
    ResetQueue(controller);
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }
  function ReadableByteStreamControllerGetBYOBRequest(controller) {
    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
      SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
      controller._byobRequest = byobRequest;
    }
    return controller._byobRequest;
  }
  function ReadableByteStreamControllerGetDesiredSize(controller) {
    const state = controller._controlledReadableByteStream._state;
    if (state === 'errored') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return controller._strategyHWM - controller._queueTotalSize;
  }
  function ReadableByteStreamControllerRespond(controller, bytesWritten) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      if (bytesWritten !== 0) {
        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
      }
    } else {
      if (bytesWritten === 0) {
        throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
      }
      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
        throw new RangeError('bytesWritten out of range');
      }
    }
    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
  }
  function ReadableByteStreamControllerRespondWithNewView(controller, view) {
    const firstDescriptor = controller._pendingPullIntos.peek();
    const state = controller._controlledReadableByteStream._state;
    if (state === 'closed') {
      if (view.byteLength !== 0) {
        throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
      }
    } else {
      if (view.byteLength === 0) {
        throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
      }
    }
    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
      throw new RangeError('The region specified by view does not match byobRequest');
    }
    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
      throw new RangeError('The buffer of view has different capacity than byobRequest');
    }
    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
      throw new RangeError('The region specified by view is larger than byobRequest');
    }
    const viewByteLength = view.byteLength;
    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
  }
  function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
    controller._controlledReadableByteStream = stream;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._byobRequest = null;
    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
    controller._queue = controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._closeRequested = false;
    controller._started = false;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    controller._autoAllocateChunkSize = autoAllocateChunkSize;
    controller._pendingPullIntos = new SimpleQueue();
    stream._readableStreamController = controller;
    const startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), () => {
      controller._started = true;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }, r => {
      ReadableByteStreamControllerError(controller, r);
    });
  }
  function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
    const controller = Object.create(ReadableByteStreamController.prototype);
    let startAlgorithm = () => undefined;
    let pullAlgorithm = () => promiseResolvedWith(undefined);
    let cancelAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingByteSource.start !== undefined) {
      startAlgorithm = () => underlyingByteSource.start(controller);
    }
    if (underlyingByteSource.pull !== undefined) {
      pullAlgorithm = () => underlyingByteSource.pull(controller);
    }
    if (underlyingByteSource.cancel !== undefined) {
      cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
    }
    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
    if (autoAllocateChunkSize === 0) {
      throw new TypeError('autoAllocateChunkSize must be greater than 0');
    }
    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
  }
  function SetUpReadableStreamBYOBRequest(request, controller, view) {
    request._associatedReadableByteStreamController = controller;
    request._view = view;
  }
  // Helper functions for the ReadableStreamBYOBRequest.
  function byobRequestBrandCheckException(name) {
    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
  }
  // Helper functions for the ReadableByteStreamController.
  function byteStreamControllerBrandCheckException(name) {
    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
  }

  // Abstract operations for the ReadableStream.
  function AcquireReadableStreamBYOBReader(stream) {
    return new ReadableStreamBYOBReader(stream);
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
    stream._reader._readIntoRequests.push(readIntoRequest);
  }
  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
    const reader = stream._reader;
    const readIntoRequest = reader._readIntoRequests.shift();
    if (done) {
      readIntoRequest._closeSteps(chunk);
    } else {
      readIntoRequest._chunkSteps(chunk);
    }
  }
  function ReadableStreamGetNumReadIntoRequests(stream) {
    return stream._reader._readIntoRequests.length;
  }
  function ReadableStreamHasBYOBReader(stream) {
    const reader = stream._reader;
    if (reader === undefined) {
      return false;
    }
    if (!IsReadableStreamBYOBReader(reader)) {
      return false;
    }
    return true;
  }
  /**
   * A BYOB reader vended by a {@link ReadableStream}.
   *
   * @public
   */
  class ReadableStreamBYOBReader {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
      assertReadableStream(stream, 'First parameter');
      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }
      if (!IsReadableByteStreamController(stream._readableStreamController)) {
        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
      }
      ReadableStreamReaderGenericInitialize(this, stream);
      this._readIntoRequests = new SimpleQueue();
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
     * the reader's lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */
    cancel(reason = undefined) {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
      }
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }
      return ReadableStreamReaderGenericCancel(this, reason);
    }
    /**
     * Attempts to reads bytes into view, and returns a promise resolved with the result.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */
    read(view) {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('read'));
      }
      if (!ArrayBuffer.isView(view)) {
        return promiseRejectedWith(new TypeError('view must be an array buffer view'));
      }
      if (view.byteLength === 0) {
        return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
      }
      if (view.buffer.byteLength === 0) {
        return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
      }
      if (IsDetachedBuffer(view.buffer)) ;
      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }
      let resolvePromise;
      let rejectPromise;
      const promise = newPromise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      const readIntoRequest = {
        _chunkSteps: chunk => resolvePromise({
          value: chunk,
          done: false
        }),
        _closeSteps: chunk => resolvePromise({
          value: chunk,
          done: true
        }),
        _errorSteps: e => rejectPromise(e)
      };
      ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
      return promise;
    }
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */
    releaseLock() {
      if (!IsReadableStreamBYOBReader(this)) {
        throw byobReaderBrandCheckException('releaseLock');
      }
      if (this._ownerReadableStream === undefined) {
        return;
      }
      if (this._readIntoRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }
      ReadableStreamReaderGenericRelease(this);
    }
  }
  Object.defineProperties(ReadableStreamBYOBReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBReader',
      configurable: true
    });
  }
  // Abstract operations for the readers.
  function IsReadableStreamBYOBReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
      return false;
    }
    return x instanceof ReadableStreamBYOBReader;
  }
  function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
    const stream = reader._ownerReadableStream;
    stream._disturbed = true;
    if (stream._state === 'errored') {
      readIntoRequest._errorSteps(stream._storedError);
    } else {
      ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
    }
  }
  // Helper functions for the ReadableStreamBYOBReader.
  function byobReaderBrandCheckException(name) {
    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
  }
  function ExtractHighWaterMark(strategy, defaultHWM) {
    const {
      highWaterMark
    } = strategy;
    if (highWaterMark === undefined) {
      return defaultHWM;
    }
    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
      throw new RangeError('Invalid highWaterMark');
    }
    return highWaterMark;
  }
  function ExtractSizeAlgorithm(strategy) {
    const {
      size
    } = strategy;
    if (!size) {
      return () => 1;
    }
    return size;
  }
  function convertQueuingStrategy(init, context) {
    assertDictionary(init, context);
    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    const size = init === null || init === void 0 ? void 0 : init.size;
    return {
      highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
      size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
    };
  }
  function convertQueuingStrategySize(fn, context) {
    assertFunction(fn, context);
    return chunk => convertUnrestrictedDouble(fn(chunk));
  }
  function convertUnderlyingSink(original, context) {
    assertDictionary(original, context);
    const abort = original === null || original === void 0 ? void 0 : original.abort;
    const close = original === null || original === void 0 ? void 0 : original.close;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const type = original === null || original === void 0 ? void 0 : original.type;
    const write = original === null || original === void 0 ? void 0 : original.write;
    return {
      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
      write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
      type
    };
  }
  function convertUnderlyingSinkAbortCallback(fn, original, context) {
    assertFunction(fn, context);
    return reason => promiseCall(fn, original, [reason]);
  }
  function convertUnderlyingSinkCloseCallback(fn, original, context) {
    assertFunction(fn, context);
    return () => promiseCall(fn, original, []);
  }
  function convertUnderlyingSinkStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertUnderlyingSinkWriteCallback(fn, original, context) {
    assertFunction(fn, context);
    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  }
  function assertWritableStream(x, context) {
    if (!IsWritableStream(x)) {
      throw new TypeError(`${context} is not a WritableStream.`);
    }
  }
  function isAbortSignal(value) {
    if (typeof value !== 'object' || value === null) {
      return false;
    }
    try {
      return typeof value.aborted === 'boolean';
    } catch (_a) {
      // AbortSignal.prototype.aborted throws if its brand check fails
      return false;
    }
  }
  const supportsAbortController = typeof AbortController === 'function';
  /**
   * Construct a new AbortController, if supported by the platform.
   *
   * @internal
   */
  function createAbortController() {
    if (supportsAbortController) {
      return new AbortController();
    }
    return undefined;
  }

  /**
   * A writable stream represents a destination for data, into which you can write.
   *
   * @public
   */
  class WritableStream {
    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
      if (rawUnderlyingSink === undefined) {
        rawUnderlyingSink = null;
      } else {
        assertObject(rawUnderlyingSink, 'First parameter');
      }
      const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
      InitializeWritableStream(this);
      const type = underlyingSink.type;
      if (type !== undefined) {
        throw new RangeError('Invalid type is specified');
      }
      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
      const highWaterMark = ExtractHighWaterMark(strategy, 1);
      SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
    }
    /**
     * Returns whether or not the writable stream is locked to a writer.
     */
    get locked() {
      if (!IsWritableStream(this)) {
        throw streamBrandCheckException$2('locked');
      }
      return IsWritableStreamLocked(this);
    }
    /**
     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
     * mechanism of the underlying sink.
     *
     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
     * the stream) if the stream is currently locked.
     */
    abort(reason = undefined) {
      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('abort'));
      }
      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
      }
      return WritableStreamAbort(this, reason);
    }
    /**
     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
     * close behavior. During this time any further attempts to write will fail (without erroring the stream).
     *
     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
     */
    close() {
      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('close'));
      }
      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
      }
      if (WritableStreamCloseQueuedOrInFlight(this)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }
      return WritableStreamClose(this);
    }
    /**
     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
     * is locked, no other writer can be acquired until this one is released.
     *
     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
     * the same time, which would cause the resulting written data to be unpredictable and probably useless.
     */
    getWriter() {
      if (!IsWritableStream(this)) {
        throw streamBrandCheckException$2('getWriter');
      }
      return AcquireWritableStreamDefaultWriter(this);
    }
  }
  Object.defineProperties(WritableStream.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    getWriter: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStream',
      configurable: true
    });
  }
  // Abstract operations for the WritableStream.
  function AcquireWritableStreamDefaultWriter(stream) {
    return new WritableStreamDefaultWriter(stream);
  }
  // Throws if and only if startAlgorithm throws.
  function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
    const stream = Object.create(WritableStream.prototype);
    InitializeWritableStream(stream);
    const controller = Object.create(WritableStreamDefaultController.prototype);
    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  }
  function InitializeWritableStream(stream) {
    stream._state = 'writable';
    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
    // 'erroring' or 'errored'. May be set to an undefined value.
    stream._storedError = undefined;
    stream._writer = undefined;
    // Initialize to undefined first because the constructor of the controller checks this
    // variable to validate the caller.
    stream._writableStreamController = undefined;
    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
    // producer without waiting for the queued writes to finish.
    stream._writeRequests = new SimpleQueue();
    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
    stream._inFlightWriteRequest = undefined;
    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
    // has been detached.
    stream._closeRequest = undefined;
    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
    stream._inFlightCloseRequest = undefined;
    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
    stream._pendingAbortRequest = undefined;
    // The backpressure signal set by the controller.
    stream._backpressure = false;
  }
  function IsWritableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
      return false;
    }
    return x instanceof WritableStream;
  }
  function IsWritableStreamLocked(stream) {
    if (stream._writer === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamAbort(stream, reason) {
    var _a;
    if (stream._state === 'closed' || stream._state === 'errored') {
      return promiseResolvedWith(undefined);
    }
    stream._writableStreamController._abortReason = reason;
    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
    // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
    // but it doesn't know that signaling abort runs author code that might have changed the state.
    // Widen the type again by casting to WritableStreamState.
    const state = stream._state;
    if (state === 'closed' || state === 'errored') {
      return promiseResolvedWith(undefined);
    }
    if (stream._pendingAbortRequest !== undefined) {
      return stream._pendingAbortRequest._promise;
    }
    let wasAlreadyErroring = false;
    if (state === 'erroring') {
      wasAlreadyErroring = true;
      // reason will not be used, so don't keep a reference to it.
      reason = undefined;
    }
    const promise = newPromise((resolve, reject) => {
      stream._pendingAbortRequest = {
        _promise: undefined,
        _resolve: resolve,
        _reject: reject,
        _reason: reason,
        _wasAlreadyErroring: wasAlreadyErroring
      };
    });
    stream._pendingAbortRequest._promise = promise;
    if (!wasAlreadyErroring) {
      WritableStreamStartErroring(stream, reason);
    }
    return promise;
  }
  function WritableStreamClose(stream) {
    const state = stream._state;
    if (state === 'closed' || state === 'errored') {
      return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
    }
    const promise = newPromise((resolve, reject) => {
      const closeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._closeRequest = closeRequest;
    });
    const writer = stream._writer;
    if (writer !== undefined && stream._backpressure && state === 'writable') {
      defaultWriterReadyPromiseResolve(writer);
    }
    WritableStreamDefaultControllerClose(stream._writableStreamController);
    return promise;
  }
  // WritableStream API exposed for controllers.
  function WritableStreamAddWriteRequest(stream) {
    const promise = newPromise((resolve, reject) => {
      const writeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._writeRequests.push(writeRequest);
    });
    return promise;
  }
  function WritableStreamDealWithRejection(stream, error) {
    const state = stream._state;
    if (state === 'writable') {
      WritableStreamStartErroring(stream, error);
      return;
    }
    WritableStreamFinishErroring(stream);
  }
  function WritableStreamStartErroring(stream, reason) {
    const controller = stream._writableStreamController;
    stream._state = 'erroring';
    stream._storedError = reason;
    const writer = stream._writer;
    if (writer !== undefined) {
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
    }
    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
      WritableStreamFinishErroring(stream);
    }
  }
  function WritableStreamFinishErroring(stream) {
    stream._state = 'errored';
    stream._writableStreamController[ErrorSteps]();
    const storedError = stream._storedError;
    stream._writeRequests.forEach(writeRequest => {
      writeRequest._reject(storedError);
    });
    stream._writeRequests = new SimpleQueue();
    if (stream._pendingAbortRequest === undefined) {
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const abortRequest = stream._pendingAbortRequest;
    stream._pendingAbortRequest = undefined;
    if (abortRequest._wasAlreadyErroring) {
      abortRequest._reject(storedError);
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
    uponPromise(promise, () => {
      abortRequest._resolve();
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    }, reason => {
      abortRequest._reject(reason);
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    });
  }
  function WritableStreamFinishInFlightWrite(stream) {
    stream._inFlightWriteRequest._resolve(undefined);
    stream._inFlightWriteRequest = undefined;
  }
  function WritableStreamFinishInFlightWriteWithError(stream, error) {
    stream._inFlightWriteRequest._reject(error);
    stream._inFlightWriteRequest = undefined;
    WritableStreamDealWithRejection(stream, error);
  }
  function WritableStreamFinishInFlightClose(stream) {
    stream._inFlightCloseRequest._resolve(undefined);
    stream._inFlightCloseRequest = undefined;
    const state = stream._state;
    if (state === 'erroring') {
      // The error was too late to do anything, so it is ignored.
      stream._storedError = undefined;
      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._resolve();
        stream._pendingAbortRequest = undefined;
      }
    }
    stream._state = 'closed';
    const writer = stream._writer;
    if (writer !== undefined) {
      defaultWriterClosedPromiseResolve(writer);
    }
  }
  function WritableStreamFinishInFlightCloseWithError(stream, error) {
    stream._inFlightCloseRequest._reject(error);
    stream._inFlightCloseRequest = undefined;
    // Never execute sink abort() after sink close().
    if (stream._pendingAbortRequest !== undefined) {
      stream._pendingAbortRequest._reject(error);
      stream._pendingAbortRequest = undefined;
    }
    WritableStreamDealWithRejection(stream, error);
  }
  // TODO(ricea): Fix alphabetical order.
  function WritableStreamCloseQueuedOrInFlight(stream) {
    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamHasOperationMarkedInFlight(stream) {
    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }
    return true;
  }
  function WritableStreamMarkCloseRequestInFlight(stream) {
    stream._inFlightCloseRequest = stream._closeRequest;
    stream._closeRequest = undefined;
  }
  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
    stream._inFlightWriteRequest = stream._writeRequests.shift();
  }
  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
    if (stream._closeRequest !== undefined) {
      stream._closeRequest._reject(stream._storedError);
      stream._closeRequest = undefined;
    }
    const writer = stream._writer;
    if (writer !== undefined) {
      defaultWriterClosedPromiseReject(writer, stream._storedError);
    }
  }
  function WritableStreamUpdateBackpressure(stream, backpressure) {
    const writer = stream._writer;
    if (writer !== undefined && backpressure !== stream._backpressure) {
      if (backpressure) {
        defaultWriterReadyPromiseReset(writer);
      } else {
        defaultWriterReadyPromiseResolve(writer);
      }
    }
    stream._backpressure = backpressure;
  }
  /**
   * A default writer vended by a {@link WritableStream}.
   *
   * @public
   */
  class WritableStreamDefaultWriter {
    constructor(stream) {
      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
      assertWritableStream(stream, 'First parameter');
      if (IsWritableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive writing by another writer');
      }
      this._ownerWritableStream = stream;
      stream._writer = this;
      const state = stream._state;
      if (state === 'writable') {
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
          defaultWriterReadyPromiseInitialize(this);
        } else {
          defaultWriterReadyPromiseInitializeAsResolved(this);
        }
        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'erroring') {
        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'closed') {
        defaultWriterReadyPromiseInitializeAsResolved(this);
        defaultWriterClosedPromiseInitializeAsResolved(this);
      } else {
        const storedError = stream._storedError;
        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
      }
    }
    /**
     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
     * the writer’s lock is released before the stream finishes closing.
     */
    get closed() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
      }
      return this._closedPromise;
    }
    /**
     * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
     * A producer can use this information to determine the right amount of data to write.
     *
     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
     * the writer’s lock is released.
     */
    get desiredSize() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw defaultWriterBrandCheckException('desiredSize');
      }
      if (this._ownerWritableStream === undefined) {
        throw defaultWriterLockException('desiredSize');
      }
      return WritableStreamDefaultWriterGetDesiredSize(this);
    }
    /**
     * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
     * back to zero or below, the getter will return a new promise that stays pending until the next transition.
     *
     * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
     * rejected.
     */
    get ready() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
      }
      return this._readyPromise;
    }
    /**
     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
     */
    abort(reason = undefined) {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
      }
      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('abort'));
      }
      return WritableStreamDefaultWriterAbort(this, reason);
    }
    /**
     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
     */
    close() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('close'));
      }
      const stream = this._ownerWritableStream;
      if (stream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('close'));
      }
      if (WritableStreamCloseQueuedOrInFlight(stream)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }
      return WritableStreamDefaultWriterClose(this);
    }
    /**
     * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
     * now on; otherwise, the writer will appear closed.
     *
     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
     * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
     * other producers from writing in an interleaved manner.
     */
    releaseLock() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw defaultWriterBrandCheckException('releaseLock');
      }
      const stream = this._ownerWritableStream;
      if (stream === undefined) {
        return;
      }
      WritableStreamDefaultWriterRelease(this);
    }
    write(chunk = undefined) {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('write'));
      }
      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('write to'));
      }
      return WritableStreamDefaultWriterWrite(this, chunk);
    }
  }
  Object.defineProperties(WritableStreamDefaultWriter.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    write: {
      enumerable: true
    },
    closed: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    },
    ready: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultWriter',
      configurable: true
    });
  }
  // Abstract operations for the WritableStreamDefaultWriter.
  function IsWritableStreamDefaultWriter(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
      return false;
    }
    return x instanceof WritableStreamDefaultWriter;
  }
  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
  function WritableStreamDefaultWriterAbort(writer, reason) {
    const stream = writer._ownerWritableStream;
    return WritableStreamAbort(stream, reason);
  }
  function WritableStreamDefaultWriterClose(writer) {
    const stream = writer._ownerWritableStream;
    return WritableStreamClose(stream);
  }
  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
    const stream = writer._ownerWritableStream;
    const state = stream._state;
    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseResolvedWith(undefined);
    }
    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    return WritableStreamDefaultWriterClose(writer);
  }
  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
    if (writer._closedPromiseState === 'pending') {
      defaultWriterClosedPromiseReject(writer, error);
    } else {
      defaultWriterClosedPromiseResetToRejected(writer, error);
    }
  }
  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
    if (writer._readyPromiseState === 'pending') {
      defaultWriterReadyPromiseReject(writer, error);
    } else {
      defaultWriterReadyPromiseResetToRejected(writer, error);
    }
  }
  function WritableStreamDefaultWriterGetDesiredSize(writer) {
    const stream = writer._ownerWritableStream;
    const state = stream._state;
    if (state === 'errored' || state === 'erroring') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
  }
  function WritableStreamDefaultWriterRelease(writer) {
    const stream = writer._ownerWritableStream;
    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
    // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
    // rejected until afterwards. This means that simply testing state will not work.
    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
    stream._writer = undefined;
    writer._ownerWritableStream = undefined;
  }
  function WritableStreamDefaultWriterWrite(writer, chunk) {
    const stream = writer._ownerWritableStream;
    const controller = stream._writableStreamController;
    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
    if (stream !== writer._ownerWritableStream) {
      return promiseRejectedWith(defaultWriterLockException('write to'));
    }
    const state = stream._state;
    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
    }
    if (state === 'erroring') {
      return promiseRejectedWith(stream._storedError);
    }
    const promise = WritableStreamAddWriteRequest(stream);
    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
    return promise;
  }
  const closeSentinel = {};
  /**
   * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
   *
   * @public
   */
  class WritableStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
     *
     * @deprecated
     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
     */
    get abortReason() {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('abortReason');
      }
      return this._abortReason;
    }
    /**
     * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
     */
    get signal() {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('signal');
      }
      if (this._abortController === undefined) {
        // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
        // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
        // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
        throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
      }
      return this._abortController.signal;
    }
    /**
     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
     *
     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
     * normal lifecycle of interactions with the underlying sink.
     */
    error(e = undefined) {
      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('error');
      }
      const state = this._controlledWritableStream._state;
      if (state !== 'writable') {
        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
        // just treat it as a no-op.
        return;
      }
      WritableStreamDefaultControllerError(this, e);
    }
    /** @internal */
    [AbortSteps](reason) {
      const result = this._abortAlgorithm(reason);
      WritableStreamDefaultControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [ErrorSteps]() {
      ResetQueue(this);
    }
  }
  Object.defineProperties(WritableStreamDefaultController.prototype, {
    abortReason: {
      enumerable: true
    },
    signal: {
      enumerable: true
    },
    error: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultController',
      configurable: true
    });
  }
  // Abstract operations implementing interface required by the WritableStream.
  function IsWritableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
      return false;
    }
    return x instanceof WritableStreamDefaultController;
  }
  function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledWritableStream = stream;
    stream._writableStreamController = controller;
    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._abortReason = undefined;
    controller._abortController = createAbortController();
    controller._started = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._writeAlgorithm = writeAlgorithm;
    controller._closeAlgorithm = closeAlgorithm;
    controller._abortAlgorithm = abortAlgorithm;
    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
    const startResult = startAlgorithm();
    const startPromise = promiseResolvedWith(startResult);
    uponPromise(startPromise, () => {
      controller._started = true;
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, r => {
      controller._started = true;
      WritableStreamDealWithRejection(stream, r);
    });
  }
  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
    const controller = Object.create(WritableStreamDefaultController.prototype);
    let startAlgorithm = () => undefined;
    let writeAlgorithm = () => promiseResolvedWith(undefined);
    let closeAlgorithm = () => promiseResolvedWith(undefined);
    let abortAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingSink.start !== undefined) {
      startAlgorithm = () => underlyingSink.start(controller);
    }
    if (underlyingSink.write !== undefined) {
      writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
    }
    if (underlyingSink.close !== undefined) {
      closeAlgorithm = () => underlyingSink.close();
    }
    if (underlyingSink.abort !== undefined) {
      abortAlgorithm = reason => underlyingSink.abort(reason);
    }
    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  }
  // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
  function WritableStreamDefaultControllerClearAlgorithms(controller) {
    controller._writeAlgorithm = undefined;
    controller._closeAlgorithm = undefined;
    controller._abortAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  }
  function WritableStreamDefaultControllerClose(controller) {
    EnqueueValueWithSize(controller, closeSentinel, 0);
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
    try {
      return controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
      return 1;
    }
  }
  function WritableStreamDefaultControllerGetDesiredSize(controller) {
    return controller._strategyHWM - controller._queueTotalSize;
  }
  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
    try {
      EnqueueValueWithSize(controller, chunk, chunkSize);
    } catch (enqueueE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      return;
    }
    const stream = controller._controlledWritableStream;
    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
      const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  // Abstract operations for the WritableStreamDefaultController.
  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
    const stream = controller._controlledWritableStream;
    if (!controller._started) {
      return;
    }
    if (stream._inFlightWriteRequest !== undefined) {
      return;
    }
    const state = stream._state;
    if (state === 'erroring') {
      WritableStreamFinishErroring(stream);
      return;
    }
    if (controller._queue.length === 0) {
      return;
    }
    const value = PeekQueueValue(controller);
    if (value === closeSentinel) {
      WritableStreamDefaultControllerProcessClose(controller);
    } else {
      WritableStreamDefaultControllerProcessWrite(controller, value);
    }
  }
  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
    if (controller._controlledWritableStream._state === 'writable') {
      WritableStreamDefaultControllerError(controller, error);
    }
  }
  function WritableStreamDefaultControllerProcessClose(controller) {
    const stream = controller._controlledWritableStream;
    WritableStreamMarkCloseRequestInFlight(stream);
    DequeueValue(controller);
    const sinkClosePromise = controller._closeAlgorithm();
    WritableStreamDefaultControllerClearAlgorithms(controller);
    uponPromise(sinkClosePromise, () => {
      WritableStreamFinishInFlightClose(stream);
    }, reason => {
      WritableStreamFinishInFlightCloseWithError(stream, reason);
    });
  }
  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
    const stream = controller._controlledWritableStream;
    WritableStreamMarkFirstWriteRequestInFlight(stream);
    const sinkWritePromise = controller._writeAlgorithm(chunk);
    uponPromise(sinkWritePromise, () => {
      WritableStreamFinishInFlightWrite(stream);
      const state = stream._state;
      DequeueValue(controller);
      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, reason => {
      if (stream._state === 'writable') {
        WritableStreamDefaultControllerClearAlgorithms(controller);
      }
      WritableStreamFinishInFlightWriteWithError(stream, reason);
    });
  }
  function WritableStreamDefaultControllerGetBackpressure(controller) {
    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
    return desiredSize <= 0;
  }
  // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
  function WritableStreamDefaultControllerError(controller, error) {
    const stream = controller._controlledWritableStream;
    WritableStreamDefaultControllerClearAlgorithms(controller);
    WritableStreamStartErroring(stream, error);
  }
  // Helper functions for the WritableStream.
  function streamBrandCheckException$2(name) {
    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
  }
  // Helper functions for the WritableStreamDefaultController.
  function defaultControllerBrandCheckException$2(name) {
    return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
  }
  // Helper functions for the WritableStreamDefaultWriter.
  function defaultWriterBrandCheckException(name) {
    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
  }
  function defaultWriterLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released writer');
  }
  function defaultWriterClosedPromiseInitialize(writer) {
    writer._closedPromise = newPromise((resolve, reject) => {
      writer._closedPromise_resolve = resolve;
      writer._closedPromise_reject = reject;
      writer._closedPromiseState = 'pending';
    });
  }
  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseReject(writer, reason);
  }
  function defaultWriterClosedPromiseInitializeAsResolved(writer) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseResolve(writer);
  }
  function defaultWriterClosedPromiseReject(writer, reason) {
    if (writer._closedPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(writer._closedPromise);
    writer._closedPromise_reject(reason);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'rejected';
  }
  function defaultWriterClosedPromiseResetToRejected(writer, reason) {
    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
  }
  function defaultWriterClosedPromiseResolve(writer) {
    if (writer._closedPromise_resolve === undefined) {
      return;
    }
    writer._closedPromise_resolve(undefined);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'resolved';
  }
  function defaultWriterReadyPromiseInitialize(writer) {
    writer._readyPromise = newPromise((resolve, reject) => {
      writer._readyPromise_resolve = resolve;
      writer._readyPromise_reject = reject;
    });
    writer._readyPromiseState = 'pending';
  }
  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseReject(writer, reason);
  }
  function defaultWriterReadyPromiseInitializeAsResolved(writer) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseResolve(writer);
  }
  function defaultWriterReadyPromiseReject(writer, reason) {
    if (writer._readyPromise_reject === undefined) {
      return;
    }
    setPromiseIsHandledToTrue(writer._readyPromise);
    writer._readyPromise_reject(reason);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'rejected';
  }
  function defaultWriterReadyPromiseReset(writer) {
    defaultWriterReadyPromiseInitialize(writer);
  }
  function defaultWriterReadyPromiseResetToRejected(writer, reason) {
    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
  }
  function defaultWriterReadyPromiseResolve(writer) {
    if (writer._readyPromise_resolve === undefined) {
      return;
    }
    writer._readyPromise_resolve(undefined);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'fulfilled';
  }

  /// <reference lib="dom" />
  const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;

  /// <reference types="node" />
  function isDOMExceptionConstructor(ctor) {
    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
      return false;
    }
    try {
      new ctor();
      return true;
    } catch (_a) {
      return false;
    }
  }
  function createDOMExceptionPolyfill() {
    // eslint-disable-next-line no-shadow
    const ctor = function DOMException(message, name) {
      this.message = message || '';
      this.name = name || 'Error';
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    };
    ctor.prototype = Object.create(Error.prototype);
    Object.defineProperty(ctor.prototype, 'constructor', {
      value: ctor,
      writable: true,
      configurable: true
    });
    return ctor;
  }
  // eslint-disable-next-line no-redeclare
  const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
    const reader = AcquireReadableStreamDefaultReader(source);
    const writer = AcquireWritableStreamDefaultWriter(dest);
    source._disturbed = true;
    let shuttingDown = false;
    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
    let currentWrite = promiseResolvedWith(undefined);
    return newPromise((resolve, reject) => {
      let abortAlgorithm;
      if (signal !== undefined) {
        abortAlgorithm = () => {
          const error = new DOMException$1('Aborted', 'AbortError');
          const actions = [];
          if (!preventAbort) {
            actions.push(() => {
              if (dest._state === 'writable') {
                return WritableStreamAbort(dest, error);
              }
              return promiseResolvedWith(undefined);
            });
          }
          if (!preventCancel) {
            actions.push(() => {
              if (source._state === 'readable') {
                return ReadableStreamCancel(source, error);
              }
              return promiseResolvedWith(undefined);
            });
          }
          shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
        };
        if (signal.aborted) {
          abortAlgorithm();
          return;
        }
        signal.addEventListener('abort', abortAlgorithm);
      }
      // Using reader and writer, read all chunks from this and write them to dest
      // - Backpressure must be enforced
      // - Shutdown must stop all activity
      function pipeLoop() {
        return newPromise((resolveLoop, rejectLoop) => {
          function next(done) {
            if (done) {
              resolveLoop();
            } else {
              // Use `PerformPromiseThen` instead of `uponPromise` to avoid
              // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
              PerformPromiseThen(pipeStep(), next, rejectLoop);
            }
          }
          next(false);
        });
      }
      function pipeStep() {
        if (shuttingDown) {
          return promiseResolvedWith(true);
        }
        return PerformPromiseThen(writer._readyPromise, () => {
          return newPromise((resolveRead, rejectRead) => {
            ReadableStreamDefaultReaderRead(reader, {
              _chunkSteps: chunk => {
                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                resolveRead(false);
              },
              _closeSteps: () => resolveRead(true),
              _errorSteps: rejectRead
            });
          });
        });
      }
      // Errors must be propagated forward
      isOrBecomesErrored(source, reader._closedPromise, storedError => {
        if (!preventAbort) {
          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
        } else {
          shutdown(true, storedError);
        }
      });
      // Errors must be propagated backward
      isOrBecomesErrored(dest, writer._closedPromise, storedError => {
        if (!preventCancel) {
          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
        } else {
          shutdown(true, storedError);
        }
      });
      // Closing must be propagated forward
      isOrBecomesClosed(source, reader._closedPromise, () => {
        if (!preventClose) {
          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
        } else {
          shutdown();
        }
      });
      // Closing must be propagated backward
      if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
        if (!preventCancel) {
          shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
        } else {
          shutdown(true, destClosed);
        }
      }
      setPromiseIsHandledToTrue(pipeLoop());
      function waitForWritesToFinish() {
        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
        // for that too.
        const oldCurrentWrite = currentWrite;
        return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
      }
      function isOrBecomesErrored(stream, promise, action) {
        if (stream._state === 'errored') {
          action(stream._storedError);
        } else {
          uponRejection(promise, action);
        }
      }
      function isOrBecomesClosed(stream, promise, action) {
        if (stream._state === 'closed') {
          action();
        } else {
          uponFulfillment(promise, action);
        }
      }
      function shutdownWithAction(action, originalIsError, originalError) {
        if (shuttingDown) {
          return;
        }
        shuttingDown = true;
        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), doTheRest);
        } else {
          doTheRest();
        }
        function doTheRest() {
          uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
        }
      }
      function shutdown(isError, error) {
        if (shuttingDown) {
          return;
        }
        shuttingDown = true;
        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
        } else {
          finalize(isError, error);
        }
      }
      function finalize(isError, error) {
        WritableStreamDefaultWriterRelease(writer);
        ReadableStreamReaderGenericRelease(reader);
        if (signal !== undefined) {
          signal.removeEventListener('abort', abortAlgorithm);
        }
        if (isError) {
          reject(error);
        } else {
          resolve(undefined);
        }
      }
    });
  }

  /**
   * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
   *
   * @public
   */
  class ReadableStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
     */
    get desiredSize() {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('desiredSize');
      }
      return ReadableStreamDefaultControllerGetDesiredSize(this);
    }
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */
    close() {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('close');
      }
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits close');
      }
      ReadableStreamDefaultControllerClose(this);
    }
    enqueue(chunk = undefined) {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('enqueue');
      }
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits enqueue');
      }
      return ReadableStreamDefaultControllerEnqueue(this, chunk);
    }
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */
    error(e = undefined) {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('error');
      }
      ReadableStreamDefaultControllerError(this, e);
    }
    /** @internal */
    [CancelSteps](reason) {
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      ReadableStreamDefaultControllerClearAlgorithms(this);
      return result;
    }
    /** @internal */
    [PullSteps](readRequest) {
      const stream = this._controlledReadableStream;
      if (this._queue.length > 0) {
        const chunk = DequeueValue(this);
        if (this._closeRequested && this._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(this);
          ReadableStreamClose(stream);
        } else {
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
        readRequest._chunkSteps(chunk);
      } else {
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableStreamDefaultControllerCallPullIfNeeded(this);
      }
    }
  }
  Object.defineProperties(ReadableStreamDefaultController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultController',
      configurable: true
    });
  }
  // Abstract operations for the ReadableStreamDefaultController.
  function IsReadableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
      return false;
    }
    return x instanceof ReadableStreamDefaultController;
  }
  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
    if (!shouldPull) {
      return;
    }
    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }
    controller._pulling = true;
    const pullPromise = controller._pullAlgorithm();
    uponPromise(pullPromise, () => {
      controller._pulling = false;
      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
    }, e => {
      ReadableStreamDefaultControllerError(controller, e);
    });
  }
  function ReadableStreamDefaultControllerShouldCallPull(controller) {
    const stream = controller._controlledReadableStream;
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return false;
    }
    if (!controller._started) {
      return false;
    }
    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }
    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
    if (desiredSize > 0) {
      return true;
    }
    return false;
  }
  function ReadableStreamDefaultControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  }
  // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
  function ReadableStreamDefaultControllerClose(controller) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }
    const stream = controller._controlledReadableStream;
    controller._closeRequested = true;
    if (controller._queue.length === 0) {
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
  }
  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }
    const stream = controller._controlledReadableStream;
    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      ReadableStreamFulfillReadRequest(stream, chunk, false);
    } else {
      let chunkSize;
      try {
        chunkSize = controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        ReadableStreamDefaultControllerError(controller, chunkSizeE);
        throw chunkSizeE;
      }
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        ReadableStreamDefaultControllerError(controller, enqueueE);
        throw enqueueE;
      }
    }
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }
  function ReadableStreamDefaultControllerError(controller, e) {
    const stream = controller._controlledReadableStream;
    if (stream._state !== 'readable') {
      return;
    }
    ResetQueue(controller);
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }
  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
    const state = controller._controlledReadableStream._state;
    if (state === 'errored') {
      return null;
    }
    if (state === 'closed') {
      return 0;
    }
    return controller._strategyHWM - controller._queueTotalSize;
  }
  // This is used in the implementation of TransformStream.
  function ReadableStreamDefaultControllerHasBackpressure(controller) {
    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
      return false;
    }
    return true;
  }
  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
    const state = controller._controlledReadableStream._state;
    if (!controller._closeRequested && state === 'readable') {
      return true;
    }
    return false;
  }
  function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledReadableStream = stream;
    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._started = false;
    controller._closeRequested = false;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    stream._readableStreamController = controller;
    const startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), () => {
      controller._started = true;
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }, r => {
      ReadableStreamDefaultControllerError(controller, r);
    });
  }
  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
    const controller = Object.create(ReadableStreamDefaultController.prototype);
    let startAlgorithm = () => undefined;
    let pullAlgorithm = () => promiseResolvedWith(undefined);
    let cancelAlgorithm = () => promiseResolvedWith(undefined);
    if (underlyingSource.start !== undefined) {
      startAlgorithm = () => underlyingSource.start(controller);
    }
    if (underlyingSource.pull !== undefined) {
      pullAlgorithm = () => underlyingSource.pull(controller);
    }
    if (underlyingSource.cancel !== undefined) {
      cancelAlgorithm = reason => underlyingSource.cancel(reason);
    }
    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  }
  // Helper functions for the ReadableStreamDefaultController.
  function defaultControllerBrandCheckException$1(name) {
    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
  }
  function ReadableStreamTee(stream, cloneForBranch2) {
    if (IsReadableByteStreamController(stream._readableStreamController)) {
      return ReadableByteStreamTee(stream);
    }
    return ReadableStreamDefaultTee(stream);
  }
  function ReadableStreamDefaultTee(stream, cloneForBranch2) {
    const reader = AcquireReadableStreamDefaultReader(stream);
    let reading = false;
    let readAgain = false;
    let canceled1 = false;
    let canceled2 = false;
    let reason1;
    let reason2;
    let branch1;
    let branch2;
    let resolveCancelPromise;
    const cancelPromise = newPromise(resolve => {
      resolveCancelPromise = resolve;
    });
    function pullAlgorithm() {
      if (reading) {
        readAgain = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const readRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgain = false;
            const chunk1 = chunk;
            const chunk2 = chunk;
            // There is no way to access the cloning code right now in the reference implementation.
            // If we add one then we'll need an implementation for serializable objects.
            // if (!canceled2 && cloneForBranch2) {
            //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
            // }
            if (!canceled1) {
              ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
            }
            if (!canceled2) {
              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
            }
            reading = false;
            if (readAgain) {
              pullAlgorithm();
            }
          });
        },
        _closeSteps: () => {
          reading = false;
          if (!canceled1) {
            ReadableStreamDefaultControllerClose(branch1._readableStreamController);
          }
          if (!canceled2) {
            ReadableStreamDefaultControllerClose(branch2._readableStreamController);
          }
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promiseResolvedWith(undefined);
    }
    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;
      if (canceled2) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;
      if (canceled1) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function startAlgorithm() {
      // do nothing
    }
    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
    uponRejection(reader._closedPromise, r => {
      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
      if (!canceled1 || !canceled2) {
        resolveCancelPromise(undefined);
      }
    });
    return [branch1, branch2];
  }
  function ReadableByteStreamTee(stream) {
    let reader = AcquireReadableStreamDefaultReader(stream);
    let reading = false;
    let readAgainForBranch1 = false;
    let readAgainForBranch2 = false;
    let canceled1 = false;
    let canceled2 = false;
    let reason1;
    let reason2;
    let branch1;
    let branch2;
    let resolveCancelPromise;
    const cancelPromise = newPromise(resolve => {
      resolveCancelPromise = resolve;
    });
    function forwardReaderError(thisReader) {
      uponRejection(thisReader._closedPromise, r => {
        if (thisReader !== reader) {
          return;
        }
        ReadableByteStreamControllerError(branch1._readableStreamController, r);
        ReadableByteStreamControllerError(branch2._readableStreamController, r);
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
      });
    }
    function pullWithDefaultReader() {
      if (IsReadableStreamBYOBReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamDefaultReader(stream);
        forwardReaderError(reader);
      }
      const readRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            const chunk1 = chunk;
            let chunk2 = chunk;
            if (!canceled1 && !canceled2) {
              try {
                chunk2 = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }
            }
            if (!canceled1) {
              ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
            }
            if (!canceled2) {
              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
            }
            reading = false;
            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: () => {
          reading = false;
          if (!canceled1) {
            ReadableByteStreamControllerClose(branch1._readableStreamController);
          }
          if (!canceled2) {
            ReadableByteStreamControllerClose(branch2._readableStreamController);
          }
          if (branch1._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
          }
          if (branch2._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
          }
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
    }
    function pullWithBYOBReader(view, forBranch2) {
      if (IsReadableStreamDefaultReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamBYOBReader(stream);
        forwardReaderError(reader);
      }
      const byobBranch = forBranch2 ? branch2 : branch1;
      const otherBranch = forBranch2 ? branch1 : branch2;
      const readIntoRequest = {
        _chunkSteps: chunk => {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(() => {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            const byobCanceled = forBranch2 ? canceled2 : canceled1;
            const otherCanceled = forBranch2 ? canceled1 : canceled2;
            if (!otherCanceled) {
              let clonedChunk;
              try {
                clonedChunk = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }
              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
            } else if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            reading = false;
            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: chunk => {
          reading = false;
          const byobCanceled = forBranch2 ? canceled2 : canceled1;
          const otherCanceled = forBranch2 ? canceled1 : canceled2;
          if (!byobCanceled) {
            ReadableByteStreamControllerClose(byobBranch._readableStreamController);
          }
          if (!otherCanceled) {
            ReadableByteStreamControllerClose(otherBranch._readableStreamController);
          }
          if (chunk !== undefined) {
            if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
            }
          }
          if (!byobCanceled || !otherCanceled) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: () => {
          reading = false;
        }
      };
      ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
    }
    function pull1Algorithm() {
      if (reading) {
        readAgainForBranch1 = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, false);
      }
      return promiseResolvedWith(undefined);
    }
    function pull2Algorithm() {
      if (reading) {
        readAgainForBranch2 = true;
        return promiseResolvedWith(undefined);
      }
      reading = true;
      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, true);
      }
      return promiseResolvedWith(undefined);
    }
    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;
      if (canceled2) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;
      if (canceled1) {
        const compositeReason = CreateArrayFromList([reason1, reason2]);
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }
      return cancelPromise;
    }
    function startAlgorithm() {
      return;
    }
    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
    forwardReaderError(reader);
    return [branch1, branch2];
  }
  function convertUnderlyingDefaultOrByteSource(source, context) {
    assertDictionary(source, context);
    const original = source;
    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
    const cancel = original === null || original === void 0 ? void 0 : original.cancel;
    const pull = original === null || original === void 0 ? void 0 : original.pull;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const type = original === null || original === void 0 ? void 0 : original.type;
    return {
      autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
      cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
      pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
      start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
      type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
    };
  }
  function convertUnderlyingSourceCancelCallback(fn, original, context) {
    assertFunction(fn, context);
    return reason => promiseCall(fn, original, [reason]);
  }
  function convertUnderlyingSourcePullCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => promiseCall(fn, original, [controller]);
  }
  function convertUnderlyingSourceStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertReadableStreamType(type, context) {
    type = `${type}`;
    if (type !== 'bytes') {
      throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
    }
    return type;
  }
  function convertReaderOptions(options, context) {
    assertDictionary(options, context);
    const mode = options === null || options === void 0 ? void 0 : options.mode;
    return {
      mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
    };
  }
  function convertReadableStreamReaderMode(mode, context) {
    mode = `${mode}`;
    if (mode !== 'byob') {
      throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
    }
    return mode;
  }
  function convertIteratorOptions(options, context) {
    assertDictionary(options, context);
    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    return {
      preventCancel: Boolean(preventCancel)
    };
  }
  function convertPipeOptions(options, context) {
    assertDictionary(options, context);
    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
    const signal = options === null || options === void 0 ? void 0 : options.signal;
    if (signal !== undefined) {
      assertAbortSignal(signal, `${context} has member 'signal' that`);
    }
    return {
      preventAbort: Boolean(preventAbort),
      preventCancel: Boolean(preventCancel),
      preventClose: Boolean(preventClose),
      signal
    };
  }
  function assertAbortSignal(signal, context) {
    if (!isAbortSignal(signal)) {
      throw new TypeError(`${context} is not an AbortSignal.`);
    }
  }
  function convertReadableWritablePair(pair, context) {
    assertDictionary(pair, context);
    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
    assertRequiredField(readable, 'readable', 'ReadableWritablePair');
    assertReadableStream(readable, `${context} has member 'readable' that`);
    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
    assertRequiredField(writable, 'writable', 'ReadableWritablePair');
    assertWritableStream(writable, `${context} has member 'writable' that`);
    return {
      readable,
      writable
    };
  }

  /**
   * A readable stream represents a source of data, from which you can read.
   *
   * @public
   */
  class ReadableStream {
    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
      if (rawUnderlyingSource === undefined) {
        rawUnderlyingSource = null;
      } else {
        assertObject(rawUnderlyingSource, 'First parameter');
      }
      const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
      InitializeReadableStream(this);
      if (underlyingSource.type === 'bytes') {
        if (strategy.size !== undefined) {
          throw new RangeError('The strategy for a byte stream cannot have a size function');
        }
        const highWaterMark = ExtractHighWaterMark(strategy, 0);
        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
      } else {
        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        const highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
      }
    }
    /**
     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
     */
    get locked() {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('locked');
      }
      return IsReadableStreamLocked(this);
    }
    /**
     * Cancels the stream, signaling a loss of interest in the stream by a consumer.
     *
     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
     * method, which might or might not use it.
     */
    cancel(reason = undefined) {
      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('cancel'));
      }
      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
      }
      return ReadableStreamCancel(this, reason);
    }
    getReader(rawOptions = undefined) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('getReader');
      }
      const options = convertReaderOptions(rawOptions, 'First parameter');
      if (options.mode === undefined) {
        return AcquireReadableStreamDefaultReader(this);
      }
      return AcquireReadableStreamBYOBReader(this);
    }
    pipeThrough(rawTransform, rawOptions = {}) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('pipeThrough');
      }
      assertRequiredArgument(rawTransform, 1, 'pipeThrough');
      const transform = convertReadableWritablePair(rawTransform, 'First parameter');
      const options = convertPipeOptions(rawOptions, 'Second parameter');
      if (IsReadableStreamLocked(this)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
      }
      if (IsWritableStreamLocked(transform.writable)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
      }
      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      setPromiseIsHandledToTrue(promise);
      return transform.readable;
    }
    pipeTo(destination, rawOptions = {}) {
      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
      }
      if (destination === undefined) {
        return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
      }
      if (!IsWritableStream(destination)) {
        return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
      }
      let options;
      try {
        options = convertPipeOptions(rawOptions, 'Second parameter');
      } catch (e) {
        return promiseRejectedWith(e);
      }
      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
      }
      if (IsWritableStreamLocked(destination)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
      }
      return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
    }
    /**
     * Tees this readable stream, returning a two-element array containing the two resulting branches as
     * new {@link ReadableStream} instances.
     *
     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
     * propagated to the stream's underlying source.
     *
     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
     * this could allow interference between the two branches.
     */
    tee() {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('tee');
      }
      const branches = ReadableStreamTee(this);
      return CreateArrayFromList(branches);
    }
    values(rawOptions = undefined) {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('values');
      }
      const options = convertIteratorOptions(rawOptions, 'First parameter');
      return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
    }
  }
  Object.defineProperties(ReadableStream.prototype, {
    cancel: {
      enumerable: true
    },
    getReader: {
      enumerable: true
    },
    pipeThrough: {
      enumerable: true
    },
    pipeTo: {
      enumerable: true
    },
    tee: {
      enumerable: true
    },
    values: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStream',
      configurable: true
    });
  }
  if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
      value: ReadableStream.prototype.values,
      writable: true,
      configurable: true
    });
  }
  // Abstract operations for the ReadableStream.
  // Throws if and only if startAlgorithm throws.
  function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
    const stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    const controller = Object.create(ReadableStreamDefaultController.prototype);
    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  }
  // Throws if and only if startAlgorithm throws.
  function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
    const stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    const controller = Object.create(ReadableByteStreamController.prototype);
    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
    return stream;
  }
  function InitializeReadableStream(stream) {
    stream._state = 'readable';
    stream._reader = undefined;
    stream._storedError = undefined;
    stream._disturbed = false;
  }
  function IsReadableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
      return false;
    }
    return x instanceof ReadableStream;
  }
  function IsReadableStreamLocked(stream) {
    if (stream._reader === undefined) {
      return false;
    }
    return true;
  }
  // ReadableStream API exposed for controllers.
  function ReadableStreamCancel(stream, reason) {
    stream._disturbed = true;
    if (stream._state === 'closed') {
      return promiseResolvedWith(undefined);
    }
    if (stream._state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }
    ReadableStreamClose(stream);
    const reader = stream._reader;
    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
      reader._readIntoRequests.forEach(readIntoRequest => {
        readIntoRequest._closeSteps(undefined);
      });
      reader._readIntoRequests = new SimpleQueue();
    }
    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
    return transformPromiseWith(sourceCancelPromise, noop);
  }
  function ReadableStreamClose(stream) {
    stream._state = 'closed';
    const reader = stream._reader;
    if (reader === undefined) {
      return;
    }
    defaultReaderClosedPromiseResolve(reader);
    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(readRequest => {
        readRequest._closeSteps();
      });
      reader._readRequests = new SimpleQueue();
    }
  }
  function ReadableStreamError(stream, e) {
    stream._state = 'errored';
    stream._storedError = e;
    const reader = stream._reader;
    if (reader === undefined) {
      return;
    }
    defaultReaderClosedPromiseReject(reader, e);
    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(readRequest => {
        readRequest._errorSteps(e);
      });
      reader._readRequests = new SimpleQueue();
    } else {
      reader._readIntoRequests.forEach(readIntoRequest => {
        readIntoRequest._errorSteps(e);
      });
      reader._readIntoRequests = new SimpleQueue();
    }
  }
  // Helper functions for the ReadableStream.
  function streamBrandCheckException$1(name) {
    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
  }
  function convertQueuingStrategyInit(init, context) {
    assertDictionary(init, context);
    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
    return {
      highWaterMark: convertUnrestrictedDouble(highWaterMark)
    };
  }

  // The size function must not have a prototype property nor be a constructor
  const byteLengthSizeFunction = chunk => {
    return chunk.byteLength;
  };
  try {
    Object.defineProperty(byteLengthSizeFunction, 'name', {
      value: 'size',
      configurable: true
    });
  } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  }
  /**
   * A queuing strategy that counts the number of bytes in each chunk.
   *
   * @public
   */
  class ByteLengthQueuingStrategy {
    constructor(options) {
      assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
    }
    /**
     * Returns the high water mark provided to the constructor.
     */
    get highWaterMark() {
      if (!IsByteLengthQueuingStrategy(this)) {
        throw byteLengthBrandCheckException('highWaterMark');
      }
      return this._byteLengthQueuingStrategyHighWaterMark;
    }
    /**
     * Measures the size of `chunk` by returning the value of its `byteLength` property.
     */
    get size() {
      if (!IsByteLengthQueuingStrategy(this)) {
        throw byteLengthBrandCheckException('size');
      }
      return byteLengthSizeFunction;
    }
  }
  Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'ByteLengthQueuingStrategy',
      configurable: true
    });
  }
  // Helper functions for the ByteLengthQueuingStrategy.
  function byteLengthBrandCheckException(name) {
    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
  }
  function IsByteLengthQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
      return false;
    }
    return x instanceof ByteLengthQueuingStrategy;
  }

  // The size function must not have a prototype property nor be a constructor
  const countSizeFunction = () => {
    return 1;
  };
  try {
    Object.defineProperty(countSizeFunction, 'name', {
      value: 'size',
      configurable: true
    });
  } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  }
  /**
   * A queuing strategy that counts the number of chunks.
   *
   * @public
   */
  class CountQueuingStrategy {
    constructor(options) {
      assertRequiredArgument(options, 1, 'CountQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._countQueuingStrategyHighWaterMark = options.highWaterMark;
    }
    /**
     * Returns the high water mark provided to the constructor.
     */
    get highWaterMark() {
      if (!IsCountQueuingStrategy(this)) {
        throw countBrandCheckException('highWaterMark');
      }
      return this._countQueuingStrategyHighWaterMark;
    }
    /**
     * Measures the size of `chunk` by always returning 1.
     * This ensures that the total queue size is a count of the number of chunks in the queue.
     */
    get size() {
      if (!IsCountQueuingStrategy(this)) {
        throw countBrandCheckException('size');
      }
      return countSizeFunction;
    }
  }
  Object.defineProperties(CountQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'CountQueuingStrategy',
      configurable: true
    });
  }
  // Helper functions for the CountQueuingStrategy.
  function countBrandCheckException(name) {
    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
  }
  function IsCountQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
      return false;
    }
    return x instanceof CountQueuingStrategy;
  }
  function convertTransformer(original, context) {
    assertDictionary(original, context);
    const flush = original === null || original === void 0 ? void 0 : original.flush;
    const readableType = original === null || original === void 0 ? void 0 : original.readableType;
    const start = original === null || original === void 0 ? void 0 : original.start;
    const transform = original === null || original === void 0 ? void 0 : original.transform;
    const writableType = original === null || original === void 0 ? void 0 : original.writableType;
    return {
      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
      readableType,
      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
      writableType
    };
  }
  function convertTransformerFlushCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => promiseCall(fn, original, [controller]);
  }
  function convertTransformerStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return controller => reflectCall(fn, original, [controller]);
  }
  function convertTransformerTransformCallback(fn, original, context) {
    assertFunction(fn, context);
    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  }

  // Class TransformStream
  /**
   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
   * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
   * In a manner specific to the transform stream in question, writes to the writable side result in new data being
   * made available for reading from the readable side.
   *
   * @public
   */
  class TransformStream {
    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
      if (rawTransformer === undefined) {
        rawTransformer = null;
      }
      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
      const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
      const transformer = convertTransformer(rawTransformer, 'First parameter');
      if (transformer.readableType !== undefined) {
        throw new RangeError('Invalid readableType specified');
      }
      if (transformer.writableType !== undefined) {
        throw new RangeError('Invalid writableType specified');
      }
      const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
      const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
      let startPromise_resolve;
      const startPromise = newPromise(resolve => {
        startPromise_resolve = resolve;
      });
      InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
      if (transformer.start !== undefined) {
        startPromise_resolve(transformer.start(this._transformStreamController));
      } else {
        startPromise_resolve(undefined);
      }
    }
    /**
     * The readable side of the transform stream.
     */
    get readable() {
      if (!IsTransformStream(this)) {
        throw streamBrandCheckException('readable');
      }
      return this._readable;
    }
    /**
     * The writable side of the transform stream.
     */
    get writable() {
      if (!IsTransformStream(this)) {
        throw streamBrandCheckException('writable');
      }
      return this._writable;
    }
  }
  Object.defineProperties(TransformStream.prototype, {
    readable: {
      enumerable: true
    },
    writable: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStream',
      configurable: true
    });
  }
  function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
    function startAlgorithm() {
      return startPromise;
    }
    function writeAlgorithm(chunk) {
      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
    }
    function abortAlgorithm(reason) {
      return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
    }
    function closeAlgorithm() {
      return TransformStreamDefaultSinkCloseAlgorithm(stream);
    }
    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
    function pullAlgorithm() {
      return TransformStreamDefaultSourcePullAlgorithm(stream);
    }
    function cancelAlgorithm(reason) {
      TransformStreamErrorWritableAndUnblockWrite(stream, reason);
      return promiseResolvedWith(undefined);
    }
    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
    stream._backpressure = undefined;
    stream._backpressureChangePromise = undefined;
    stream._backpressureChangePromise_resolve = undefined;
    TransformStreamSetBackpressure(stream, true);
    stream._transformStreamController = undefined;
  }
  function IsTransformStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
      return false;
    }
    return x instanceof TransformStream;
  }
  // This is a no-op if both sides are already errored.
  function TransformStreamError(stream, e) {
    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
  }
  function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
    if (stream._backpressure) {
      // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
      // _backpressure is set.
      TransformStreamSetBackpressure(stream, false);
    }
  }
  function TransformStreamSetBackpressure(stream, backpressure) {
    // Passes also when called during construction.
    if (stream._backpressureChangePromise !== undefined) {
      stream._backpressureChangePromise_resolve();
    }
    stream._backpressureChangePromise = newPromise(resolve => {
      stream._backpressureChangePromise_resolve = resolve;
    });
    stream._backpressure = backpressure;
  }
  // Class TransformStreamDefaultController
  /**
   * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
   *
   * @public
   */
  class TransformStreamDefaultController {
    constructor() {
      throw new TypeError('Illegal constructor');
    }
    /**
     * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
     */
    get desiredSize() {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('desiredSize');
      }
      const readableController = this._controlledTransformStream._readable._readableStreamController;
      return ReadableStreamDefaultControllerGetDesiredSize(readableController);
    }
    enqueue(chunk = undefined) {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('enqueue');
      }
      TransformStreamDefaultControllerEnqueue(this, chunk);
    }
    /**
     * Errors both the readable side and the writable side of the controlled transform stream, making all future
     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
     */
    error(reason = undefined) {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('error');
      }
      TransformStreamDefaultControllerError(this, reason);
    }
    /**
     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
     * transformer only needs to consume a portion of the chunks written to the writable side.
     */
    terminate() {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('terminate');
      }
      TransformStreamDefaultControllerTerminate(this);
    }
  }
  Object.defineProperties(TransformStreamDefaultController.prototype, {
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    terminate: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });
  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStreamDefaultController',
      configurable: true
    });
  }
  // Transform Stream Default Controller Abstract Operations
  function IsTransformStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }
    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
      return false;
    }
    return x instanceof TransformStreamDefaultController;
  }
  function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
    controller._controlledTransformStream = stream;
    stream._transformStreamController = controller;
    controller._transformAlgorithm = transformAlgorithm;
    controller._flushAlgorithm = flushAlgorithm;
  }
  function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
    const controller = Object.create(TransformStreamDefaultController.prototype);
    let transformAlgorithm = chunk => {
      try {
        TransformStreamDefaultControllerEnqueue(controller, chunk);
        return promiseResolvedWith(undefined);
      } catch (transformResultE) {
        return promiseRejectedWith(transformResultE);
      }
    };
    let flushAlgorithm = () => promiseResolvedWith(undefined);
    if (transformer.transform !== undefined) {
      transformAlgorithm = chunk => transformer.transform(chunk, controller);
    }
    if (transformer.flush !== undefined) {
      flushAlgorithm = () => transformer.flush(controller);
    }
    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
  }
  function TransformStreamDefaultControllerClearAlgorithms(controller) {
    controller._transformAlgorithm = undefined;
    controller._flushAlgorithm = undefined;
  }
  function TransformStreamDefaultControllerEnqueue(controller, chunk) {
    const stream = controller._controlledTransformStream;
    const readableController = stream._readable._readableStreamController;
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
      throw new TypeError('Readable side is not in a state that permits enqueue');
    }
    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
    // accept TransformStreamDefaultControllerEnqueue() calls.
    try {
      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
    } catch (e) {
      // This happens when readableStrategy.size() throws.
      TransformStreamErrorWritableAndUnblockWrite(stream, e);
      throw stream._readable._storedError;
    }
    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
    if (backpressure !== stream._backpressure) {
      TransformStreamSetBackpressure(stream, true);
    }
  }
  function TransformStreamDefaultControllerError(controller, e) {
    TransformStreamError(controller._controlledTransformStream, e);
  }
  function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
    const transformPromise = controller._transformAlgorithm(chunk);
    return transformPromiseWith(transformPromise, undefined, r => {
      TransformStreamError(controller._controlledTransformStream, r);
      throw r;
    });
  }
  function TransformStreamDefaultControllerTerminate(controller) {
    const stream = controller._controlledTransformStream;
    const readableController = stream._readable._readableStreamController;
    ReadableStreamDefaultControllerClose(readableController);
    const error = new TypeError('TransformStream terminated');
    TransformStreamErrorWritableAndUnblockWrite(stream, error);
  }
  // TransformStreamDefaultSink Algorithms
  function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
    const controller = stream._transformStreamController;
    if (stream._backpressure) {
      const backpressureChangePromise = stream._backpressureChangePromise;
      return transformPromiseWith(backpressureChangePromise, () => {
        const writable = stream._writable;
        const state = writable._state;
        if (state === 'erroring') {
          throw writable._storedError;
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      });
    }
    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
  }
  function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
    // errored.
    TransformStreamError(stream, reason);
    return promiseResolvedWith(undefined);
  }
  function TransformStreamDefaultSinkCloseAlgorithm(stream) {
    // stream._readable cannot change after construction, so caching it across a call to user code is safe.
    const readable = stream._readable;
    const controller = stream._transformStreamController;
    const flushPromise = controller._flushAlgorithm();
    TransformStreamDefaultControllerClearAlgorithms(controller);
    // Return a promise that is fulfilled with undefined on success.
    return transformPromiseWith(flushPromise, () => {
      if (readable._state === 'errored') {
        throw readable._storedError;
      }
      ReadableStreamDefaultControllerClose(readable._readableStreamController);
    }, r => {
      TransformStreamError(stream, r);
      throw readable._storedError;
    });
  }
  // TransformStreamDefaultSource Algorithms
  function TransformStreamDefaultSourcePullAlgorithm(stream) {
    // Invariant. Enforced by the promises returned by start() and pull().
    TransformStreamSetBackpressure(stream, false);
    // Prevent the next pull() call until there is backpressure.
    return stream._backpressureChangePromise;
  }
  // Helper functions for the TransformStreamDefaultController.
  function defaultControllerBrandCheckException(name) {
    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
  }
  // Helper functions for the TransformStream.
  function streamBrandCheckException(name) {
    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
  }
  exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
  exports.CountQueuingStrategy = CountQueuingStrategy;
  exports.ReadableByteStreamController = ReadableByteStreamController;
  exports.ReadableStream = ReadableStream;
  exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
  exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
  exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
  exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
  exports.TransformStream = TransformStream;
  exports.TransformStreamDefaultController = TransformStreamDefaultController;
  exports.WritableStream = WritableStream;
  exports.WritableStreamDefaultController = WritableStreamDefaultController;
  exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/fetch-blob/streams.cjs":
/*!*********************************************!*\
  !*** ./node_modules/fetch-blob/streams.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = __webpack_require__(/*! node:process */ "node:process")
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ "node:stream/web"))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
    Object.assign(globalThis, __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.es2018.js */ "./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"))
  }
}

try {
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = __webpack_require__(/*! buffer */ "buffer")
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
} catch (error) {}
/* c8 ignore end */


/***/ }),

/***/ "./node_modules/data-uri-to-buffer/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/data-uri-to-buffer/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataUriToBuffer: () => (/* binding */ dataUriToBuffer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  // strip newlines
  uri = uri.replace(/\r?\n/g, '');
  // split the URI up into the "metadata" and the "data" portions
  const firstComma = uri.indexOf(',');
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError('malformed data: URI');
  }
  // remove the "data:" scheme and parse the metadata
  const meta = uri.substring(5, firstComma).split(';');
  let charset = '';
  let base64 = false;
  const type = meta[0] || 'text/plain';
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === 'base64') {
      base64 = true;
    } else if (meta[i]) {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf('charset=') === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  // defaults to US-ASCII only if type is not provided
  if (!meta[0] && !charset.length) {
    typeFull += ';charset=US-ASCII';
    charset = 'US-ASCII';
  }
  // get the encoded data portion and decode URI-encoded chars
  const encoding = base64 ? 'base64' : 'ascii';
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  // set `.type` and `.typeFull` properties to MIME type
  buffer.type = type;
  buffer.typeFull = typeFull;
  // set the `.charset` property
  buffer.charset = charset;
  return buffer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataUriToBuffer);

/***/ }),

/***/ "./node_modules/fetch-blob/file.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/file.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");

const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #lastModified = 0;
  #name = '';

  /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */ // @ts-ignore
  constructor(fileBits, fileName, options = {}) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
    }
    super(fileBits, options);
    if (options === null) options = {};

    // Simulate WebIDL type casting for NaN value in lastModified option.
    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
    if (!Number.isNaN(lastModified)) {
      this.#lastModified = lastModified;
    }
    this.#name = String(fileName);
  }
  get name() {
    return this.#name;
  }
  get lastModified() {
    return this.#lastModified;
  }
  get [Symbol.toStringTag]() {
    return 'File';
  }
  static [Symbol.hasInstance](object) {
    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] && /^(File)$/.test(object[Symbol.toStringTag]);
  }
};

/** @type {typeof globalThis.File} */ // @ts-ignore
const File = _File;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);

/***/ }),

/***/ "./node_modules/fetch-blob/from.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/from.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   blobFrom: () => (/* binding */ blobFrom),
/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fileFrom: () => (/* binding */ fileFrom),
/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-domexception */ "./node_modules/node-domexception/index.js");
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ "./node_modules/fetch-blob/file.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/fetch-blob/index.js");





const {
  stat
} = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises;

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const blobFromSync = (path, type) => fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<Blob>}
 */
const blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<File>}
 */
const fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const fileFromSync = (path, type) => fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);

// @ts-ignore
const fromBlob = (stat, path, type = '') => new _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], {
  type
});

// @ts-ignore
const fromFile = (stat, path, type = '') => new _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), {
  type,
  lastModified: stat.mtimeMs
});

/**
 * This is a blob backed up by a file on the disk
 * with minium requirement. Its wrapped around a Blob as a blobPart
 * so you have no direct access to this.
 *
 * @private
 */
class BlobDataItem {
  #path;
  #start;
  constructor(options) {
    this.#path = options.path;
    this.#start = options.start;
    this.size = options.size;
    this.lastModified = options.lastModified;
  }

  /**
   * Slicing arguments is first validated and formatted
   * to not be out of range by Blob.prototype.slice
   */
  slice(start, end) {
    return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
    });
  }
  async *stream() {
    const {
      mtimeMs
    } = await stat(this.#path);
    if (mtimeMs > this.lastModified) {
      throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');
    }
    yield* (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
    });
  }
  get [Symbol.toStringTag]() {
    return 'Blob';
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);


/***/ }),

/***/ "./node_modules/fetch-blob/index.js":
/*!******************************************!*\
  !*** ./node_modules/fetch-blob/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* binding */ Blob),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streams.cjs */ "./node_modules/fetch-blob/streams.cjs");
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core



// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536;

/** @param {(Blob | Uint8Array)[]} parts */
async function* toIterator(parts, clone = true) {
  for (const part of parts) {
    if ('stream' in part) {
      yield* /** @type {AsyncIterableIterator<Uint8Array>} */part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
      /* c8 ignore next 10 */
    } else {
      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
      let position = 0,
        b = /** @type {Blob} */part;
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
const _Blob = class Blob {
  /** @type {Array.<(Blob|Uint8Array)>} */
  #parts = [];
  #type = '';
  #size = 0;
  #endings = 'transparent';

  /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */
  constructor(blobParts = [], options = {}) {
    if (typeof blobParts !== 'object' || blobParts === null) {
      throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.');
    }
    if (typeof blobParts[Symbol.iterator] !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.');
    }
    if (typeof options !== 'object' && typeof options !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.');
    }
    if (options === null) options = {};
    const encoder = new TextEncoder();
    for (const element of blobParts) {
      let part;
      if (ArrayBuffer.isView(element)) {
        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
      } else if (element instanceof ArrayBuffer) {
        part = new Uint8Array(element.slice(0));
      } else if (element instanceof Blob) {
        part = element;
      } else {
        part = encoder.encode(`${element}`);
      }
      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
      this.#parts.push(part);
    }
    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`;
    const type = options.type === undefined ? '' : String(options.type);
    this.#type = /^[\x20-\x7E]*$/.test(type) ? type : '';
  }

  /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */
  get size() {
    return this.#size;
  }

  /**
   * The type property of a Blob object returns the MIME type of the file.
   */
  get type() {
    return this.#type;
  }

  /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */
  async text() {
    // More optimized than using this.arrayBuffer()
    // that requires twice as much ram
    const decoder = new TextDecoder();
    let str = '';
    for await (const part of toIterator(this.#parts, false)) {
      str += decoder.decode(part, {
        stream: true
      });
    }
    // Remaining
    str += decoder.decode();
    return str;
  }

  /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */
  async arrayBuffer() {
    // Easier way... Just a unnecessary overhead
    // const view = new Uint8Array(this.size);
    // await this.stream().getReader({mode: 'byob'}).read(view);
    // return view.buffer;

    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of toIterator(this.#parts, false)) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    const it = toIterator(this.#parts, true);
    return new globalThis.ReadableStream({
      // @ts-ignore
      type: 'bytes',
      async pull(ctrl) {
        const chunk = await it.next();
        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
      },
      async cancel() {
        await it.return();
      }
    });
  }

  /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */
  slice(start = 0, end = this.size, type = '') {
    const {
      size
    } = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = this.#parts;
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      // don't add the overflow to new blobParts
      if (added >= span) {
        break;
      }
      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size <= relativeStart) {
        // Skip the beginning and change the relative
        // start & end position as we skip the unwanted parts
        relativeStart -= size;
        relativeEnd -= size;
      } else {
        let chunk;
        if (ArrayBuffer.isView(part)) {
          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));
          added += chunk.byteLength;
        } else {
          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));
          added += chunk.size;
        }
        relativeEnd -= size;
        blobParts.push(chunk);
        relativeStart = 0; // All next sequential parts should start at 0
      }
    }

    const blob = new Blob([], {
      type: String(type).toLowerCase()
    });
    blob.#size = span;
    blob.#parts = blobParts;
    return blob;
  }
  get [Symbol.toStringTag]() {
    return 'Blob';
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(_Blob.prototype, {
  size: {
    enumerable: true
  },
  type: {
    enumerable: true
  },
  slice: {
    enumerable: true
  }
});

/** @type {typeof globalThis.Blob} */
const Blob = _Blob;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);

/***/ }),

/***/ "./node_modules/formdata-polyfill/esm.min.js":
/*!***************************************************!*\
  !*** ./node_modules/formdata-polyfill/esm.min.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   FormData: () => (/* binding */ FormData),
/* harmony export */   formDataToBlob: () => (/* binding */ formDataToBlob)
/* harmony export */ });
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fetch-blob/file.js */ "./node_modules/fetch-blob/file.js");
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */



var {
    toStringTag: t,
    iterator: i,
    hasInstance: h
  } = Symbol,
  r = Math.random,
  m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
  f = (a, b, c) => (a += '', /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob', a), b.name !== c || b[t] == 'blob' ? new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]([b], c, b) : b] : [a, b + '']),
  e = (c, f) => (f ? c : c.replace(/\r?\n|\r/g, '\r\n')).replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22'),
  x = (n, a, e) => {
    if (a.length < e) {
      throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);
    }
  };
const File = fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/** @type {typeof globalThis.FormData} */
const FormData = class FormData {
  #d = [];
  constructor(...a) {
    if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
  }
  get [t]() {
    return 'FormData';
  }
  [i]() {
    return this.entries();
  }
  static [h](o) {
    return o && typeof o === 'object' && o[t] === 'FormData' && !m.some(m => typeof o[m] != 'function');
  }
  append(...a) {
    x('append', arguments, 2);
    this.#d.push(f(...a));
  }
  delete(a) {
    x('delete', arguments, 1);
    a += '';
    this.#d = this.#d.filter(([b]) => b !== a);
  }
  get(a) {
    x('get', arguments, 1);
    a += '';
    for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
    return null;
  }
  getAll(a, b) {
    x('getAll', arguments, 1);
    b = [];
    a += '';
    this.#d.forEach(c => c[0] === a && b.push(c[1]));
    return b;
  }
  has(a) {
    x('has', arguments, 1);
    a += '';
    return this.#d.some(b => b[0] === a);
  }
  forEach(a, b) {
    x('forEach', arguments, 1);
    for (var [c, d] of this) a.call(b, d, c, this);
  }
  set(...a) {
    x('set', arguments, 2);
    var b = [],
      c = !0;
    a = f(...a);
    this.#d.forEach(d => {
      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
    });
    c && b.push(a);
    this.#d = b;
  }
  *entries() {
    yield* this.#d;
  }
  *keys() {
    for (var [a] of this) yield a;
  }
  *values() {
    for (var [, a] of this) yield a;
  }
};

/** @param {FormData} F */
function formDataToBlob(F, B = fetch_blob__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  var b = `${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),
    c = [],
    p = `--${b}\r\nContent-Disposition: form-data; name="`;
  F.forEach((v, n) => typeof v == 'string' ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, '\r\n'));
  c.push(`--${b}--`);
  return new B(c, {
    type: "multipart/form-data; boundary=" + b
  });
}

/***/ }),

/***/ "./node_modules/ky-universal/index.js":
/*!********************************************!*\
  !*** ./node_modules/ky-universal/index.js ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTTPError: () => (/* binding */ HTTPError),
/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/index.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/request.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/src/response.js");
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abort-controller */ "./node_modules/abort-controller/dist/abort-controller.js");


const TEN_MEGABYTES = 1000 * 1000 * 10;
if (!globalThis.fetch) {
  globalThis.fetch = (url, options) => (0,node_fetch__WEBPACK_IMPORTED_MODULE_1__["default"])(url, {
    highWaterMark: TEN_MEGABYTES,
    ...options
  });
}
if (!globalThis.Headers) {
  globalThis.Headers = node_fetch__WEBPACK_IMPORTED_MODULE_2__["default"];
}
if (!globalThis.Request) {
  globalThis.Request = node_fetch__WEBPACK_IMPORTED_MODULE_3__["default"];
}
if (!globalThis.Response) {
  globalThis.Response = node_fetch__WEBPACK_IMPORTED_MODULE_4__["default"];
}
if (!globalThis.AbortController) {
  globalThis.AbortController = abort_controller__WEBPACK_IMPORTED_MODULE_0__;
}
if (!globalThis.ReadableStream) {
  try {
    globalThis.ReadableStream = await __webpack_require__.e(/*! import() */ "vendors-node_modules_web-streams-polyfill_dist_polyfill_es2018_min_js").then(__webpack_require__.t.bind(__webpack_require__, /*! web-streams-polyfill/ponyfill/es2018 */ "./node_modules/web-streams-polyfill/dist/polyfill.es2018.min.js", 19));
  } catch {}
}
const {
  default: ky,
  HTTPError,
  TimeoutError
} = await __webpack_require__.e(/*! import() */ "vendors-node_modules_ky_distribution_index_js").then(__webpack_require__.bind(__webpack_require__, /*! ky */ "./node_modules/ky/distribution/index.js"));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ky);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./node_modules/node-fetch/src/body.js":
/*!*********************************************!*\
  !*** ./node_modules/node-fetch/src/body.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   "default": () => (/* binding */ Body),
/* harmony export */   extractContentType: () => (/* binding */ extractContentType),
/* harmony export */   getTotalBytes: () => (/* binding */ getTotalBytes),
/* harmony export */   writeToStream: () => (/* binding */ writeToStream)
/* harmony export */ });
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fetch-blob */ "./node_modules/fetch-blob/index.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors/base.js */ "./node_modules/node-fetch/src/errors/base.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */









const pipeline = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_0__.pipeline);
const INTERNALS = Symbol('Body internals');

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Body {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      // Body is undefined or null
      body = null;
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
      // Body is a URLSearchParams
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.toString());
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
      // Body is blob
    } else if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
      // Body is Buffer
    } else if (node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body)) {
      // Body is ArrayBuffer
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      // Body is ArrayBufferView
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
      // Body is stream
    } else if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
      // Body is FormData
      body = (0,formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.formDataToBlob)(body);
      boundary = body.type.split('=')[1];
    } else {
      // None of the above
      // coerce to string then buffer
      body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(String(body));
    }
    let stream = body;
    if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
      stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body);
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
      stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
      body.on('error', error_ => {
        const error = error_ instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error_ : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }

  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const {
      buffer,
      byteOffset,
      byteLength
    } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get('content-type');
    if (ct.startsWith('application/x-www-form-urlencoded')) {
      const formData = new formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const {
      toFormData
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_node-fetch_src_utils_multipart-parser_js").then(__webpack_require__.bind(__webpack_require__, /*! ./utils/multipart-parser.js */ "./node_modules/node-fetch/src/utils/multipart-parser.js"));
    return toFormData(this.body, ct);
  }

  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';
    const buf = await this.arrayBuffer();
    return new fetch_blob__WEBPACK_IMPORTED_MODULE_3__["default"]([buf], {
      type: ct
    });
  }

  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }

  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }

  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
}
Body.prototype.buffer = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
  body: {
    enumerable: true
  },
  bodyUsed: {
    enumerable: true
  },
  arrayBuffer: {
    enumerable: true
  },
  blob: {
    enumerable: true
  },
  json: {
    enumerable: true
  },
  text: {
    enumerable: true
  },
  data: {
    get: (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {}, 'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')
  }
});

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const {
    body
  } = data;

  // Body is null
  if (body === null) {
    return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
  }

  /* c8 ignore next 3 */
  if (!(body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__)) {
    return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
  }

  // Body is stream
  // get ready to actually consume the body
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every(c => typeof c === 'string')) {
        return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(accum.join(''));
      }
      return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
    }
  } else {
    throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_7__.FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed   instance       Response or Request instance
 * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
 * @return  Mixed
 */
const clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let {
    body
  } = instance[INTERNALS];

  // Don't allow cloning a used body
  if (instance.bodyUsed) {
    throw new Error('cannot clone body after it is used');
  }

  // Check that body is a stream and not form-data object
  // note: we can't clone the form-data object without having it as a dependency
  if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {
    // Tee instance body
    p1 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({
      highWaterMark
    });
    p2 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({
      highWaterMark
    });
    body.pipe(p1);
    body.pipe(p2);
    // Set instance body to teed body and return the other teed body
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
const getNonSpecFormDataBoundary = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(body => body.getBoundary(), 'form-data doesn\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param {any} body Any options.body input
 * @returns {string | null}
 */
const extractContentType = (body, request) => {
  // Body is null or undefined
  if (body === null) {
    return null;
  }

  // Body is string
  if (typeof body === 'string') {
    return 'text/plain;charset=UTF-8';
  }

  // Body is a URLSearchParams
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isURLSearchParameters)(body)) {
    return 'application/x-www-form-urlencoded;charset=UTF-8';
  }

  // Body is blob
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
    return body.type || null;
  }

  // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
  if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body) || node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }

  // Detect form data input from form-data module
  if (body && typeof body.getBoundary === 'function') {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }

  // Body is stream - can't really do much about this
  if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
    return null;
  }

  // Body constructor defaults other things to string
  return 'text/plain;charset=UTF-8';
};

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param {any} obj.body Body object from the Body instance.
 * @returns {number | null}
 */
const getTotalBytes = request => {
  const {
    body
  } = request[INTERNALS];

  // Body is null or undefined
  if (body === null) {
    return 0;
  }

  // Body is Blob
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_5__.isBlob)(body)) {
    return body.size;
  }

  // Body is Buffer
  if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
    return body.length;
  }

  // Detect form data input from form-data module
  if (body && typeof body.getLengthSync === 'function') {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }

  // Body is stream
  return null;
};

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param {Stream.Writable} dest The stream to write to.
 * @param obj.body Body object from the Body instance.
 * @returns {Promise<void>}
 */
const writeToStream = async (dest, {
  body
}) => {
  if (body === null) {
    // Body is null
    dest.end();
  } else {
    // Body is stream
    await pipeline(body, dest);
  }
};

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/abort-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/abort-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");


/**
 * AbortError interface for cancelled requests
 */
class AbortError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
  constructor(message, type = 'aborted') {
    super(message, type);
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/base.js":
/*!****************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/base.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBaseError: () => (/* binding */ FetchBaseError)
/* harmony export */ });
class FetchBaseError extends Error {
  constructor(message, type) {
    super(message);
    // Hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/errors/fetch-error.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-fetch/src/errors/fetch-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchError: () => (/* binding */ FetchError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/node-fetch/src/errors/base.js");


/**
 * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/

/**
 * FetchError interface for operational errors
 */
class FetchError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
    if (systemError) {
      // eslint-disable-next-line no-multi-assign
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
}

/***/ }),

/***/ "./node_modules/node-fetch/src/headers.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/headers.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Headers),
/* harmony export */   fromRawHeaders: () => (/* binding */ fromRawHeaders)
/* harmony export */ });
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:http */ "node:http");
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */




/* c8 ignore next 9 */
const validateHeaderName = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName === 'function' ? node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName : name => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_HTTP_TOKEN'
    });
    throw error;
  }
};

/* c8 ignore next 9 */
const validateHeaderValue = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue === 'function' ? node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_CHAR'
    });
    throw error;
  }
};

/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */
class Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    // Validate and normalize init object in [name, value(s)][]
    /** @type {string[][]} */
    let result = [];
    if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map(value => [name, value]));
      }
    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq
      // No op
    } else if (typeof init === 'object' && !node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      // eslint-disable-next-line no-eq-null, eqeqeq
      if (method == null) {
        // Record<ByteString, ByteString>
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== 'function') {
          throw new TypeError('Header pairs must be iterable');
        }

        // Sequence<sequence<ByteString>>
        // Note: per spec we have to first exhaust the lists then process them
        result = [...init].map(pair => {
          if (typeof pair !== 'object' || node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(pair)) {
            throw new TypeError('Each header pair must be an iterable object');
          }
          return [...pair];
        }).map(pair => {
          if (pair.length !== 2) {
            throw new TypeError('Each header pair must be a name/value tuple');
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
    }

    // Validate and lowercase
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : undefined;
    super(result);

    // Returning a Proxy that will lowercase key names, validate parameters and sort keys
    // eslint-disable-next-line no-constructor-return
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case 'append':
          case 'set':
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
            };
          case 'delete':
          case 'has':
          case 'getAll':
            return name => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
            };
          case 'keys':
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
    /* c8 ignore next */
  }

  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(', ');
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = undefined) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }

  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }

  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }

  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      // Http.request() only supports string as Host header.
      // This hack makes specifying custom Host header possible.
      if (key === 'host') {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
}

/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */
Object.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
  result[property] = {
    enumerable: true
  };
  return result;
}, {}));

/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */
function fromRawHeaders(headers = []) {
  return new Headers(headers
  // Split into pairs
  .reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}

/***/ }),

/***/ "./node_modules/node-fetch/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-fetch/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* reexport safe */ _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError),
/* harmony export */   Blob: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.Blob),
/* harmony export */   FetchError: () => (/* reexport safe */ _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError),
/* harmony export */   File: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.File),
/* harmony export */   FormData: () => (/* reexport safe */ formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__.FormData),
/* harmony export */   Headers: () => (/* reexport safe */ _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Request: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Response: () => (/* reexport safe */ _response_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   blobFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFrom),
/* harmony export */   blobFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.blobFromSync),
/* harmony export */   "default": () => (/* binding */ fetch),
/* harmony export */   fileFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFrom),
/* harmony export */   fileFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__.fileFromSync),
/* harmony export */   isRedirect: () => (/* reexport safe */ _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)
/* harmony export */ });
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ "node:https");
/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:zlib */ "node:zlib");
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! data-uri-to-buffer */ "./node_modules/data-uri-to-buffer/dist/index.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./response.js */ "./node_modules/node-fetch/src/response.js");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./request.js */ "./node_modules/node-fetch/src/request.js");
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./errors/fetch-error.js */ "./node_modules/node-fetch/src/errors/fetch-error.js");
/* harmony import */ var _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors/abort-error.js */ "./node_modules/node-fetch/src/errors/abort-error.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! formdata-polyfill/esm.min.js */ "./node_modules/formdata-polyfill/esm.min.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/* harmony import */ var fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fetch-blob/from.js */ "./node_modules/fetch-blob/from.js");
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */




















const supportedSchemas = new Set(['data:', 'http:', 'https:']);

/**
 * Fetch function
 *
 * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
 * @param   {*} [options_] - Fetch options
 * @return  {Promise<import('./response').default>}
 */
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    // Build request object
    const request = new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](url, options_);
    const {
      parsedURL,
      options
    } = (0,_request_js__WEBPACK_IMPORTED_MODULE_9__.getNodeRequestOptions)(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
    }
    if (parsedURL.protocol === 'data:') {
      const data = (0,data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__["default"])(request.url);
      const response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](data, {
        headers: {
          'Content-Type': data.typeFull
        }
      });
      resolve(response);
      return;
    }

    // Wrap http.request into fetch
    const send = (parsedURL.protocol === 'https:' ? node_https__WEBPACK_IMPORTED_MODULE_1__ : node_http__WEBPACK_IMPORTED_MODULE_0__).request;
    const {
      signal
    } = request;
    let response = null;
    const abort = () => {
      const error = new _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_12__.AbortError('The operation was aborted.');
      reject(error);
      if (request.body && request.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit('error', error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };

    // Send request
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener('abort', abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener('abort', abortAndFinalize);
      }
    };
    request_.on('error', error => {
      reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, error => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });

    /* c8 ignore next 18 */
    if (process.version < 'v14') {
      // Before Node.js 14, pipeline() does not fully support async iterators and does not always
      // properly handle when the socket close/end events are out of order.
      request_.on('socket', s => {
        let endedWithEventsCount;
        s.prependListener('end', () => {
          endedWithEventsCount = s._eventsCount;
        });
        s.prependListener('close', hadError => {
          // if end happened before close but the socket didn't emit an error, do it now
          if (response && endedWithEventsCount < s._eventsCount && !hadError) {
            const error = new Error('Premature close');
            error.code = 'ERR_STREAM_PREMATURE_CLOSE';
            response.body.emit('error', error);
          }
        });
      });
    }
    request_.on('response', response_ => {
      request_.setTimeout(0);
      const headers = (0,_headers_js__WEBPACK_IMPORTED_MODULE_8__.fromRawHeaders)(response_.rawHeaders);

      // HTTP fetch step 5
      if ((0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_13__.isRedirect)(response_.statusCode)) {
        // HTTP fetch step 5.2
        const location = headers.get('Location');

        // HTTP fetch step 5.3
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          // error here can only be invalid URL in Location: header
          // do not throw when options.redirect == manual
          // let the user extract the errorneous redirect URL
          if (request.redirect !== 'manual') {
            reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
            finalize();
            return;
          }
        }

        // HTTP fetch step 5.5
        switch (request.redirect) {
          case 'error':
            reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
            finalize();
            return;
          case 'manual':
            // Nothing to do
            break;
          case 'follow':
            {
              // HTTP-redirect fetch step 2
              if (locationURL === null) {
                break;
              }

              // HTTP-redirect fetch step 5
              if (request.counter >= request.follow) {
                reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                finalize();
                return;
              }

              // HTTP-redirect fetch step 6 (counter increment)
              // Create a new Request object.
              const requestOptions = {
                headers: new _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"](request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: (0,_body_js__WEBPACK_IMPORTED_MODULE_14__.clone)(request),
                signal: request.signal,
                size: request.size,
                referrer: request.referrer,
                referrerPolicy: request.referrerPolicy
              };

              // when forwarding sensitive headers like "Authorization",
              // "WWW-Authenticate", and "Cookie" to untrusted targets,
              // headers will be ignored when following a redirect to a domain
              // that is not a subdomain match or exact match of the initial domain.
              // For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
              // will forward the sensitive headers, but a redirect to "bar.com" will not.
              // headers will also be ignored when following a redirect to a domain using
              // a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
              // will not forward the sensitive headers
              if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isDomainOrSubdomain)(request.url, locationURL) || !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_15__.isSameProtocol)(request.url, locationURL)) {
                for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
                  requestOptions.headers.delete(name);
                }
              }

              // HTTP-redirect fetch step 9
              if (response_.statusCode !== 303 && request.body && options_.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
                reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_11__.FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                finalize();
                return;
              }

              // HTTP-redirect fetch step 11
              if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST') {
                requestOptions.method = 'GET';
                requestOptions.body = undefined;
                requestOptions.headers.delete('content-length');
              }

              // HTTP-redirect fetch step 14
              const responseReferrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_16__.parseReferrerPolicyFromHeader)(headers);
              if (responseReferrerPolicy) {
                requestOptions.referrerPolicy = responseReferrerPolicy;
              }

              // HTTP-redirect fetch step 15
              resolve(fetch(new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](locationURL, requestOptions)));
              finalize();
              return;
            }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }

      // Prepare response
      if (signal) {
        response_.once('end', () => {
          signal.removeEventListener('abort', abortAndFinalize);
        });
      }
      let body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
        if (error) {
          reject(error);
        }
      });
      // see https://github.com/nodejs/node/pull/29376
      /* c8 ignore next 3 */
      if (process.version < 'v12.10') {
        response_.on('aborted', abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };

      // HTTP-network fetch step 12.1.1.3
      const codings = headers.get('Content-Encoding');

      // HTTP-network fetch step 12.1.1.4: handle content codings

      // in following scenarios we ignore compression support
      // 1. compression support is disabled
      // 2. HEAD request
      // 3. no Content-Encoding header
      // 4. no content response (204)
      // 5. content not modified response (304)
      if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // For Node v6+
      // Be less strict when decoding compressed responses, since sometimes
      // servers send slightly invalid responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      const zlibOptions = {
        flush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH,
        finishFlush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH
      };

      // For gzip
      if (codings === 'gzip' || codings === 'x-gzip') {
        body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip(zlibOptions), error => {
          if (error) {
            reject(error);
          }
        });
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // For deflate
      if (codings === 'deflate' || codings === 'x-deflate') {
        // Handle the infamous raw deflate response from old servers
        // a hack for old IIS and Apache servers
        const raw = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
          if (error) {
            reject(error);
          }
        });
        raw.once('data', chunk => {
          // See http://stackoverflow.com/questions/37519828
          if ((chunk[0] & 0x0F) === 0x08) {
            body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate(), error => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflateRaw(), error => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
          resolve(response);
        });
        raw.once('end', () => {
          // Some old IIS servers return zero-length OK deflate responses, so
          // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
          if (!response) {
            response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
            resolve(response);
          }
        });
        return;
      }

      // For br
      if (codings === 'br') {
        body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createBrotliDecompress(), error => {
          if (error) {
            reject(error);
          }
        });
        response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
        resolve(response);
        return;
      }

      // Otherwise, use response as-is
      response = new _response_js__WEBPACK_IMPORTED_MODULE_10__["default"](body, responseOptions);
      resolve(response);
    });

    // eslint-disable-next-line promise/prefer-await-to-then
    (0,_body_js__WEBPACK_IMPORTED_MODULE_14__.writeToStream)(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from('0\r\n\r\n');
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on('response', response => {
    const {
      headers
    } = response;
    isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
  });
  request.on('socket', socket => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error('Premature close');
        error.code = 'ERR_STREAM_PREMATURE_CLOSE';
        errorCallback(error);
      }
    };
    const onData = buf => {
      properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

      // Sometimes final 0-length chunk and end of message code are in separate packets
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener('close', onSocketClose);
    socket.on('data', onData);
    request.on('close', () => {
      socket.removeListener('close', onSocketClose);
      socket.removeListener('data', onData);
    });
  });
}

/***/ }),

/***/ "./node_modules/node-fetch/src/request.js":
/*!************************************************!*\
  !*** ./node_modules/node-fetch/src/request.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request),
/* harmony export */   getNodeRequestOptions: () => (/* binding */ getNodeRequestOptions)
/* harmony export */ });
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/is.js */ "./node_modules/node-fetch/src/utils/is.js");
/* harmony import */ var _utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/get-search.js */ "./node_modules/node-fetch/src/utils/get-search.js");
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/referrer.js */ "./node_modules/node-fetch/src/utils/referrer.js");
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */








const INTERNALS = Symbol('Request internals');

/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */
const isRequest = object => {
  return typeof object === 'object' && typeof object[INTERNALS] === 'object';
};
const doBadDataWarn = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {}, '.data is not a valid RequestInit property, use .body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

/**
 * Request class
 *
 * Ref: https://fetch.spec.whatwg.org/#request-class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request extends _body_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(input, init = {}) {
    let parsedURL;

    // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== '' || parsedURL.password !== '') {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || 'GET';
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && 'data' in init) {
      doBadDataWarn();
    }

    // eslint-disable-next-line no-eq-null, eqeqeq
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
      throw new TypeError('Request with GET/HEAD method cannot have body');
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.clone)(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](init.headers || input.headers || {});
    if (inputBody !== null && !headers.has('Content-Type')) {
      const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.extractContentType)(inputBody, this);
      if (contentType) {
        headers.set('Content-Type', contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ('signal' in init) {
      signal = init.signal;
    }

    // eslint-disable-next-line no-eq-null, eqeqeq
    if (signal != null && !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_4__.isAbortSignal)(signal)) {
      throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
    }

    // §5.4, Request constructor steps, step 15.1
    // eslint-disable-next-line no-eq-null, eqeqeq
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === '') {
      // §5.4, Request constructor steps, step 15.2
      referrer = 'no-referrer';
    } else if (referrer) {
      // §5.4, Request constructor steps, step 15.3.1, 15.3.2
      const parsedReferrer = new URL(referrer);
      // §5.4, Request constructor steps, step 15.3.3, 15.3.4
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
    } else {
      referrer = undefined;
    }
    this[INTERNALS] = {
      method,
      redirect: init.redirect || input.redirect || 'follow',
      headers,
      parsedURL,
      signal,
      referrer
    };

    // Node-fetch-only options
    this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;
    this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

    // §5.4, Request constructor steps, step 16.
    // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
  }

  /** @returns {string} */
  get method() {
    return this[INTERNALS].method;
  }

  /** @returns {string} */
  get url() {
    return (0,node_url__WEBPACK_IMPORTED_MODULE_0__.format)(this[INTERNALS].parsedURL);
  }

  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }

  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS].signal;
  }

  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS].referrer === 'no-referrer') {
      return '';
    }
    if (this[INTERNALS].referrer === 'client') {
      return 'about:client';
    }
    if (this[INTERNALS].referrer) {
      return this[INTERNALS].referrer.toString();
    }
    return undefined;
  }
  get referrerPolicy() {
    return this[INTERNALS].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS].referrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.validateReferrerPolicy)(referrerPolicy);
  }

  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return 'Request';
  }
}
Object.defineProperties(Request.prototype, {
  method: {
    enumerable: true
  },
  url: {
    enumerable: true
  },
  headers: {
    enumerable: true
  },
  redirect: {
    enumerable: true
  },
  clone: {
    enumerable: true
  },
  signal: {
    enumerable: true
  },
  referrer: {
    enumerable: true
  },
  referrerPolicy: {
    enumerable: true
  }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param {Request} request - A Request instance
 * @return The options object to be passed to http.request
 */
const getNodeRequestOptions = request => {
  const {
    parsedURL
  } = request[INTERNALS];
  const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_3__["default"](request[INTERNALS].headers);

  // Fetch step 1.3
  if (!headers.has('Accept')) {
    headers.set('Accept', '*/*');
  }

  // HTTP-network-or-cache fetch steps 2.4-2.7
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = '0';
  }
  if (request.body !== null) {
    const totalBytes = (0,_body_js__WEBPACK_IMPORTED_MODULE_2__.getTotalBytes)(request);
    // Set Content-Length if totalBytes is a number (that is not NaN)
    if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set('Content-Length', contentLengthValue);
  }

  // 4.1. Main fetch, step 2.6
  // > If request's referrer policy is the empty string, then set request's referrer policy to the
  // > default referrer policy.
  if (request.referrerPolicy === '') {
    request.referrerPolicy = _utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_REFERRER_POLICY;
  }

  // 4.1. Main fetch, step 2.7
  // > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
  // > determine request's referrer.
  if (request.referrer && request.referrer !== 'no-referrer') {
    request[INTERNALS].referrer = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_5__.determineRequestsReferrer)(request);
  } else {
    request[INTERNALS].referrer = 'no-referrer';
  }

  // 4.5. HTTP-network-or-cache fetch, step 6.9
  // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
  // >  and isomorphic encoded, to httpRequest's header list.
  if (request[INTERNALS].referrer instanceof URL) {
    headers.set('Referer', request.referrer);
  }

  // HTTP-network-or-cache fetch step 2.11
  if (!headers.has('User-Agent')) {
    headers.set('User-Agent', 'node-fetch');
  }

  // HTTP-network-or-cache fetch step 2.15
  if (request.compress && !headers.has('Accept-Encoding')) {
    headers.set('Accept-Encoding', 'gzip, deflate, br');
  }
  let {
    agent
  } = request;
  if (typeof agent === 'function') {
    agent = agent(parsedURL);
  }

  // HTTP-network fetch step 4.2
  // chunked encoding is handled by Node.js

  const search = (0,_utils_get_search_js__WEBPACK_IMPORTED_MODULE_6__.getSearch)(parsedURL);

  // Pass the full URL directly to request(), but overwrite the following
  // options:
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

/***/ }),

/***/ "./node_modules/node-fetch/src/response.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/response.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Response)
/* harmony export */ });
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./headers.js */ "./node_modules/node-fetch/src/headers.js");
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./body.js */ "./node_modules/node-fetch/src/body.js");
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/is-redirect.js */ "./node_modules/node-fetch/src/utils/is-redirect.js");
/**
 * Response.js
 *
 * Response class provides content decoding
 */




const INTERNALS = Symbol('Response internals');

/**
 * Response class
 *
 * Ref: https://fetch.spec.whatwg.org/#response-class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response extends _body_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(body = null, options = {}) {
    super(body, options);

    // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
    const status = options.status != null ? options.status : 200;
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.headers);
    if (body !== null && !headers.has('Content-Type')) {
      const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_0__.extractContentType)(body, this);
      if (contentType) {
        headers.append('Content-Type', contentType);
      }
    }
    this[INTERNALS] = {
      type: 'default',
      url: options.url,
      status,
      statusText: options.statusText || '',
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS].type;
  }
  get url() {
    return this[INTERNALS].url || '';
  }
  get status() {
    return this[INTERNALS].status;
  }

  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
  }
  get redirected() {
    return this[INTERNALS].counter > 0;
  }
  get statusText() {
    return this[INTERNALS].statusText;
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get highWaterMark() {
    return this[INTERNALS].highWaterMark;
  }

  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response((0,_body_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }

  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!(0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__.isRedirect)(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response(null, {
      status: 0,
      statusText: ''
    });
    response[INTERNALS].type = 'error';
    return response;
  }
  static json(data = undefined, init = {}) {
    const body = JSON.stringify(data);
    if (body === undefined) {
      throw new TypeError('data is not JSON serializable');
    }
    const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_1__["default"](init && init.headers);
    if (!headers.has('content-type')) {
      headers.set('content-type', 'application/json');
    }
    return new Response(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return 'Response';
  }
}
Object.defineProperties(Response.prototype, {
  type: {
    enumerable: true
  },
  url: {
    enumerable: true
  },
  status: {
    enumerable: true
  },
  ok: {
    enumerable: true
  },
  redirected: {
    enumerable: true
  },
  statusText: {
    enumerable: true
  },
  headers: {
    enumerable: true
  },
  clone: {
    enumerable: true
  }
});

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/get-search.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/get-search.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSearch: () => (/* binding */ getSearch)
/* harmony export */ });
const getSearch = parsedURL => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
  return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is-redirect.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is-redirect.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRedirect: () => (/* binding */ isRedirect)
/* harmony export */ });
const redirectStatus = new Set([301, 302, 303, 307, 308]);

/**
 * Redirect code matching
 *
 * @param {number} code - Status code
 * @return {boolean}
 */
const isRedirect = code => {
  return redirectStatus.has(code);
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/is.js":
/*!*************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/is.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAbortSignal: () => (/* binding */ isAbortSignal),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isDomainOrSubdomain: () => (/* binding */ isDomainOrSubdomain),
/* harmony export */   isSameProtocol: () => (/* binding */ isSameProtocol),
/* harmony export */   isURLSearchParameters: () => (/* binding */ isURLSearchParameters)
/* harmony export */ });
/**
 * Is.js
 *
 * Object type checks.
 */

const NAME = Symbol.toStringTag;

/**
 * Check if `obj` is a URLSearchParams object
 * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isURLSearchParameters = object => {
  return typeof object === 'object' && typeof object.append === 'function' && typeof object.delete === 'function' && typeof object.get === 'function' && typeof object.getAll === 'function' && typeof object.has === 'function' && typeof object.set === 'function' && typeof object.sort === 'function' && object[NAME] === 'URLSearchParams';
};

/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isBlob = object => {
  return object && typeof object === 'object' && typeof object.arrayBuffer === 'function' && typeof object.type === 'string' && typeof object.stream === 'function' && typeof object.constructor === 'function' && /^(Blob|File)$/.test(object[NAME]);
};

/**
 * Check if `obj` is an instance of AbortSignal.
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isAbortSignal = object => {
  return typeof object === 'object' && (object[NAME] === 'AbortSignal' || object[NAME] === 'EventTarget');
};

/**
 * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
 * the parent domain.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

/***/ }),

/***/ "./node_modules/node-fetch/src/utils/referrer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch/src/utils/referrer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_REFERRER_POLICY: () => (/* binding */ DEFAULT_REFERRER_POLICY),
/* harmony export */   ReferrerPolicy: () => (/* binding */ ReferrerPolicy),
/* harmony export */   determineRequestsReferrer: () => (/* binding */ determineRequestsReferrer),
/* harmony export */   isOriginPotentiallyTrustworthy: () => (/* binding */ isOriginPotentiallyTrustworthy),
/* harmony export */   isUrlPotentiallyTrustworthy: () => (/* binding */ isUrlPotentiallyTrustworthy),
/* harmony export */   parseReferrerPolicyFromHeader: () => (/* binding */ parseReferrerPolicyFromHeader),
/* harmony export */   stripURLForUseAsAReferrer: () => (/* binding */ stripURLForUseAsAReferrer),
/* harmony export */   validateReferrerPolicy: () => (/* binding */ validateReferrerPolicy)
/* harmony export */ });
/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:net */ "node:net");


/**
 * @external URL
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
 */

/**
 * @module utils/referrer
 * @private
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}
 * @param {string} URL
 * @param {boolean} [originOnly=false]
 */
function stripURLForUseAsAReferrer(url, originOnly = false) {
  // 1. If url is null, return no referrer.
  if (url == null) {
    // eslint-disable-line no-eq-null, eqeqeq
    return 'no-referrer';
  }
  url = new URL(url);

  // 2. If url's scheme is a local scheme, then return no referrer.
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return 'no-referrer';
  }

  // 3. Set url's username to the empty string.
  url.username = '';

  // 4. Set url's password to null.
  // Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
  url.password = '';

  // 5. Set url's fragment to null.
  // Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
  url.hash = '';

  // 6. If the origin-only flag is true, then:
  if (originOnly) {
    // 6.1. Set url's path to null.
    // Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
    url.pathname = '';

    // 6.2. Set url's query to null.
    // Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
    url.search = '';
  }

  // 7. Return url.
  return url;
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
 */
const ReferrerPolicy = new Set(['', 'no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url']);

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
 */
const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}
 * @param {string} referrerPolicy
 * @returns {string} referrerPolicy
 */
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isOriginPotentiallyTrustworthy(url) {
  // 1. If origin is an opaque origin, return "Not Trustworthy".
  // Not applicable

  // 2. Assert: origin is a tuple origin.
  // Not for implementations

  // 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }

  // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
  const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
  const hostIPVersion = (0,node_net__WEBPACK_IMPORTED_MODULE_0__.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }

  // 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
  // We are returning FALSE here because we cannot ensure conformance to
  // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
  if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
    return false;
  }

  // 6. If origin's scheme component is file, return "Potentially Trustworthy".
  if (url.protocol === 'file:') {
    return true;
  }

  // 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
  // Not supported

  // 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
  // Not supported

  // 9. Return "Not Trustworthy".
  return false;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isUrlPotentiallyTrustworthy(url) {
  // 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }

  // 2. If url's scheme is "data", return "Potentially Trustworthy".
  if (url.protocol === 'data:') {
    return true;
  }

  // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
  // created. Therefore, blobs created in a trustworthy origin will themselves be potentially
  // trustworthy.
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }

  // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.
  return isOriginPotentiallyTrustworthy(url);
}

/**
 * Modifies the referrerURL to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerURLCallback
 * @param {external:URL} referrerURL
 * @returns {external:URL} modified referrerURL
 */

/**
 * Modifies the referrerOrigin to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerOriginCallback
 * @param {external:URL} referrerOrigin
 * @returns {external:URL} modified referrerOrigin
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}
 * @param {Request} request
 * @param {object} o
 * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
 * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
 * @returns {external:URL} Request's referrer
 */
function determineRequestsReferrer(request, {
  referrerURLCallback,
  referrerOriginCallback
} = {}) {
  // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
  // these cases:
  // > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
  // > Note: If request's referrer policy is the empty string, Fetch will not call into this
  // > algorithm.
  if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
    return null;
  }

  // 1. Let policy be request's associated referrer policy.
  const policy = request.referrerPolicy;

  // 2. Let environment be request's client.
  // not applicable to node.js

  // 3. Switch on request's referrer:
  if (request.referrer === 'about:client') {
    return 'no-referrer';
  }

  // "a URL": Let referrerSource be request's referrer.
  const referrerSource = request.referrer;

  // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);

  // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
  //    origin-only flag set to true.
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

  // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
  //    referrerURL to referrerOrigin.
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }

  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
  //    policy considerations in the interests of minimizing data leakage. For example, the user
  //    agent could strip the URL down to an origin, modify its host, replace it with an empty
  //    string, etc.
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }

  // 8.Execute the statements corresponding to the value of policy:
  const currentURL = new URL(request.url);
  switch (policy) {
    case 'no-referrer':
      return 'no-referrer';
    case 'origin':
      return referrerOrigin;
    case 'unsafe-url':
      return referrerURL;
    case 'strict-origin':
      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 2. Return referrerOrigin.
      return referrerOrigin.toString();
    case 'strict-origin-when-cross-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 3. Return referrerOrigin.
      return referrerOrigin;
    case 'same-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // 2. Return no referrer.
      return 'no-referrer';
    case 'origin-when-cross-origin':
      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then
      //    return referrerURL.
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }

      // Return referrerOrigin.
      return referrerOrigin;
    case 'no-referrer-when-downgrade':
      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
      //    potentially trustworthy URL, then return no referrer.
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer';
      }

      // 2. Return referrerURL.
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}
 * @param {Headers} headers Response headers
 * @returns {string} policy
 */
function parseReferrerPolicyFromHeader(headers) {
  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
  //    and response’s header list.
  const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

  // 2. Let policy be the empty string.
  let policy = '';

  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
  //    string, then set policy to token.
  // Note: This algorithm loops over multiple policy values to allow deployment of new policy
  // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }

  // 4. Return policy.
  return policy;
}

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfa3ktdW5pdmVyc2FsX2luZGV4X2pzLmNvbW0tc2Vydi1kZXYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7OztBQUlBLE1BQXFCQSxXQUFZLFNBQVFDLGVBQUEsQ0FBQUMsV0FBb0M7Ozs7RUFJekVDLFlBQUE7SUFDSSxLQUFLLEVBQUU7SUFDUCxNQUFNLElBQUlDLFNBQVMsQ0FBQyw0Q0FBNEMsQ0FBQzs7Ozs7RUFNckUsSUFBV0MsT0FBT0EsQ0FBQTtJQUNkLE1BQU1BLE9BQU8sR0FBR0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQ3RDLElBQUksT0FBT0YsT0FBTyxLQUFLLFNBQVMsRUFBRTtNQUM5QixNQUFNLElBQUlELFNBQVMsQ0FDZiwwREFDSSxJQUFJLEtBQUssSUFBSSxHQUFHLE1BQU0sR0FBRyxPQUFPLElBQ3BDLEVBQUUsQ0FDTDs7SUFFTCxPQUFPQyxPQUFPOzs7QUFHdEJKLGVBQUEsQ0FBQU8sb0JBQW9CLENBQUNSLFdBQVcsQ0FBQ1MsU0FBUyxFQUFFLE9BQU8sQ0FBQzs7OztBQUtwRCxTQUFnQkMsaUJBQWlCQSxDQUFBO0VBQzdCLE1BQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNiLFdBQVcsQ0FBQ1MsU0FBUyxDQUFDO0VBQ25EUixlQUFBLENBQUFDLFdBQVcsQ0FBQ1ksSUFBSSxDQUFDSCxNQUFNLENBQUM7RUFDeEJMLFlBQVksQ0FBQ1MsR0FBRyxDQUFDSixNQUFNLEVBQUUsS0FBSyxDQUFDO0VBQy9CLE9BQU9BLE1BQU07Ozs7O0FBTWpCLFNBQWdCSyxXQUFXQSxDQUFDTCxNQUFtQjtFQUMzQyxJQUFJTCxZQUFZLENBQUNDLEdBQUcsQ0FBQ0ksTUFBTSxDQUFDLEtBQUssS0FBSyxFQUFFO0lBQ3BDOztFQUdKTCxZQUFZLENBQUNTLEdBQUcsQ0FBQ0osTUFBTSxFQUFFLElBQUksQ0FBQztFQUM5QkEsTUFBTSxDQUFDTSxhQUFhLENB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QG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9hYm9ydC1zaWduYWwudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9hYm9ydC1jb250cm9sbGVyLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvZXZlbnQubWpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvZXZlbnQtdGFyZ2V0Lm1qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1kb21leGNlcHRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9zdHViL3N5bWJvbC50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2hlbHBlcnMvbWlzY2VsbGFuZW91cy50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9oZWxwZXJzL3dlYmlkbC50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9zaW1wbGUtcXVldWUudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2dlbmVyaWMtcmVhZGVyLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvc3R1Yi9udW1iZXItaXNmaW5pdGUudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9zdHViL21hdGgtdHJ1bmMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9iYXNpYy50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3JlYWRhYmxlLXN0cmVhbS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy90YXJnZXQvZXMyMDE4L3N0dWIvYXN5bmMtaXRlcmF0b3ItcHJvdG90eXBlLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9hc3luYy1pdGVyYXRvci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3N0dWIvbnVtYmVyLWlzbmFuLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0LnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9ieXRlLXN0cmVhbS1jb250cm9sbGVyLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9ieW9iLXJlYWRlci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3kudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNpbmsudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy93cml0YWJsZS1zdHJlYW0udHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYWJvcnQtc2lnbmFsLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3dyaXRhYmxlLXN0cmVhbS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL3N0dWIvbmF0aXZlLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvc3R1Yi9kb20tZXhjZXB0aW9uLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9waXBlLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL3RlZS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi92YWxpZGF0b3JzL3VuZGVybHlpbmctc291cmNlLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvcmVhZGVyLW9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvcGlwZS1vcHRpb25zLnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvcmVhZGFibGUtd3JpdGFibGUtcGFpci50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0udHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5LWluaXQudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvYnl0ZS1sZW5ndGgtcXVldWluZy1zdHJhdGVneS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2xpYi9jb3VudC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uLi9zcmMvbGliL3ZhbGlkYXRvcnMvdHJhbnNmb3JtZXIudHMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4uL3NyYy9saWIvdHJhbnNmb3JtLXN0cmVhbS50cyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9zdHJlYW1zLmNqcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL2ZldGNoLWJsb2IvZnJvbS5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvZm9ybWRhdGEtcG9seWZpbGwvZXNtLm1pbi5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMva3ktdW5pdmVyc2FsL2luZGV4LmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9ib2R5LmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9lcnJvcnMvYWJvcnQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2Vycm9ycy9iYXNlLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9lcnJvcnMvZmV0Y2gtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2hlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL2luZGV4LmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9yZXF1ZXN0LmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy9yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvdXRpbHMvZ2V0LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly9Ab3dsbWVhbnMvcmVnb3YtY29tbS1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9zcmMvdXRpbHMvaXMtcmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vQG93bG1lYW5zL3JlZ292LWNvbW0tc2VydmVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvc3JjL3V0aWxzL2lzLmpzIiwid2VicGFjazovL0Bvd2xtZWFucy9yZWdvdi1jb21tLXNlcnZlci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9yZWZlcnJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIC8vIEV2ZW50LFxuICAgIEV2ZW50VGFyZ2V0LFxuICAgIC8vIFR5cGUsXG4gICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUsXG59IGZyb20gXCJldmVudC10YXJnZXQtc2hpbVwiXG5cbi8vIEtub3duIExpbWl0YXRpb25cbi8vICAgVXNlIGBhbnlgIGJlY2F1c2UgdGhlIHR5cGUgb2YgYEFib3J0U2lnbmFsYCBpbiBgbGliLmRvbS5kLnRzYCBpcyB3cm9uZyBhbmRcbi8vICAgdG8gbWFrZSBhc3NpZ25hYmxlIG91ciBgQWJvcnRTaWduYWxgIGludG8gdGhhdC5cbi8vICAgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UU0pTLWxpYi1nZW5lcmF0b3IvcHVsbC82MjNcbnR5cGUgRXZlbnRzID0ge1xuICAgIGFib3J0OiBhbnkgLy8gRXZlbnQgJiBUeXBlPFwiYWJvcnRcIj5cbn1cbnR5cGUgRXZlbnRBdHRyaWJ1dGVzID0ge1xuICAgIG9uYWJvcnQ6IGFueSAvLyBFdmVudCAmIFR5cGU8XCJhYm9ydFwiPlxufVxuXG4vKipcbiAqIFRoZSBzaWduYWwgY2xhc3MuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRzaWduYWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWJvcnRTaWduYWwgZXh0ZW5kcyBFdmVudFRhcmdldDxFdmVudHMsIEV2ZW50QXR0cmlidXRlcz4ge1xuICAgIC8qKlxuICAgICAqIEFib3J0U2lnbmFsIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFib3J0U2lnbmFsIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgYEFib3J0U2lnbmFsYCdzIGBBYm9ydENvbnRyb2xsZXJgIGhhcyBzaWduYWxlZCB0byBhYm9ydCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYWJvcnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYWJvcnRlZCA9IGFib3J0ZWRGbGFncy5nZXQodGhpcylcbiAgICAgICAgaWYgKHR5cGVvZiBhYm9ydGVkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydFNpZ25hbCcgb2JqZWN0LCBidXQgZ290ICR7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB0aGlzXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFib3J0ZWRcbiAgICB9XG59XG5kZWZpbmVFdmVudEF0dHJpYnV0ZShBYm9ydFNpZ25hbC5wcm90b3R5cGUsIFwiYWJvcnRcIilcblxuLyoqXG4gKiBDcmVhdGUgYW4gQWJvcnRTaWduYWwgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWJvcnRTaWduYWwoKTogQWJvcnRTaWduYWwge1xuICAgIGNvbnN0IHNpZ25hbCA9IE9iamVjdC5jcmVhdGUoQWJvcnRTaWduYWwucHJvdG90eXBlKVxuICAgIEV2ZW50VGFyZ2V0LmNhbGwoc2lnbmFsKVxuICAgIGFib3J0ZWRGbGFncy5zZXQoc2lnbmFsLCBmYWxzZSlcbiAgICByZXR1cm4gc2lnbmFsXG59XG5cbi8qKlxuICogQWJvcnQgYSBnaXZlbiBzaWduYWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydFNpZ25hbChzaWduYWw6IEFib3J0U2lnbmFsKTogdm9pZCB7XG4gICAgaWYgKGFib3J0ZWRGbGFncy5nZXQoc2lnbmFsKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYWJvcnRlZEZsYWdzLnNldChzaWduYWwsIHRydWUpXG4gICAgc2lnbmFsLmRpc3BhdGNoRXZlbnQ8XCJhYm9ydFwiPih7IHR5cGU6IFwiYWJvcnRcIiB9KVxufVxuXG4vKipcbiAqIEFib3J0ZWQgZmxhZyBmb3IgZWFjaCBpbnN0YW5jZXMuXG4gKi9cbmNvbnN0IGFib3J0ZWRGbGFncyA9IG5ldyBXZWFrTWFwPEFib3J0U2lnbmFsLCBib29sZWFuPigpXG5cbi8vIFByb3BlcnRpZXMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydFNpZ25hbC5wcm90b3R5cGUsIHtcbiAgICBhYm9ydGVkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbn0pXG5cbi8vIGB0b1N0cmluZygpYCBzaG91bGQgcmV0dXJuIGBcIltvYmplY3QgQWJvcnRTaWduYWxdXCJgXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRTaWduYWwucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogXCJBYm9ydFNpZ25hbFwiLFxuICAgIH0pXG59XG4iLCJpbXBvcnQgQWJvcnRTaWduYWwsIHsgYWJvcnRTaWduYWwsIGNyZWF0ZUFib3J0U2lnbmFsIH0gZnJvbSBcIi4vYWJvcnQtc2lnbmFsXCJcblxuLyoqXG4gKiBUaGUgQWJvcnRDb250cm9sbGVyLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0Y29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc2lnbmFscy5zZXQodGhpcywgY3JlYXRlQWJvcnRTaWduYWwoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgQWJvcnRTaWduYWxgIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaWduYWwoKTogQWJvcnRTaWduYWwge1xuICAgICAgICByZXR1cm4gZ2V0U2lnbmFsKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJvcnQgYW5kIHNpZ25hbCB0byBhbnkgb2JzZXJ2ZXJzIHRoYXQgdGhlIGFzc29jaWF0ZWQgYWN0aXZpdHkgaXMgdG8gYmUgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJvcnQoKTogdm9pZCB7XG4gICAgICAgIGFib3J0U2lnbmFsKGdldFNpZ25hbCh0aGlzKSlcbiAgICB9XG59XG5cbi8qKlxuICogQXNzb2NpYXRlZCBzaWduYWxzLlxuICovXG5jb25zdCBzaWduYWxzID0gbmV3IFdlYWtNYXA8QWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbD4oKVxuXG4vKipcbiAqIEdldCB0aGUgYXNzb2NpYXRlZCBzaWduYWwgb2YgYSBnaXZlbiBjb250cm9sbGVyLlxuICovXG5mdW5jdGlvbiBnZXRTaWduYWwoY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogQWJvcnRTaWduYWwge1xuICAgIGNvbnN0IHNpZ25hbCA9IHNpZ25hbHMuZ2V0KGNvbnRyb2xsZXIpXG4gICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydENvbnRyb2xsZXInIG9iamVjdCwgYnV0IGdvdCAke1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBjb250cm9sbGVyXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsXG59XG5cbi8vIFByb3BlcnRpZXMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG59KVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFwiQWJvcnRDb250cm9sbGVyXCIsXG4gICAgfSlcbn1cblxuZXhwb3J0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9XG4iLCIvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByaXZhdGVEYXRhXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHt7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50UGhhc2UgVGhlIGN1cnJlbnQgZXZlbnQgcGhhc2UuXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgVGhlIGN1cnJlbnQgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5jZWxlZCBUaGUgZmxhZyB0byBwcmV2ZW50IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW1tZWRpYXRlU3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgVGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJyZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUuIE90aGVyd2lzZSB0aGlzIGlzIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZVN0YW1wIFRoZSB1bml4IHRpbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cbiAqIEB0eXBlIHtXZWFrTWFwPEV2ZW50LCBQcml2YXRlRGF0YT59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwcml2YXRlRGF0YSA9IG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHJldHVybnMge1ByaXZhdGVEYXRhfSBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBkKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudClcbiAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixcbiAgICAgICAgZXZlbnRcbiAgICApXG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNldENhbmNlbEZsYWcoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGRhdGEucGFzc2l2ZUxpc3RlbmVyXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghZGF0YS5ldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSlcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnQudHlwZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY3VycmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRUYXJnZXRbXX0gVGhlIGNvbXBvc2VkIHBhdGggb2YgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBjb21wb3NlZFBhdGgoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGRhdGEuaW1tZWRpYXRlU3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmJ1YmJsZXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGlzIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjb21wb3NlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNvbXBvc2VkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykudGltZVN0YW1wXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgc3JjRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIHN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuc3RvcHBlZFxuICAgIH0sXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAhcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuICAgIHNldCByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBvYmplY3QuIEJ1dCBkbyBub3RoaW5nIHVuZGVyIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGJ1YmJsZSB1cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBjYW5jZWwuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSxcbn1cblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KVxuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgd2luZG93LkV2ZW50LnByb3RvdHlwZSlcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIGEgZ2l2ZW4gbWV0aG9kIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQmFzZUV2ZW50XG4gICAgfVxuXG4gICAgLyoqIEN1c3RvbUV2ZW50ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudClcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSlcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgaWYgKCEoa2V5IGluIEJhc2VFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KVxuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZ2V0IGl0cyB3cmFwcGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBwZXIocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlciA9IHdyYXBwZXJzLmdldChwcm90bylcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSksIHByb3RvKVxuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpXG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogV3JhcCBhIGdpdmVuIGV2ZW50IHRvIG1hbmFnZW1lbnQgYSBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIHdyYXBwZXIgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpXG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZVN0b3BwZWQgZmxhZyBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGdldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuaW1tZWRpYXRlU3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEV2ZW50UGhhc2UoZXZlbnQsIGV2ZW50UGhhc2UpIHtcbiAgICBwZChldmVudCkuZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2Vcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICBwZChldmVudCkuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXNzaXZlTGlzdGVuZXIoZXZlbnQsIHBhc3NpdmVMaXN0ZW5lcikge1xuICAgIHBkKGV2ZW50KS5wYXNzaXZlTGlzdGVuZXIgPSBwYXNzaXZlTGlzdGVuZXJcbn1cbiIsImltcG9ydCB7XG4gICAgaXNTdG9wcGVkLFxuICAgIHNldEN1cnJlbnRUYXJnZXQsXG4gICAgc2V0RXZlbnRQaGFzZSxcbiAgICBzZXRQYXNzaXZlTGlzdGVuZXIsXG4gICAgd3JhcEV2ZW50LFxufSBmcm9tIFwiLi9ldmVudC5tanNcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExpc3RlbmVyTm9kZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7MXwyfDN9IGxpc3RlbmVyVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzaXZlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKVxuXG4vLyBMaXN0ZW5lciB0eXBlc1xuY29uc3QgQ0FQVFVSRSA9IDFcbmNvbnN0IEJVQkJMRSA9IDJcbmNvbnN0IEFUVFJJQlVURSA9IDNcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBwYXJhbSB7YW55fSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxufVxuXG4vKipcbiAqIEdldCBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IHRvIGdldC5cbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+fSBUaGUgbGlzdGVuZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2ZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwLmdldChldmVudFRhcmdldClcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXG4gICAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5saXN0ZW5lclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG5cbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIHJlbW92aW5nIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcbiAgICAgICAgYG9uJHtldmVudE5hbWV9YCxcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSlcbiAgICApXG59XG5cbi8qKlxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgRXZlbnQgbmFtZXMgZm9yIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJucyB7RXZlbnRUYXJnZXR9IFRoZSBjdXN0b20gRXZlbnRUYXJnZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChldmVudE5hbWVzKSB7XG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcylcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSlcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgY29uc3Qgb3B0aW9uc0lzT2JqID0gaXNPYmplY3Qob3B0aW9ucylcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09ialxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKVxuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRVxuICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICBsaXN0ZW5lclR5cGUsXG4gICAgICAgICAgICBwYXNzaXZlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLnBhc3NpdmUpLFxuICAgICAgICAgICAgb25jZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIGNoZWNraW5nIGR1cGxpY2F0aW9uLi5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGl0LlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFXG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuY2VsZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCB0eXBlb2YgZXZlbnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJldmVudC50eXBlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50LnR5cGVcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbm5vdCByZXdyaXRlIHNldmVyYWwgcHJvcGVydGllcywgc28gd3JhcCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudClcblxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgcHJvY2VzcyBjYXB0dXJpbmcgcGhhc2UgYW5kIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgICAvLyBUaGlzIGlzbid0IHBhcnRpY2lwYXRpbmcgaW4gYSB0cmVlLlxuICAgICAgICBsZXQgcHJldiA9IG51bGxcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKFxuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudCxcbiAgICAgICAgICAgICAgICBub2RlLnBhc3NpdmUgPyBub2RlLmxpc3RlbmVyIDogbnVsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmNhbGwodGhpcywgd3JhcHBlZEV2ZW50KVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIGBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIHdhcyBjYWxsZWQuXG4gICAgICAgICAgICBpZiAoaXNTdG9wcGVkKHdyYXBwZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbClcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApXG4gICAgICAgIHNldEN1cnJlbnRUYXJnZXQod3JhcHBlZEV2ZW50LCBudWxsKVxuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufVxuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50VGFyZ2V0LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pXG5cbi8vIEVuc3VyZSBgZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRUYXJnZXRgIGlzIGB0cnVlYC5cbmlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIlxuKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSlcbn1cblxuZXhwb3J0IHsgZGVmaW5lRXZlbnRBdHRyaWJ1dGUsIEV2ZW50VGFyZ2V0IH1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50VGFyZ2V0XG4iLCIvKiEgbm9kZS1kb21leGNlcHRpb24uIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG5cbmlmICghZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IE1lc3NhZ2VDaGFubmVsIH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpLFxuICAgIHBvcnQgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MSxcbiAgICBhYiA9IG5ldyBBcnJheUJ1ZmZlcigpXG4gICAgcG9ydC5wb3N0TWVzc2FnZShhYiwgW2FiLCBhYl0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRE9NRXhjZXB0aW9uJyAmJiAoXG4gICAgICBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbiA9IGVyci5jb25zdHJ1Y3RvclxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uXG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sXCIgLz5cblxuY29uc3QgU3ltYm9sUG9seWZpbGw6IChkZXNjcmlwdGlvbj86IHN0cmluZykgPT4gc3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/XG4gICAgU3ltYm9sIDpcbiAgICBkZXNjcmlwdGlvbiA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWAgYXMgYW55IGFzIHN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sUG9seWZpbGw7XG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpOiB1bmRlZmluZWQge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9IGdldEdsb2JhbHMoKTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBBc3NlcnRpb25FcnJvciB9IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVJc09iamVjdCh4OiBhbnkpOiB4IGlzIG9iamVjdCB7XG4gIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3QgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uOiAoZTogYW55KSA9PiB2b2lkID1cbiAgREVCVUcgPyBlID0+IHtcbiAgICAvLyBVc2VkIHRocm91Z2hvdXQgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiwgYXMgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCwgdG8gZW5zdXJlIGFueSBlcnJvcnNcbiAgICAvLyBnZXQgc2hvd24uIFRoZXJlIGFyZSBwbGFjZXMgaW4gdGhlIHNwZWMgd2hlcmUgd2UgZG8gcHJvbWlzZSB0cmFuc2Zvcm1hdGlvbnMgYW5kIHB1cnBvc2VmdWxseSBpZ25vcmUgb3IgZG9uJ3RcbiAgICAvLyBleHBlY3QgYW55IGVycm9ycywgYnV0IGFzc2VydGlvbiBlcnJvcnMgYXJlIGFsd2F5cyBwcm9ibGVtYXRpYy5cbiAgICBpZiAoZSAmJiBlIGluc3RhbmNlb2YgQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9IDogbm9vcDtcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24gfSBmcm9tICcuL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5cbmNvbnN0IG9yaWdpbmFsUHJvbWlzZSA9IFByb21pc2U7XG5jb25zdCBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbmNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVqZWN0ID0gUHJvbWlzZS5yZWplY3QuYmluZChvcmlnaW5hbFByb21pc2UpO1xuXG5leHBvcnQgZnVuY3Rpb24gbmV3UHJvbWlzZTxUPihleGVjdXRvcjogKFxuICByZXNvbHZlOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZCxcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkXG4pID0+IHZvaWQpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBvcmlnaW5hbFByb21pc2UoZXhlY3V0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aDxUPih2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VSZXNvbHZlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VSZWplY3RlZFdpdGg8VCA9IG5ldmVyPihyZWFzb246IGFueSk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVqZWN0KHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW48VCwgVFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgb25GdWxmaWxsZWQ/OiAodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+LFxuICBvblJlamVjdGVkPzogKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPik6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICAvLyBUaGVyZSBkb2Vzbid0IGFwcGVhciB0byBiZSBhbnkgd2F5IHRvIGNvcnJlY3RseSBlbXVsYXRlIHRoZSBiZWhhdmlvdXIgZnJvbSBKYXZhU2NyaXB0LCBzbyB0aGlzIGlzIGp1c3QgYW5cbiAgLy8gYXBwcm94aW1hdGlvbi5cbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVRoZW4uY2FsbChwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkgYXMgUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwb25Qcm9taXNlPFQ+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBvbkZ1bGZpbGxlZD86ICh2YWx1ZTogVCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICBvblJlamVjdGVkPzogKHJlYXNvbjogYW55KSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pOiB2b2lkIHtcbiAgUGVyZm9ybVByb21pc2VUaGVuKFxuICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCksXG4gICAgdW5kZWZpbmVkLFxuICAgIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvblxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50PFQ+KHByb21pc2U6IFByb21pc2U8VD4sIG9uRnVsZmlsbGVkOiAodmFsdWU6IFQpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPik6IHZvaWQge1xuICB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cG9uUmVqZWN0aW9uKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4sIG9uUmVqZWN0ZWQ6IChyZWFzb246IGFueSkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KTogdm9pZCB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Qcm9taXNlV2l0aDxULCBUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBmdWxmaWxsbWVudEhhbmRsZXI/OiAodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+LFxuICByZWplY3Rpb25IYW5kbGVyPzogKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPik6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4pOiB2b2lkIHtcbiAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbn1cblxuZXhwb3J0IGNvbnN0IHF1ZXVlTWljcm90YXNrOiAoZm46ICgpID0+IHZvaWQpID0+IHZvaWQgPSAoKCkgPT4ge1xuICBjb25zdCBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9IGdsb2JhbHMgJiYgZ2xvYmFscy5xdWV1ZU1pY3JvdGFzaztcbiAgaWYgKHR5cGVvZiBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWxRdWV1ZU1pY3JvdGFzaztcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgcmV0dXJuIChmbjogKCkgPT4gdm9pZCkgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgZm4pO1xufSkoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3RDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiwgVjogVCwgYXJnczogQSk6IFIge1xuICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChGLCBWLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiB8IFByb21pc2VMaWtlPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVjogVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IEEpOiBQcm9taXNlPFI+IHtcbiAgYXNzZXJ0KHR5cGVvZiBGID09PSAnZnVuY3Rpb24nKTtcbiAgYXNzZXJ0KFYgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG4gIH0gY2F0Y2ggKHZhbHVlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICB9XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3N0dWIvYXNzZXJ0JztcblxuLy8gT3JpZ2luYWwgZnJvbSBDaHJvbWl1bVxuLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rLzBhZWU0NDM0YTRkYmE0MmE0MmFiYWVhOWJmYmMwY2QxOTZhNjNiYzEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9zdHJlYW1zL1NpbXBsZVF1ZXVlLmpzXG5cbmNvbnN0IFFVRVVFX01BWF9BUlJBWV9TSVpFID0gMTYzODQ7XG5cbmludGVyZmFjZSBOb2RlPFQ+IHtcbiAgX2VsZW1lbnRzOiBUW107XG4gIF9uZXh0OiBOb2RlPFQ+IHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXG4gKlxuICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXG4gKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxuICovXG5leHBvcnQgY2xhc3MgU2ltcGxlUXVldWU8VD4ge1xuICBwcml2YXRlIF9mcm9udDogTm9kZTxUPjtcbiAgcHJpdmF0ZSBfYmFjazogTm9kZTxUPjtcbiAgcHJpdmF0ZSBfY3Vyc29yID0gMDtcbiAgcHJpdmF0ZSBfc2l6ZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gX2Zyb250IGFuZCBfYmFjayBhcmUgYWx3YXlzIGRlZmluZWQuXG4gICAgdGhpcy5fZnJvbnQgPSB7XG4gICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXG4gICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG4gICAgLy8gZnJvbnQtbW9zdCBub2RlLiBJdCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIFswLCBRVUVVRV9NQVhfQVJSQVlfU0laRSkuXG4gICAgdGhpcy5fY3Vyc29yID0gMDtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cbiAgICB0aGlzLl9zaXplID0gMDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIC8vIEZvciBleGNlcHRpb24gc2FmZXR5LCB0aGlzIG1ldGhvZCBpcyBzdHJ1Y3R1cmVkIGluIG9yZGVyOlxuICAvLyAxLiBSZWFkIHN0YXRlXG4gIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcbiAgLy8gMy4gUGVyZm9ybSBzdGF0ZSBtdXRhdGlvbnNcbiAgcHVzaChlbGVtZW50OiBUKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkQmFjayA9IHRoaXMuX2JhY2s7XG4gICAgbGV0IG5ld0JhY2sgPSBvbGRCYWNrO1xuICAgIGFzc2VydChvbGRCYWNrLl9uZXh0ID09PSB1bmRlZmluZWQpO1xuICAgIGlmIChvbGRCYWNrLl9lbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgbmV3QmFjayA9IHtcbiAgICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBwdXNoKCkgaXMgdGhlIG11dGF0aW9uIG1vc3QgbGlrZWx5IHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gaXRcbiAgICAvLyBnb2VzIGZpcnN0LlxuICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcbiAgICAgIHRoaXMuX2JhY2sgPSBuZXdCYWNrO1xuICAgICAgb2xkQmFjay5fbmV4dCA9IG5ld0JhY2s7XG4gICAgfVxuICAgICsrdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxuICAvLyBleGNlcHRpb24gc2FmZXR5LlxuICBzaGlmdCgpOiBUIHtcbiAgICBhc3NlcnQodGhpcy5fc2l6ZSA+IDApOyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcblxuICAgIGNvbnN0IG9sZEZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgbGV0IG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICAgY29uc3Qgb2xkQ3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgIGxldCBuZXdDdXJzb3IgPSBvbGRDdXJzb3IgKyAxO1xuXG4gICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG5cbiAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuICAgICAgYXNzZXJ0KGVsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpO1xuICAgICAgYXNzZXJ0KG9sZEZyb250Ll9uZXh0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dCE7XG4gICAgICBuZXdDdXJzb3IgPSAwO1xuICAgIH1cblxuICAgIC8vIE5vIG11dGF0aW9ucyBiZWZvcmUgdGhpcyBwb2ludC5cbiAgICAtLXRoaXMuX3NpemU7XG4gICAgdGhpcy5fY3Vyc29yID0gbmV3Q3Vyc29yO1xuICAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICAgIHRoaXMuX2Zyb250ID0gbmV3RnJvbnQ7XG4gICAgfVxuXG4gICAgLy8gUGVybWl0IHNoaWZ0ZWQgZWxlbWVudCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICBlbGVtZW50c1tvbGRDdXJzb3JdID0gdW5kZWZpbmVkITtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gVGhlIHRyaWNreSB0aGluZyBhYm91dCBmb3JFYWNoKCkgaXMgdGhhdCBpdCBjYW4gYmUgY2FsbGVkXG4gIC8vIHJlLWVudHJhbnRseS4gVGhlIHF1ZXVlIG1heSBiZSBtdXRhdGVkIGluc2lkZSB0aGUgY2FsbGJhY2suIEl0IGlzIGVhc3kgdG9cbiAgLy8gc2VlIHRoYXQgcHVzaCgpIHdpdGhpbiB0aGUgY2FsbGJhY2sgaGFzIG5vIG5lZ2F0aXZlIGVmZmVjdHMgc2luY2UgdGhlIGVuZFxuICAvLyBvZiB0aGUgcXVldWUgaXMgY2hlY2tlZCBmb3Igb24gZXZlcnkgaXRlcmF0aW9uLiBJZiBzaGlmdCgpIGlzIGNhbGxlZFxuICAvLyByZXBlYXRlZGx5IHdpdGhpbiB0aGUgY2FsbGJhY2sgdGhlbiB0aGUgbmV4dCBpdGVyYXRpb24gbWF5IHJldHVybiBhblxuICAvLyBlbGVtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZC4gSW4gdGhpcyBjYXNlIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAvLyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgdW50aWwgd2UgZWl0aGVyIFwiY2F0Y2ggdXBcIiB3aXRoIGVsZW1lbnRzIHRoYXQgc3RpbGxcbiAgLy8gZXhpc3Qgb3IgcmVhY2ggdGhlIGJhY2sgb2YgdGhlIHF1ZXVlLlxuICBmb3JFYWNoKGNhbGxiYWNrOiAoZWxlbWVudDogVCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG4gICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpID09PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGFzc2VydChpID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9uZXh0ITtcbiAgICAgICAgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuICAgICAgKytpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgZWxlbWVudCB0aGF0IHdvdWxkIGJlIHJldHVybmVkIGlmIHNoaWZ0KCkgd2FzIGNhbGxlZCBub3csXG4gIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cbiAgcGVlaygpOiBUIHtcbiAgICBhc3NlcnQodGhpcy5fc2l6ZSA+IDApOyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcblxuICAgIGNvbnN0IGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgfVxufVxuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1DYW5jZWwsIFJlYWRhYmxlU3RyZWFtUmVhZGVyIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplPFI+KHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8Uj4sIHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4pIHtcbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3JlYWRlciA9IHJlYWRlcjtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpO1xuXG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG59XG5cbi8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciBhbmQgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZVxuLy8gY2hlY2suXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIGFzc2VydChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3JlYWRlciA9PT0gcmVhZGVyKTtcblxuICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KFxuICAgICAgcmVhZGVyLFxuICAgICAgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQoXG4gICAgICByZWFkZXIsXG4gICAgICBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgfVxuXG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQhO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXInKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4sIHJlYXNvbjogYW55KSB7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4sIHJlYXNvbjogYW55KSB7XG4gIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHJlYWRlci5fY2xvc2VkUHJvbWlzZSk7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4sIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG59XG4iLCJleHBvcnQgY29uc3QgQWJvcnRTdGVwcyA9IFN5bWJvbCgnW1tBYm9ydFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBFcnJvclN0ZXBzID0gU3ltYm9sKCdbW0Vycm9yU3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sKCdbW0NhbmNlbFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBQdWxsU3RlcHMgPSBTeW1ib2woJ1tbUHVsbFN0ZXBzXV0nKTtcbiIsIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlI1BvbHlmaWxsXG5jb25zdCBOdW1iZXJJc0Zpbml0ZTogdHlwZW9mIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTnVtYmVySXNGaW5pdGU7XG4iLCIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmMjUG9seWZpbGxcbmNvbnN0IE1hdGhUcnVuYzogdHlwZW9mIE1hdGgudHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB2IDwgMCA/IE1hdGguY2VpbCh2KSA6IE1hdGguZmxvb3Iodik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXRoVHJ1bmM7XG4iLCJpbXBvcnQgTnVtYmVySXNGaW5pdGUgZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNmaW5pdGUnO1xuaW1wb3J0IE1hdGhUcnVuYyBmcm9tICcuLi8uLi9zdHViL21hdGgtdHJ1bmMnO1xuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXG5leHBvcnQgZnVuY3Rpb24gaXNEaWN0aW9uYXJ5KHg6IGFueSk6IHggaXMgb2JqZWN0IHwgbnVsbCB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iajogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgb2JqIGlzIG9iamVjdCB8IG51bGwgfCB1bmRlZmluZWQge1xuICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgIWlzRGljdGlvbmFyeShvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFueUZ1bmN0aW9uID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgQW55RnVuY3Rpb24ge1xuICBpZiAodHlwZW9mIHggIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1vYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh4OiBhbnkpOiB4IGlzIG9iamVjdCB7XG4gIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHg6IHVua25vd24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBvYmplY3Qge1xuICBpZiAoIWlzT2JqZWN0KHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50PFQgZXh0ZW5kcyBhbnk+KHg6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFQge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRGaWVsZDxUIGV4dGVuZHMgYW55Pih4OiBUIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBUIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmllbGR9IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5yZXN0cmljdGVkLWRvdWJsZVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWU6IHVua25vd24pOiBudW1iZXIge1xuICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIGludGVnZXJQYXJ0KHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgpKTtcbn1cblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVuc2lnbmVkLWxvbmctbG9uZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZTogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICBsZXQgeCA9IE51bWJlcih2YWx1ZSk7XG4gIHggPSBjZW5zb3JOZWdhdGl2ZVplcm8oeCk7XG5cbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZmluaXRlIG51bWJlcmApO1xuICB9XG5cbiAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXG4gIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgKTtcbiAgfVxuXG4gIGlmICghTnVtYmVySXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVE9ETyBVc2UgQmlnSW50IGlmIHN1cHBvcnRlZD9cbiAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuICAvLyB4QmlnSW50ID0gQmlnSW50LmFzVWludE4oNjQsIHhCaWdJbnQpO1xuICAvLyByZXR1cm4gTnVtYmVyKHhCaWdJbnQpO1xuXG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeDogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFJlYWRhYmxlU3RyZWFtIHtcbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBSZWFkYWJsZVN0cmVhbS5gKTtcbiAgfVxufVxuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UsXG4gIHJlYWRlckxvY2tFeGNlcHRpb25cbn0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgUHVsbFN0ZXBzIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlamVjdGVkV2l0aCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGFzc2VydFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9yZWFkYWJsZS1zdHJlYW0nO1xuXG4vKipcbiAqIEEgcmVzdWx0IHJldHVybmVkIGJ5IHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFQ+ID0ge1xuICBkb25lOiBmYWxzZTtcbiAgdmFsdWU6IFQ7XG59IHwge1xuICBkb25lOiB0cnVlO1xuICB2YWx1ZT86IHVuZGVmaW5lZDtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbn1cblxuLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdDxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0uX3JlYWRlcikpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgKHN0cmVhbS5fcmVhZGVyISBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4pLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdDxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LCBjaHVuazogUiB8IHVuZGVmaW5lZCwgZG9uZTogYm9vbGVhbikge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj47XG5cbiAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKSE7XG4gIGlmIChkb25lKSB7XG4gICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgfSBlbHNlIHtcbiAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayEpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0czxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KTogbnVtYmVyIHtcbiAgcmV0dXJuIChzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4pLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IGludGVyZmFjZSBSZWFkUmVxdWVzdDxSPiB7XG4gIF9jaHVua1N0ZXBzKGNodW5rOiBSKTogdm9pZDtcblxuICBfY2xvc2VTdGVwcygpOiB2b2lkO1xuXG4gIF9lcnJvclN0ZXBzKGU6IGFueSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX293bmVyUmVhZGFibGVTdHJlYW0hOiBSZWFkYWJsZVN0cmVhbTxSPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZFJlcXVlc3RzOiBTaW1wbGVRdWV1ZTxSZWFkUmVxdWVzdDxSPj47XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPikge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyk7XG4gICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cbiAgICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCxcbiAgICogb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvciB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgKi9cbiAgZ2V0IGNsb3NlZCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAqL1xuICBjYW5jZWwocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgKi9cbiAgcmVhZCgpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlITogKHJlc3VsdDogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPikgPT4gdm9pZDtcbiAgICBsZXQgcmVqZWN0UHJvbWlzZSE6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pLFxuICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSID0gYW55Pih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkUmVxdWVzdHMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZDxSPihyZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPik6IHZvaWQge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG4gICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCBhcyBSZWFkUmVxdWVzdDxhbnk+KTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJgKTtcbn1cbiIsIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5leHBvcnQgY29uc3QgQXN5bmNJdGVyYXRvclByb3RvdHlwZTogQXN5bmNJdGVyYWJsZTxhbnk+IHwgdW5kZWZpbmVkID1cbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxhbnk+IHt9KS5wcm90b3R5cGUpO1xuIiwiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuXG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQsXG4gIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBBc3luY0l0ZXJhdG9yUHJvdG90eXBlIH0gZnJvbSAnQEB0YXJnZXQvc3R1Yi9hc3luYy1pdGVyYXRvci1wcm90b3R5cGUnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7XG4gIG5ld1Byb21pc2UsXG4gIHByb21pc2VSZWplY3RlZFdpdGgsXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHF1ZXVlTWljcm90YXNrLFxuICB0cmFuc2Zvcm1Qcm9taXNlV2l0aFxufSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5cbi8qKlxuICogQW4gYXN5bmMgaXRlcmF0b3IgcmV0dXJuZWQgYnkge0BsaW5rIFJlYWRhYmxlU3RyZWFtLnZhbHVlc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiBleHRlbmRzIEFzeW5jSXRlcmF0b3I8Uj4ge1xuICBuZXh0KCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8UiwgdW5kZWZpbmVkPj47XG5cbiAgcmV0dXJuKHZhbHVlPzogYW55KTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxhbnk+Pjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw8Uj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPjtcbiAgcHJpdmF0ZSByZWFkb25seSBfcHJldmVudENhbmNlbDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfb25nb2luZ1Byb21pc2U6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX2lzRmluaXNoZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihyZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiwgcHJldmVudENhbmNlbDogYm9vbGVhbikge1xuICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcbiAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcbiAgfVxuXG4gIG5leHQoKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB7XG4gICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG4gICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgbmV4dFN0ZXBzLCBuZXh0U3RlcHMpIDpcbiAgICAgIG5leHRTdGVwcygpO1xuICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcbiAgfVxuXG4gIHJldHVybih2YWx1ZTogYW55KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xuICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIHJldHVyblN0ZXBzLCByZXR1cm5TdGVwcykgOlxuICAgICAgcmV0dXJuU3RlcHMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX25leHRTdGVwcygpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignaXRlcmF0ZScpKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBieSBvbmUgbWljcm90YXNrLCBvdGhlcndpc2Ugd2Ugc3RvcCBwdWxsaW5nIHRvbyBlYXJseSB3aGljaCBicmVha3MgYSB0ZXN0LlxuICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pKTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgfSxcbiAgICAgIF9lcnJvclN0ZXBzOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgcmVqZWN0UHJvbWlzZShyZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgX3JldHVyblN0ZXBzKHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgfVxuICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignZmluaXNoIGl0ZXJhdGluZycpKTtcbiAgICB9XG5cbiAgICBhc3NlcnQocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID09PSAwKTtcblxuICAgIGlmICghdGhpcy5fcHJldmVudENhbmNlbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgdmFsdWUpO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHJlc3VsdCwgKCkgPT4gKHsgdmFsdWUsIGRvbmU6IHRydWUgfSkpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICB9XG59XG5cbmRlY2xhcmUgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8Uj4gaW1wbGVtZW50cyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4ge1xuICAvKiogQGludGVyYWwgKi9cbiAgX2FzeW5jSXRlcmF0b3JJbXBsOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsPFI+O1xuXG4gIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxSLCB1bmRlZmluZWQ+PjtcblxuICByZXR1cm4odmFsdWU/OiBhbnkpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PGFueT4+O1xufVxuXG5jb25zdCBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGU6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4gPSB7XG4gIG5leHQodGhpczogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55Pik6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ25leHQnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5uZXh0KCk7XG4gIH0sXG5cbiAgcmV0dXJuKHRoaXM6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4sIHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuICB9XG59IGFzIGFueTtcbmlmIChBc3luY0l0ZXJhdG9yUHJvdG90eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuZXhwb3J0IGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IGJvb2xlYW4pOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4ge1xuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbSk7XG4gIGNvbnN0IGltcGwgPSBuZXcgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbChyZWFkZXIsIHByZXZlbnRDYW5jZWwpO1xuICBjb25zdCBpdGVyYXRvcjogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8Uj4gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gIGl0ZXJhdG9yLl9hc3luY0l0ZXJhdG9ySW1wbCA9IGltcGw7XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8UiA9IGFueT4oeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvckltcGwnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gbm9pbnNwZWN0aW9uIFN1c3BpY2lvdXNUeXBlT2ZHdWFyZFxuICAgIHJldHVybiAoeCBhcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxhbnk+KS5fYXN5bmNJdGVyYXRvckltcGwgaW5zdGFuY2VvZlxuICAgICAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0ZWFtQXN5bmNJdGVyYXRvcmApO1xufVxuIiwiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU4jUG9seWZpbGxcbmNvbnN0IE51bWJlcklzTmFOOiB0eXBlb2YgTnVtYmVyLmlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggIT09IHg7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJJc05hTjtcbiIsImV4cG9ydCBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0PFQgZXh0ZW5kcyBhbnlbXT4oZWxlbWVudHM6IFQpOiBUIHtcbiAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG4gIC8vIERvIGEgc2xpY2UgdGhvdWdoIGp1c3QgaW4gY2FzZSB3ZSBoYXBwZW4gdG8gZGVwZW5kIG9uIHRoZSB1bmlxdWUtbmVzcy5cbiAgcmV0dXJuIGVsZW1lbnRzLnNsaWNlKCkgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvcHlEYXRhQmxvY2tCeXRlcyhkZXN0OiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE9mZnNldDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogbnVtYmVyKSB7XG4gIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xufVxuXG4vLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmZXJBcnJheUJ1ZmZlcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJMaWtlPihPOiBUKTogVCB7XG4gIHJldHVybiBPO1xufVxuXG4vLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcihPOiBBcnJheUJ1ZmZlckxpa2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBmdW5jdGlvbiBJc0RldGFjaGVkQnVmZmVyKE86IEFycmF5QnVmZmVyTGlrZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcnJheUJ1ZmZlclNsaWNlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBiZWdpbjogbnVtYmVyLCBlbmQ6IG51bWJlcik6IEFycmF5QnVmZmVyTGlrZSB7XG4gIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcbiAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2VcbiAgaWYgKGJ1ZmZlci5zbGljZSkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gZW5kIC0gYmVnaW47XG4gIGNvbnN0IHNsaWNlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gIENvcHlEYXRhQmxvY2tCeXRlcyhzbGljZSwgMCwgYnVmZmVyLCBiZWdpbiwgbGVuZ3RoKTtcbiAgcmV0dXJuIHNsaWNlO1xufVxuIiwiaW1wb3J0IE51bWJlcklzTmFOIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzbmFuJztcbmltcG9ydCB7IEFycmF5QnVmZmVyU2xpY2UgfSBmcm9tICcuL2VjbWFzY3JpcHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2OiBudW1iZXIpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChOdW1iZXJJc05hTih2KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2xvbmVBc1VpbnQ4QXJyYXkoTzogQXJyYXlCdWZmZXJWaWV3KTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEFycmF5QnVmZmVyU2xpY2UoTy5idWZmZXIsIE8uYnl0ZU9mZnNldCwgTy5ieXRlT2Zmc2V0ICsgTy5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL21pc2NlbGxhbmVvdXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlQ29udGFpbmVyPFQ+IHtcbiAgX3F1ZXVlOiBTaW1wbGVRdWV1ZTxUPjtcbiAgX3F1ZXVlVG90YWxTaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVQYWlyPFQ+IHtcbiAgdmFsdWU6IFQ7XG4gIHNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlcXVldWVWYWx1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4pOiBUIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuICBhc3NlcnQoY29udGFpbmVyLl9xdWV1ZS5sZW5ndGggPiAwKTtcblxuICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpITtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG4gIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHBhaXIudmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4sIHZhbHVlOiBULCBzaXplOiBudW1iZXIpIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuXG4gIGlmICghSXNOb25OZWdhdGl2ZU51bWJlcihzaXplKSB8fCBzaXplID09PSBJbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gIH1cblxuICBjb250YWluZXIuX3F1ZXVlLnB1c2goeyB2YWx1ZSwgc2l6ZSB9KTtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBzaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxRdWV1ZVBhaXI8VD4+KTogVCB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcbiAgYXNzZXJ0KGNvbnRhaW5lci5fcXVldWUubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUucGVlaygpO1xuICByZXR1cm4gcGFpci52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlc2V0UXVldWU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxUPikge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG5cbiAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZTxUPigpO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgUmVzZXRRdWV1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyxcbiAgUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyLFxuICBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyxcbiAgUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyLFxuICBSZWFkSW50b1JlcXVlc3Rcbn0gZnJvbSAnLi9ieW9iLXJlYWRlcic7XG5pbXBvcnQgTnVtYmVySXNJbnRlZ2VyIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzaW50ZWdlcic7XG5pbXBvcnQge1xuICBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Jcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFZhbGlkYXRlZFVuZGVybHlpbmdCeXRlU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtcbiAgQXJyYXlCdWZmZXJTbGljZSxcbiAgQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcixcbiAgQ29weURhdGFCbG9ja0J5dGVzLFxuICBJc0RldGFjaGVkQnVmZmVyLFxuICBUcmFuc2ZlckFycmF5QnVmZmVyXG59IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IENhbmNlbFN0ZXBzLCBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBwcm9taXNlUmVzb2x2ZWRXaXRoLCB1cG9uUHJvbWlzZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQsIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvYmFzaWMnO1xuXG4vKipcbiAqIEEgcHVsbC1pbnRvIHJlcXVlc3QgaW4gYSB7QGxpbmsgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyITogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdmlldyE6IEFycmF5QnVmZmVyVmlldyB8IG51bGw7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlldyBmb3Igd3JpdGluZyBpbiB0bywgb3IgYG51bGxgIGlmIHRoZSBCWU9CIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXNwb25kZWQgdG8uXG4gICAqL1xuICBnZXQgdmlldygpOiBBcnJheUJ1ZmZlclZpZXcgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCd2aWV3Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRvIHRoZSBhc3NvY2lhdGVkIHJlYWRhYmxlIGJ5dGUgc3RyZWFtIHRoYXQgYGJ5dGVzV3JpdHRlbmAgYnl0ZXMgd2VyZSB3cml0dGVuIGludG9cbiAgICoge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QudmlldyB8IHZpZXd9LCBjYXVzaW5nIHRoZSByZXN1bHQgYmUgc3VyZmFjZWQgdG8gdGhlIGNvbnN1bWVyLlxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSB3aWxsIGJlIHRyYW5zZmVycmVkIGFuZCBubyBsb25nZXJcbiAgICogbW9kaWZpYWJsZS5cbiAgICovXG4gIHJlc3BvbmQoYnl0ZXNXcml0dGVuOiBudW1iZXIpOiB2b2lkO1xuICByZXNwb25kKGJ5dGVzV3JpdHRlbjogbnVtYmVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuICAgIH1cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcbiAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3IS5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgQllPQiByZXF1ZXN0J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlYCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuX3ZpZXchLmJ5dGVMZW5ndGggPiAwKTtcbiAgICBhc3NlcnQodGhpcy5fdmlldyEuYnVmZmVyLmJ5dGVMZW5ndGggPiAwKTtcblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0byB0aGUgYXNzb2NpYXRlZCByZWFkYWJsZSBieXRlIHN0cmVhbSB0aGF0IGluc3RlYWQgb2Ygd3JpdGluZyBpbnRvXG4gICAqIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSwgdGhlIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2UgaXMgcHJvdmlkaW5nIGEgbmV3IGBBcnJheUJ1ZmZlclZpZXdgLFxuICAgKiB3aGljaCB3aWxsIGJlIGdpdmVuIHRvIHRoZSBjb25zdW1lciBvZiB0aGUgcmVhZGFibGUgYnl0ZSBzdHJlYW0uXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYHZpZXdgIHdpbGwgYmUgdHJhbnNmZXJyZWQgYW5kIG5vIGxvbmdlciBtb2RpZmlhYmxlLlxuICAgKi9cbiAgcmVzcG9uZFdpdGhOZXdWaWV3KHZpZXc6IEFycmF5QnVmZmVyVmlldyk6IHZvaWQ7XG4gIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3OiBBcnJheUJ1ZmZlclZpZXcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh2aWV3LCAxLCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmludGVyZmFjZSBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXJWaWV3PiB7XG4gIG5ldyhidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgYnl0ZU9mZnNldDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBUO1xuXG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVDtcbiAgcmVhZG9ubHkgQllURVNfUEVSX0VMRU1FTlQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEJ5dGVRdWV1ZUVsZW1lbnQge1xuICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZTtcbiAgYnl0ZU9mZnNldDogbnVtYmVyO1xuICBieXRlTGVuZ3RoOiBudW1iZXI7XG59XG5cbnR5cGUgUHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlclZpZXc+ID1cbiAgRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvclxuICB8IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD47XG5cbmludGVyZmFjZSBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yIHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2U7XG4gIGJ1ZmZlckJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZU9mZnNldDogbnVtYmVyO1xuICBieXRlTGVuZ3RoOiBudW1iZXI7XG4gIGJ5dGVzRmlsbGVkOiBudW1iZXI7XG4gIGVsZW1lbnRTaXplOiBudW1iZXI7XG4gIHZpZXdDb25zdHJ1Y3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VWludDhBcnJheT47XG4gIHJlYWRlclR5cGU6ICdkZWZhdWx0Jztcbn1cblxuaW50ZXJmYWNlIEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyVmlldz4ge1xuICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZTtcbiAgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZXNGaWxsZWQ6IG51bWJlcjtcbiAgZWxlbWVudFNpemU6IG51bWJlcjtcbiAgdmlld0NvbnN0cnVjdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPjtcbiAgcmVhZGVyVHlwZTogJ2J5b2InO1xufVxuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgYnl0ZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtITogUmVhZGFibGVCeXRlU3RyZWFtO1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPEJ5dGVRdWV1ZUVsZW1lbnQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZVRvdGFsU2l6ZSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhcnRlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFnYWluITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbGluZyAhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2J5b2JSZXF1ZXN0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcGVuZGluZ1B1bGxJbnRvcyE6IFNpbXBsZVF1ZXVlPFB1bGxJbnRvRGVzY3JpcHRvcj47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBCWU9CIHB1bGwgcmVxdWVzdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICovXG4gIGdldCBieW9iUmVxdWVzdCgpOiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgY2h1bmsgaW4gdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLlxuICAgKiBUaGUgY2h1bmsgaGFzIHRvIGJlIGFuIGBBcnJheUJ1ZmZlclZpZXdgIGluc3RhbmNlLCBvciBlbHNlIGEgYFR5cGVFcnJvcmAgd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpOiB2b2lkO1xuICBlbnF1ZXVlKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChjaHVuaywgMSwgJ2VucXVldWUnKTtcbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICAgfVxuICAgIGlmIChjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcnJvcnMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICovXG4gIGVycm9yKGU6IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbQ2FuY2VsU3RlcHNdKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcblxuICAgIFJlc2V0UXVldWUodGhpcyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxVaW50OEFycmF5Pik6IHZvaWQge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgYXNzZXJ0KFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKTtcblxuICAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgIGFzc2VydChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKTtcblxuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpITtcbiAgICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKHRoaXMpO1xuXG4gICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcblxuICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHModmlldyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGJ1ZmZlckUpIHtcbiAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yOiBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICBidWZmZXIsXG4gICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgYnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICBieXRlc0ZpbGxlZDogMCxcbiAgICAgICAgZWxlbWVudFNpemU6IDEsXG4gICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogVWludDhBcnJheSxcbiAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgYnlvYlJlcXVlc3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHg6IGFueSk6IHggaXMgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Qge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IHZvaWQge1xuICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXG4gIC8vIFRPRE86IFRlc3QgY29udHJvbGxlciBhcmd1bWVudFxuICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHVsbFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGUgPT4ge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihcbiAgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yPFQ+XG4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgIT09ICdlcnJvcmVkJyk7XG5cbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA9PT0gMCk7XG4gICAgZG9uZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VD4ocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcgYXMgdW5rbm93biBhcyBVaW50OEFycmF5LCBkb25lKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdieW9iJyk7XG4gICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oXG4gIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yPFQ+XG4pOiBUIHtcbiAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXG4gIGFzc2VydChieXRlc0ZpbGxlZCA8PSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCk7XG4gIGFzc2VydChieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplID09PSAwKTtcblxuICByZXR1cm4gbmV3IHB1bGxJbnRvRGVzY3JpcHRvci52aWV3Q29uc3RydWN0b3IoXG4gICAgcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGJ5dGVzRmlsbGVkIC8gZWxlbWVudFNpemUpIGFzIFQ7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IG51bWJlcikge1xuICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG5cbiAgY29uc3QgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXG4gIGNvbnN0IG1heEJ5dGVzVG9Db3B5ID0gTWF0aC5taW4oY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICBjb25zdCBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuICBjb25zdCBtYXhBbGlnbmVkQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAtIG1heEJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG5cbiAgbGV0IHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcbiAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG4gICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICByZWFkeSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuXG4gIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xuICAgIGNvbnN0IGhlYWRPZlF1ZXVlID0gcXVldWUucGVlaygpO1xuXG4gICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcblxuICAgIGNvbnN0IGRlc3RTdGFydCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgIENvcHlEYXRhQmxvY2tCeXRlcyhwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBkZXN0U3RhcnQsIGhlYWRPZlF1ZXVlLmJ1ZmZlciwgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCwgYnl0ZXNUb0NvcHkpO1xuXG4gICAgaWYgKGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggPT09IGJ5dGVzVG9Db3B5KSB7XG4gICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xuICAgICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcbiAgICB9XG4gICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgLT0gYnl0ZXNUb0NvcHk7XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNUb0NvcHksIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xuICB9XG5cbiAgaWYgKCFyZWFkeSkge1xuICAgIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA+IDApO1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIHJlYWR5O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID09PSAwIHx8IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpID09PSBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICBhc3NlcnQoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpO1xuICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKz0gc2l6ZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBhc3NlcnQoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsITtcbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCk7XG5cbiAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXG4gICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICB2aWV3OiBULFxuICByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPlxuKTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgbGV0IGVsZW1lbnRTaXplID0gMTtcbiAgaWYgKHZpZXcuY29uc3RydWN0b3IgIT09IERhdGFWaWV3KSB7XG4gICAgZWxlbWVudFNpemUgPSAodmlldy5jb25zdHJ1Y3RvciBhcyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPikuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cblxuICBjb25zdCBjdG9yID0gdmlldy5jb25zdHJ1Y3RvciBhcyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPjtcblxuICAvLyB0cnkge1xuICBjb25zdCBidWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgLy8gfSBjYXRjaCAoZSkge1xuICAvLyAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgLy8gICByZXR1cm47XG4gIC8vIH1cblxuICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3I6IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD4gPSB7XG4gICAgYnVmZmVyLFxuICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgIGJ5dGVPZmZzZXQ6IHZpZXcuYnl0ZU9mZnNldCxcbiAgICBieXRlTGVuZ3RoOiB2aWV3LmJ5dGVMZW5ndGgsXG4gICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgZWxlbWVudFNpemUsXG4gICAgdmlld0NvbnN0cnVjdG9yOiBjdG9yLFxuICAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICB9O1xuXG4gIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcbiAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXG4gICAgLy8gLSBUaGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gbm90aWZpZWQgb2YgdGhhdCB0aGVyZSdzIGF0IGxlYXN0IDEgcGVuZGluZyByZWFkKHZpZXcpXG5cbiAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgY29uc3QgZW1wdHlWaWV3ID0gbmV3IGN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIDApO1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhlbXB0eVZpZXcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yPFQ+KHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xuXG4gICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Q8VD4oc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3REZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgYXNzZXJ0KGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA9PT0gMCk7XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1dyaXR0ZW46IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPD0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGgpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblxuICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICBjb25zdCByZW1haW5kZXIgPSBBcnJheUJ1ZmZlclNsaWNlKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGVuZCAtIHJlbWFpbmRlclNpemUsIGVuZCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgcmVtYWluZGVyLCAwLCByZW1haW5kZXIuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLT0gcmVtYWluZGVyU2l6ZTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuOiBudW1iZXIpIHtcbiAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gIGFzc2VydChDYW5UcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBhc3NlcnQoYnl0ZXNXcml0dGVuID09PSAwKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGFzc2VydChieXRlc1dyaXR0ZW4gPiAwKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIGZpcnN0RGVzY3JpcHRvcik7XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG4pOiBQdWxsSW50b0Rlc2NyaXB0b3Ige1xuICBhc3NlcnQoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpITtcbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICBhc3NlcnQoZGVzaXJlZFNpemUgIT09IG51bGwpO1xuICBpZiAoZGVzaXJlZFNpemUhID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG4gICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IGNodW5rLmJ1ZmZlcjtcbiAgY29uc3QgYnl0ZU9mZnNldCA9IGNodW5rLmJ5dGVPZmZzZXQ7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoO1xuICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmtcXCdzIGJ1ZmZlciBpcyBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGVucXVldWVkJyk7XG4gIH1cbiAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBCWU9CIHJlcXVlc3RcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGZpbGxlZCB3aXRoIGFuIGVucXVldWVkIGNodW5rJ1xuICAgICAgKTtcbiAgICB9XG4gICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpIHtcbiAgICBpZiAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID09PSAwKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCk7XG4gICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKS5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIHRyYW5zZmVycmVkVmlldywgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgIC8vIFRPRE86IElkZWFsbHkgaW4gdGhpcyBicmFuY2ggZGV0YWNoaW5nIHNob3VsZCBoYXBwZW4gb25seSBpZiB0aGUgYnVmZmVyIGlzIG5vdCBjb25zdW1lZCBmdWxseS5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoIUlzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgZTogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpO1xuXG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxuKTogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB8IG51bGwge1xuICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyk7XG4gICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBieW9iUmVxdWVzdDtcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5fYnlvYlJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbjogbnVtYmVyKSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgIH1cbiAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICB9XG5cbiAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogQXJyYXlCdWZmZXJWaWV3KSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcblxuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0Jyk7XG4gIH1cbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuICB9XG5cbiAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCB2aWV3Qnl0ZUxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gIGFzc2VydChzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcbiAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0KE51bWJlcklzSW50ZWdlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpKTtcbiAgICBhc3NlcnQoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID4gMCk7XG4gIH1cblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtID0gc3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cbiAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsaW5nKTtcbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIHVuZGVybHlpbmdCeXRlU291cmNlOiBWYWxpZGF0ZWRVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgaGlnaFdhdGVyTWFyazogbnVtYmVyXG4pIHtcbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+ID0gKCkgPT4gdW5kZWZpbmVkO1xuICBsZXQgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsIShjb250cm9sbGVyKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsIShyZWFzb24pO1xuICB9XG5cbiAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0b0FsbG9jYXRlQ2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgfVxuXG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZVxuICApO1xufVxuXG5mdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QocmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IEFycmF5QnVmZmVyVmlldykge1xuICBhc3NlcnQoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKGNvbnRyb2xsZXIpKTtcbiAgYXNzZXJ0KHR5cGVvZiB2aWV3ID09PSAnb2JqZWN0Jyk7XG4gIGFzc2VydChBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcbiAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QuXG5cbmZ1bmN0aW9uIGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblxuZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSxcbiAgcmVhZGVyTG9ja0V4Y2VwdGlvblxufSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7IElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsIFJlYWRhYmxlQnl0ZVN0cmVhbSwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG9cbn0gZnJvbSAnLi9ieXRlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVqZWN0ZWRXaXRoIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi92YWxpZGF0b3JzL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBJc0RldGFjaGVkQnVmZmVyIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuXG4vKipcbiAqIEEgcmVzdWx0IHJldHVybmVkIGJ5IHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+ID0ge1xuICBkb25lOiBmYWxzZTtcbiAgdmFsdWU6IFQ7XG59IHwge1xuICBkb25lOiB0cnVlO1xuICB2YWx1ZTogVCB8IHVuZGVmaW5lZDtcbn07XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuZXhwb3J0IGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xufVxuXG4vLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPik6IHZvaWQge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtLl9yZWFkZXIpKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpO1xuXG4gIChzdHJlYW0uX3JlYWRlciEgYXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKS5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBBcnJheUJ1ZmZlclZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGJvb2xlYW4pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXIgYXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuXG4gIGFzc2VydChyZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnNoaWZ0KCkhO1xuICBpZiAoZG9uZSkge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogbnVtYmVyIHtcbiAgcmV0dXJuIChzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIpLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUmVhZGVyc1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRJbnRvUmVxdWVzdDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PiB7XG4gIF9jaHVua1N0ZXBzKGNodW5rOiBUKTogdm9pZDtcblxuICBfY2xvc2VTdGVwcyhjaHVuazogVCB8IHVuZGVmaW5lZCk6IHZvaWQ7XG5cbiAgX2Vycm9yU3RlcHMoZTogYW55KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIEJZT0IgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZEludG9SZXF1ZXN0czogU2ltcGxlUXVldWU8UmVhZEludG9SZXF1ZXN0PGFueT4+O1xuXG4gIGNvbnN0cnVjdG9yKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInKTtcbiAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgIH1cblxuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlICcgK1xuICAgICAgICAnc291cmNlJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuXG4gICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG4gICAqIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZWFkcyBieXRlcyBpbnRvIHZpZXcsIGFuZCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgKi9cbiAgcmVhZDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3Pih2aWV3OiBUKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0PFQ+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcbiAgICB9XG4gICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpKTtcbiAgICB9XG4gICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYHZpZXcncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKSk7XG4gICAgfVxuICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlld1xcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0PFQ+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiB0cnVlIH0pLFxuICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICpcbiAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cbiAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcmVsZWFzZUxvY2soKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRJbnRvUmVxdWVzdHMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIHZpZXc6IFQsXG4gIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+XG4pOiB2b2lkIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKFxuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgIHZpZXcsXG4gICAgICByZWFkSW50b1JlcXVlc3RcbiAgICApO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIuXG5cbmZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcmApO1xufVxuIiwiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCBOdW1iZXJJc05hTiBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc25hbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5LCBkZWZhdWx0SFdNOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB7IGhpZ2hXYXRlck1hcmsgfSA9IHN0cmF0ZWd5O1xuXG4gIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGVmYXVsdEhXTTtcbiAgfVxuXG4gIGlmIChOdW1iZXJJc05hTihoaWdoV2F0ZXJNYXJrKSB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcbiAgfVxuXG4gIHJldHVybiBoaWdoV2F0ZXJNYXJrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRXh0cmFjdFNpemVBbGdvcml0aG08VD4oc3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxUPik6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPiB7XG4gIGNvbnN0IHsgc2l6ZSB9ID0gc3RyYXRlZ3k7XG5cbiAgaWYgKCFzaXplKSB7XG4gICAgcmV0dXJuICgpID0+IDE7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiwgY29udmVydFVucmVzdHJpY3RlZERvdWJsZSB9IGZyb20gJy4vYmFzaWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneTxUPihpbml0OiBRdWV1aW5nU3RyYXRlZ3k8VD4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUXVldWluZ1N0cmF0ZWd5PFQ+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQ/LmhpZ2hXYXRlck1hcms7XG4gIGNvbnN0IHNpemUgPSBpbml0Py5zaXplO1xuICByZXR1cm4ge1xuICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG4gICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplPFQ+KGZuOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8VD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBjaHVuayA9PiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XG59XG4iLCJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgcHJvbWlzZUNhbGwsIHJlZmxlY3RDYWxsIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgVW5kZXJseWluZ1NpbmssXG4gIFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayxcbiAgVmFsaWRhdGVkVW5kZXJseWluZ1Npbmtcbn0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtL3VuZGVybHlpbmctc2luayc7XG5pbXBvcnQgeyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIH0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2luazxXPihvcmlnaW5hbDogVW5kZXJseWluZ1Npbms8Vz4gfCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBWYWxpZGF0ZWRVbmRlcmx5aW5nU2luazxXPiB7XG4gIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICBjb25zdCBhYm9ydCA9IG9yaWdpbmFsPy5hYm9ydDtcbiAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbD8uY2xvc2U7XG4gIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWw/LnN0YXJ0O1xuICBjb25zdCB0eXBlID0gb3JpZ2luYWw/LnR5cGU7XG4gIGNvbnN0IHdyaXRlID0gb3JpZ2luYWw/LndyaXRlO1xuICByZXR1cm4ge1xuICAgIGFib3J0OiBhYm9ydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Fib3J0JyB0aGF0YCksXG4gICAgY2xvc2U6IGNsb3NlID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soY2xvc2UsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2xvc2UnIHRoYXRgKSxcbiAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgIHdyaXRlOiB3cml0ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRlJyB0aGF0YCksXG4gICAgdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKHJlYXNvbjogYW55KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhcbiAgZm46IFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rLFxuICBjb250ZXh0OiBzdHJpbmdcbik6ICgpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhcbiAgZm46IFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2s8Vz4oXG4gIGZuOiBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2s8Vz4sXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luazxXPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY2h1bms6IFcsIGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY2h1bms6IFcsIGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG59XG4iLCJpbXBvcnQgeyBJc1dyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRXcml0YWJsZVN0cmVhbSh4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgV3JpdGFibGVTdHJlYW0ge1xuICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApO1xuICB9XG59XG4iLCIvKipcbiAqIEEgc2lnbmFsIG9iamVjdCB0aGF0IGFsbG93cyB5b3UgdG8gY29tbXVuaWNhdGUgd2l0aCBhIHJlcXVlc3QgYW5kIGFib3J0IGl0IGlmIHJlcXVpcmVkXG4gKiB2aWEgaXRzIGFzc29jaWF0ZWQgYEFib3J0Q29udHJvbGxlcmAgb2JqZWN0LlxuICpcbiAqIEByZW1hcmtzXG4gKiAgIFRoaXMgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgYEFib3J0U2lnbmFsYCBpbnRlcmZhY2UgZGVmaW5lZCBpbiBUeXBlU2NyaXB0J3MgRE9NIHR5cGVzLlxuICogICBJdCBpcyByZWRlZmluZWQgaGVyZSwgc28gaXQgY2FuIGJlIHBvbHlmaWxsZWQgd2l0aG91dCBhIERPTSwgZm9yIGV4YW1wbGUgd2l0aFxuICogICB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsIHwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsfSBpbiBhIE5vZGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFib3J0U2lnbmFsIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYWJvcnRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGFib3J0ZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIHNpZ25hbCBiZWNvbWVzIGFib3J0ZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGU6ICdhYm9ydCcsIGxpc3RlbmVyOiAoKSA9PiB2b2lkKTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgYWRkZWQgd2l0aCB7QGxpbmsgQWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcn0uXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGU6ICdhYm9ydCcsIGxpc3RlbmVyOiAoKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnRTaWduYWwodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBYm9ydFNpZ25hbCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiAodmFsdWUgYXMgQWJvcnRTaWduYWwpLmFib3J0ZWQgPT09ICdib29sZWFuJztcbiAgfSBjYXRjaCB7XG4gICAgLy8gQWJvcnRTaWduYWwucHJvdG90eXBlLmFib3J0ZWQgdGhyb3dzIGlmIGl0cyBicmFuZCBjaGVjayBmYWlsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29udHJvbGxlciBvYmplY3QgdGhhdCBhbGxvd3MgeW91IHRvIGFib3J0IGFuIGBBYm9ydFNpZ25hbGAgd2hlbiBkZXNpcmVkLlxuICpcbiAqIEByZW1hcmtzXG4gKiAgIFRoaXMgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgYEFib3J0Q29udHJvbGxlcmAgaW50ZXJmYWNlIGRlZmluZWQgaW4gVHlwZVNjcmlwdCdzIERPTSB0eXBlcy5cbiAqICAgSXQgaXMgcmVkZWZpbmVkIGhlcmUsIHNvIGl0IGNhbiBiZSBwb2x5ZmlsbGVkIHdpdGhvdXQgYSBET00sIGZvciBleGFtcGxlIHdpdGhcbiAqICAge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbCB8IGFib3J0Y29udHJvbGxlci1wb2x5ZmlsbH0gaW4gYSBOb2RlIGVudmlyb25tZW50LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFib3J0Q29udHJvbGxlciB7XG4gIHJlYWRvbmx5IHNpZ25hbDogQWJvcnRTaWduYWw7XG5cbiAgYWJvcnQoKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIEFib3J0Q29udHJvbGxlckNvbnN0cnVjdG9yIHtcbiAgbmV3KCk6IEFib3J0Q29udHJvbGxlcjtcbn1cblxuY29uc3Qgc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgKEFib3J0Q29udHJvbGxlciBhcyBhbnkpID09PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBBYm9ydENvbnRyb2xsZXIsIGlmIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKTogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ldyAoQWJvcnRDb250cm9sbGVyIGFzIEFib3J0Q29udHJvbGxlckNvbnN0cnVjdG9yKSgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7XG4gIG5ld1Byb21pc2UsXG4gIHByb21pc2VSZWplY3RlZFdpdGgsXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUsXG4gIHVwb25Qcm9taXNlXG59IGZyb20gJy4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgRGVxdWV1ZVZhbHVlLFxuICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZSxcbiAgUGVla1F1ZXVlVmFsdWUsXG4gIFF1ZXVlUGFpcixcbiAgUmVzZXRRdWV1ZVxufSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgQWJvcnRTdGVwcywgRXJyb3JTdGVwcyB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgSXNOb25OZWdhdGl2ZU51bWJlciB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgRXh0cmFjdEhpZ2hXYXRlck1hcmssIEV4dHJhY3RTaXplQWxnb3JpdGhtIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHtcbiAgVW5kZXJseWluZ1NpbmssXG4gIFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayxcbiAgVmFsaWRhdGVkVW5kZXJseWluZ1Npbmtcbn0gZnJvbSAnLi93cml0YWJsZS1zdHJlYW0vdW5kZXJseWluZy1zaW5rJztcbmltcG9ydCB7IGFzc2VydE9iamVjdCwgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0VW5kZXJseWluZ1NpbmsgfSBmcm9tICcuL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zaW5rJztcbmltcG9ydCB7IGFzc2VydFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi92YWxpZGF0b3JzL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsLCBjcmVhdGVBYm9ydENvbnRyb2xsZXIgfSBmcm9tICcuL2Fib3J0LXNpZ25hbCc7XG5cbnR5cGUgV3JpdGFibGVTdHJlYW1TdGF0ZSA9ICd3cml0YWJsZScgfCAnY2xvc2VkJyB8ICdlcnJvcmluZycgfCAnZXJyb3JlZCc7XG5cbmludGVyZmFjZSBXcml0ZU9yQ2xvc2VSZXF1ZXN0IHtcbiAgX3Jlc29sdmU6ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgX3JlamVjdDogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xufVxuXG50eXBlIFdyaXRlUmVxdWVzdCA9IFdyaXRlT3JDbG9zZVJlcXVlc3Q7XG50eXBlIENsb3NlUmVxdWVzdCA9IFdyaXRlT3JDbG9zZVJlcXVlc3Q7XG5cbmludGVyZmFjZSBQZW5kaW5nQWJvcnRSZXF1ZXN0IHtcbiAgX3Byb21pc2U6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgX3Jlc29sdmU6ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgX3JlamVjdDogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICBfcmVhc29uOiBhbnk7XG4gIF93YXNBbHJlYWR5RXJyb3Jpbmc6IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSB3cml0YWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIGRlc3RpbmF0aW9uIGZvciBkYXRhLCBpbnRvIHdoaWNoIHlvdSBjYW4gd3JpdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBXcml0YWJsZVN0cmVhbTxXID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXRlITogV3JpdGFibGVTdHJlYW1TdGF0ZTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RvcmVkRXJyb3I6IGFueTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4gfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciE6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRlUmVxdWVzdHMhOiBTaW1wbGVRdWV1ZTxXcml0ZVJlcXVlc3Q+O1xuICAvKiogQGludGVybmFsICovXG4gIF9pbkZsaWdodFdyaXRlUmVxdWVzdDogV3JpdGVSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZVJlcXVlc3Q6IENsb3NlUmVxdWVzdCB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5GbGlnaHRDbG9zZVJlcXVlc3Q6IENsb3NlUmVxdWVzdCB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcGVuZGluZ0Fib3J0UmVxdWVzdDogUGVuZGluZ0Fib3J0UmVxdWVzdCB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlITogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih1bmRlcmx5aW5nU2luaz86IFVuZGVybHlpbmdTaW5rPFc+LCBzdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxXPik7XG4gIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTaW5rOiBVbmRlcmx5aW5nU2luazxXPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3U3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxXPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdVbmRlcmx5aW5nU2luayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByYXdVbmRlcmx5aW5nU2luayA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCB1bmRlcmx5aW5nU2luayA9IGNvbnZlcnRVbmRlcmx5aW5nU2luayhyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuXG4gICAgY29uc3QgdHlwZSA9IHVuZGVybHlpbmdTaW5rLnR5cGU7XG4gICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG5cbiAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsodGhpcywgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHdyaXRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB3cml0ZXIuXG4gICAqL1xuICBnZXQgbG9ja2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWJvcnRzIHRoZSBzdHJlYW0sIHNpZ25hbGluZyB0aGF0IHRoZSBwcm9kdWNlciBjYW4gbm8gbG9uZ2VyIHN1Y2Nlc3NmdWxseSB3cml0ZSB0byB0aGUgc3RyZWFtIGFuZCBpdCBpcyB0byBiZVxuICAgKiBpbW1lZGlhdGVseSBtb3ZlZCB0byBhbiBlcnJvcmVkIHN0YXRlLCB3aXRoIGFueSBxdWV1ZWQtdXAgd3JpdGVzIGRpc2NhcmRlZC4gVGhpcyB3aWxsIGFsc28gZXhlY3V0ZSBhbnkgYWJvcnRcbiAgICogbWVjaGFuaXNtIG9mIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCBpZiB0aGUgc3RyZWFtIHNodXRzIGRvd24gc3VjY2Vzc2Z1bGx5LCBvciByZWplY3QgaWYgdGhlIHVuZGVybHlpbmcgc2luayBzaWduYWxlZFxuICAgKiB0aGF0IHRoZXJlIHdhcyBhbiBlcnJvciBkb2luZyBzby4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWxcbiAgICogdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgKi9cbiAgYWJvcnQocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgIH1cblxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc3RyZWFtLiBUaGUgdW5kZXJseWluZyBzaW5rIHdpbGwgZmluaXNoIHByb2Nlc3NpbmcgYW55IHByZXZpb3VzbHktd3JpdHRlbiBjaHVua3MsIGJlZm9yZSBpbnZva2luZyBpdHNcbiAgICogY2xvc2UgYmVoYXZpb3IuIER1cmluZyB0aGlzIHRpbWUgYW55IGZ1cnRoZXIgYXR0ZW1wdHMgdG8gd3JpdGUgd2lsbCBmYWlsICh3aXRob3V0IGVycm9yaW5nIHRoZSBzdHJlYW0pLlxuICAgKlxuICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIGlmIGFsbCByZW1haW5pbmcgY2h1bmtzIGFyZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiBhbmQgdGhlIHN0cmVhbVxuICAgKiBzdWNjZXNzZnVsbHkgY2xvc2VzLCBvciByZWplY3RzIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGR1cmluZyB0aGlzIHByb2Nlc3MuIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aFxuICAgKiBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgIH1cblxuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgfCB3cml0ZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgd3JpdGVyLiBXaGlsZSB0aGUgc3RyZWFtXG4gICAqIGlzIGxvY2tlZCwgbm8gb3RoZXIgd3JpdGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgdG8gYSBzdHJlYW1cbiAgICogd2l0aG91dCBpbnRlcnJ1cHRpb24gb3IgaW50ZXJsZWF2aW5nLiBCeSBnZXR0aW5nIGEgd3JpdGVyIGZvciB0aGUgc3RyZWFtLCB5b3UgY2FuIGVuc3VyZSBub2JvZHkgZWxzZSBjYW4gd3JpdGUgYXRcbiAgICogdGhlIHNhbWUgdGltZSwgd2hpY2ggd291bGQgY2F1c2UgdGhlIHJlc3VsdGluZyB3cml0dGVuIGRhdGEgdG8gYmUgdW5wcmVkaWN0YWJsZSBhbmQgcHJvYmFibHkgdXNlbGVzcy5cbiAgICovXG4gIGdldFdyaXRlcigpOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignZ2V0V3JpdGVyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBnZXRXcml0ZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsXG4gIENyZWF0ZVdyaXRhYmxlU3RyZWFtLFxuICBJc1dyaXRhYmxlU3RyZWFtLFxuICBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkLFxuICBXcml0YWJsZVN0cmVhbSxcbiAgV3JpdGFibGVTdHJlYW1BYm9ydCxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24sXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlLFxuICBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCxcbiAgVW5kZXJseWluZ1NpbmssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFja1xufTtcblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4pOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4ge1xuICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xufVxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW08Vz4oc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPiA9ICgpID0+IDEpIHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIoaGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJbml0aWFsaXplV3JpdGFibGVTdHJlYW08Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPikge1xuICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcblxuICAvLyBUaGUgZXJyb3IgdGhhdCB3aWxsIGJlIHJlcG9ydGVkIGJ5IG5ldyBtZXRob2QgY2FsbHMgb25jZSB0aGUgc3RhdGUgYmVjb21lcyBlcnJvcmVkLiBPbmx5IHNldCB3aGVuIFtbc3RhdGVdXSBpc1xuICAvLyAnZXJyb3JpbmcnIG9yICdlcnJvcmVkJy4gTWF5IGJlIHNldCB0byBhbiB1bmRlZmluZWQgdmFsdWUuXG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcbiAgLy8gdmFyaWFibGUgdG8gdmFsaWRhdGUgdGhlIGNhbGxlci5cbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQhO1xuXG4gIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcbiAgLy8gcHJvZHVjZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgcXVldWVkIHdyaXRlcyB0byBmaW5pc2guXG4gIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXG4gIC8vIFdyaXRlIHJlcXVlc3RzIGFyZSByZW1vdmVkIGZyb20gX3dyaXRlUmVxdWVzdHMgd2hlbiB3cml0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzXG4gIC8vIHRoZW0gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSB3cml0ZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5jbG9zZSgpLiBTdG9yZWQgaGVyZSBiZWNhdXNlIGl0IG1heSBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlclxuICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcbiAgLy8gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSBjbG9zZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5hYm9ydCgpLiBUaGlzIG1heSBhbHNvIGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyIGhhcyBkZXRhY2hlZC5cbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBiYWNrcHJlc3N1cmUgc2lnbmFsIHNldCBieSB0aGUgY29udHJvbGxlci5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4OiB1bmtub3duKTogeCBpcyBXcml0YWJsZVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ193cml0YWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW07XG59XG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbShzdHJlYW0pKTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gcmVhc29uO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuXG4gIC8vIFR5cGVTY3JpcHQgbmFycm93cyB0aGUgdHlwZSBvZiBgc3RyZWFtLl9zdGF0ZWAgZG93biB0byAnd3JpdGFibGUnIHwgJ2Vycm9yaW5nJyxcbiAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cbiAgLy8gV2lkZW4gdGhlIHR5cGUgYWdhaW4gYnkgY2FzdGluZyB0byBXcml0YWJsZVN0cmVhbVN0YXRlLlxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGUgYXMgV3JpdGFibGVTdHJlYW1TdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIGxldCB3YXNBbHJlYWR5RXJyb3JpbmcgPSBmYWxzZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcbiAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cbiAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgICBfcHJvbWlzZTogdW5kZWZpbmVkISxcbiAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgX3JlamVjdDogcmVqZWN0LFxuICAgICAgX3JlYXNvbjogcmVhc29uLFxuICAgICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG4gICAgfTtcbiAgfSk7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCEuX3Byb21pc2UgPSBwcm9taXNlO1xuXG4gIGlmICghd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbTogV3JpdGFibGVTdHJlYW08YW55Pik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihcbiAgICAgIGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gIGFzc2VydCghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2xvc2VSZXF1ZXN0OiBDbG9zZVJlcXVlc3QgPSB7XG4gICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgIH07XG5cbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IGNsb3NlUmVxdWVzdDtcbiAgfSk7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gIH1cblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBXcml0YWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVxdWVzdDogV3JpdGVSZXF1ZXN0ID0ge1xuICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICBfcmVqZWN0OiByZWplY3RcbiAgICB9O1xuXG4gICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLnB1c2god3JpdGVSZXF1ZXN0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX3N0b3JlZEVycm9yID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuICBhc3NlcnQoY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yaW5nJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgfVxuXG4gIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgYXNzZXJ0KCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkpO1xuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltFcnJvclN0ZXBzXSgpO1xuXG4gIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcbiAgICB3cml0ZVJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gIH0pO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWJvcnRSZXF1ZXN0ID0gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O1xuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbQWJvcnRTdGVwc10oYWJvcnRSZXF1ZXN0Ll9yZWFzb24pO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGFib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgIH0sXG4gICAgKHJlYXNvbjogYW55KSA9PiB7XG4gICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChyZWFzb24pO1xuICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCEuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIGVycm9yOiBhbnkpIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QhLl9yZWplY3QoZXJyb3IpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IS5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIC8vIFRoZSBlcnJvciB3YXMgdG9vIGxhdGUgdG8gZG8gYW55dGhpbmcsIHNvIGl0IGlzIGlnbm9yZWQuXG4gICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcblxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gIH1cblxuICBhc3NlcnQoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl9zdG9yZWRFcnJvciA9PT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIGVycm9yOiBhbnkpIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QhLl9yZWplY3QoZXJyb3IpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIC8vIE5ldmVyIGV4ZWN1dGUgc2luayBhYm9ydCgpIGFmdGVyIHNpbmsgY2xvc2UoKS5cbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xufVxuXG4vLyBUT0RPKHJpY2VhKTogRml4IGFscGhhYmV0aWNhbCBvcmRlci5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSBzdHJlYW0uX2Nsb3NlUmVxdWVzdDtcbiAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5sZW5ndGggIT09IDApO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gc3RyZWFtLl93cml0ZVJlcXVlc3RzLnNoaWZ0KCk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKTtcbiAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcblxuICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0Ll9yZWplY3Qoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgYmFja3ByZXNzdXJlOiBib29sZWFuKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcbiAgYXNzZXJ0KCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKTtcblxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBpZiAoYmFja3ByZXNzdXJlKSB7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFiYWNrcHJlc3N1cmUpO1xuXG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xufVxuXG4vKipcbiAqIEEgZGVmYXVsdCB3cml0ZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VyA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9vd25lcldyaXRhYmxlU3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZVN0YXRlITogJ3BlbmRpbmcnIHwgJ3Jlc29sdmVkJyB8ICdyZWplY3RlZCc7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWR5UHJvbWlzZSE6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWR5UHJvbWlzZV9yZWplY3Q/OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWR5UHJvbWlzZVN0YXRlITogJ3BlbmRpbmcnIHwgJ2Z1bGZpbGxlZCcgfCAncmVqZWN0ZWQnO1xuXG4gIGNvbnN0cnVjdG9yKHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4pIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicpO1xuICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgICBzdHJlYW0uX3dyaXRlciA9IHRoaXM7XG5cbiAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnZXJyb3JlZCcpO1xuXG4gICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG4gICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICovXG4gIGdldCBjbG9zZWQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG4gICAqIEEgcHJvZHVjZXIgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB0aGUgcmlnaHQgYW1vdW50IG9mIGRhdGEgdG8gd3JpdGUuXG4gICAqXG4gICAqIEl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZSBzdHJlYW0gY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIHRvIChkdWUgdG8gZWl0aGVyIGJlaW5nIGVycm9yZWQsIG9yIGhhdmluZyBhbiBhYm9ydFxuICAgKiBxdWV1ZWQgdXApLiBJdCB3aWxsIHJldHVybiB6ZXJvIGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkLiBBbmQgdGhlIGdldHRlciB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBpbnZva2VkIHdoZW5cbiAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZC5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZSB0cmFuc2l0aW9uc1xuICAgKiBmcm9tIG5vbi1wb3NpdGl2ZSB0byBwb3NpdGl2ZSwgc2lnbmFsaW5nIHRoYXQgaXQgaXMgbm8gbG9uZ2VyIGFwcGx5aW5nIGJhY2twcmVzc3VyZS4gT25jZSB0aGUgZGVzaXJlZCBzaXplIGRpcHNcbiAgICogYmFjayB0byB6ZXJvIG9yIGJlbG93LCB0aGUgZ2V0dGVyIHdpbGwgcmV0dXJuIGEgbmV3IHByb21pc2UgdGhhdCBzdGF5cyBwZW5kaW5nIHVudGlsIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAqXG4gICAqIElmIHRoZSBzdHJlYW0gYmVjb21lcyBlcnJvcmVkIG9yIGFib3J0ZWQsIG9yIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmVjb21lXG4gICAqIHJlamVjdGVkLlxuICAgKi9cbiAgZ2V0IHJlYWR5KCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWR5JykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkeVByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmFib3J0IHwgc3RyZWFtLmFib3J0KHJlYXNvbil9LlxuICAgKi9cbiAgYWJvcnQocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5jbG9zZSB8IHN0cmVhbS5jbG9zZSgpfS5cbiAgICovXG4gIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgd3JpdGVy4oCZcyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheSBmcm9tXG4gICAqIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBsb2NrIGNhbiBzdGlsbCBiZSByZWxlYXNlZCBldmVuIGlmIHNvbWUgb25nb2luZyB3cml0ZXMgaGF2ZSBub3QgeWV0IGZpbmlzaGVkIChpLmUuIGV2ZW4gaWYgdGhlXG4gICAqIHByb21pc2VzIHJldHVybmVkIGZyb20gcHJldmlvdXMgY2FsbHMgdG8ge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci53cml0ZSB8IHdyaXRlKCl9IGhhdmUgbm90IHlldCBzZXR0bGVkKS5cbiAgICogSXTigJlzIG5vdCBuZWNlc3NhcnkgdG8gaG9sZCB0aGUgbG9jayBvbiB0aGUgd3JpdGVyIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHdyaXRlOyB0aGUgbG9jayBpbnN0ZWFkIHNpbXBseSBwcmV2ZW50c1xuICAgKiBvdGhlciBwcm9kdWNlcnMgZnJvbSB3cml0aW5nIGluIGFuIGludGVybGVhdmVkIG1hbm5lci5cbiAgICovXG4gIHJlbGVhc2VMb2NrKCk6IHZvaWQge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhc3NlcnQoc3RyZWFtLl93cml0ZXIgIT09IHVuZGVmaW5lZCk7XG5cbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgZ2l2ZW4gY2h1bmsgdG8gdGhlIHdyaXRhYmxlIHN0cmVhbSwgYnkgd2FpdGluZyB1bnRpbCBhbnkgcHJldmlvdXMgd3JpdGVzIGhhdmUgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LFxuICAgKiBhbmQgdGhlbiBzZW5kaW5nIHRoZSBjaHVuayB0byB0aGUgdW5kZXJseWluZyBzaW5rJ3Mge0BsaW5rIFVuZGVybHlpbmdTaW5rLndyaXRlIHwgd3JpdGUoKX0gbWV0aG9kLiBJdCB3aWxsIHJldHVyblxuICAgKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHVuZGVmaW5lZCB1cG9uIGEgc3VjY2Vzc2Z1bCB3cml0ZSwgb3IgcmVqZWN0cyBpZiB0aGUgd3JpdGUgZmFpbHMgb3Igc3RyZWFtIGJlY29tZXNcbiAgICogZXJyb3JlZCBiZWZvcmUgdGhlIHdyaXRpbmcgcHJvY2VzcyBpcyBpbml0aWF0ZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3aGF0IFwic3VjY2Vzc1wiIG1lYW5zIGlzIHVwIHRvIHRoZSB1bmRlcmx5aW5nIHNpbms7IGl0IG1pZ2h0IGluZGljYXRlIHNpbXBseSB0aGF0IHRoZSBjaHVuayBoYXMgYmVlblxuICAgKiBhY2NlcHRlZCwgYW5kIG5vdCBuZWNlc3NhcmlseSB0aGF0IGl0IGlzIHNhZmVseSBzYXZlZCB0byBpdHMgdWx0aW1hdGUgZGVzdGluYXRpb24uXG4gICAqL1xuICB3cml0ZShjaHVuazogVyk6IFByb21pc2U8dm9pZD47XG4gIHdyaXRlKGNodW5rOiBXID0gdW5kZWZpbmVkISk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0ZScpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCB7XG4gIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHdyaXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWFkeTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXID0gYW55Pih4OiBhbnkpOiB4IGlzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbn1cblxuLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgZXJyb3I6IGFueSkge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCBlcnJvcjogYW55KSB7XG4gIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fd3JpdGVyID09PSB3cml0ZXIpO1xuXG4gIGNvbnN0IHJlbGVhc2VkRXJyb3IgPSBuZXcgVHlwZUVycm9yKFxuICAgIGBXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApO1xuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cbiAgLy8gVGhlIHN0YXRlIHRyYW5zaXRpb25zIHRvIFwiZXJyb3JlZFwiIGJlZm9yZSB0aGUgc2luayBhYm9ydCgpIG1ldGhvZCBydW5zLCBidXQgdGhlIHdyaXRlci5jbG9zZWQgcHJvbWlzZSBpcyBub3RcbiAgLy8gcmVqZWN0ZWQgdW50aWwgYWZ0ZXJ3YXJkcy4gVGhpcyBtZWFucyB0aGF0IHNpbXBseSB0ZXN0aW5nIHN0YXRlIHdpbGwgbm90IHdvcmsuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuXG4gIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0gPSB1bmRlZmluZWQhO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZTxXPih3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiwgY2h1bms6IFcpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgY29uc3QgY2h1bmtTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuayk7XG5cbiAgaWYgKHN0cmVhbSAhPT0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgY2xvc2luZyBvciBjbG9zZWQgYW5kIGNhbm5vdCBiZSB3cml0dGVuIHRvJykpO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBjb25zdCBwcm9taXNlID0gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKTtcblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmNvbnN0IGNsb3NlU2VudGluZWw6IHVuaXF1ZSBzeW1ib2wgPSB7fSBhcyBhbnk7XG5cbnR5cGUgUXVldWVSZWNvcmQ8Vz4gPSBXIHwgdHlwZW9mIGNsb3NlU2VudGluZWw7XG5cbi8qKlxuICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VyA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0hOiBXcml0YWJsZVN0cmVhbTxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWUhOiBTaW1wbGVRdWV1ZTxRdWV1ZVBhaXI8UXVldWVSZWNvcmQ8Vz4+PjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWVUb3RhbFNpemUhOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fib3J0UmVhc29uOiBhbnk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGFydGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lTaXplQWxnb3JpdGhtITogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGVBbGdvcml0aG0hOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlQWxnb3JpdGhtITogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWJvcnRBbGdvcml0aG0hOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlYXNvbiB3aGljaCB3YXMgcGFzc2VkIHRvIGBXcml0YWJsZVN0cmVhbS5hYm9ydChyZWFzb24pYCB3aGVuIHRoZSBzdHJlYW0gd2FzIGFib3J0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqICBUaGlzIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgc3BlY2lmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9wdWxsLzExNzcuXG4gICAqICBVc2Uge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuc2lnbmFsfSdzIGByZWFzb25gIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYWJvcnRSZWFzb24oKTogYW55IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydFJlYXNvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWJvcnRSZWFzb247XG4gIH1cblxuICAvKipcbiAgICogQW4gYEFib3J0U2lnbmFsYCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFib3J0IHRoZSBwZW5kaW5nIHdyaXRlIG9yIGNsb3NlIG9wZXJhdGlvbiB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvcnRlZC5cbiAgICovXG4gIGdldCBzaWduYWwoKTogQWJvcnRTaWduYWwge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpZ25hbCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJ1bmRsZSBhbmQgc2hpcCBhbiBgQWJvcnRDb250cm9sbGVyYCBwb2x5ZmlsbCB0b2dldGhlciB3aXRoIG91ciBwb2x5ZmlsbCxcbiAgICAgIC8vIHNvIGluc3RlYWQgd2Ugb25seSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYHNpZ25hbGAgaWYgd2UgZmluZCBhIGdsb2JhbCBgQWJvcnRDb250cm9sbGVyYCBjb25zdHJ1Y3Rvci5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCB3cml0YWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByYXJlbHkgdXNlZCwgc2luY2UgdXN1YWxseSBpdCBzdWZmaWNlcyB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZyb20gb25lIG9mIHRoZSB1bmRlcmx5aW5nXG4gICAqIHNpbmsncyBtZXRob2RzLiBIb3dldmVyLCBpdCBjYW4gYmUgdXNlZnVsIGZvciBzdWRkZW5seSBzaHV0dGluZyBkb3duIGEgc3RyZWFtIGluIHJlc3BvbnNlIHRvIGFuIGV2ZW50IG91dHNpZGUgdGhlXG4gICAqIG5vcm1hbCBsaWZlY3ljbGUgb2YgaW50ZXJhY3Rpb25zIHdpdGggdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICovXG4gIGVycm9yKGU6IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcbiAgICAgIC8vIFRoZSBzdHJlYW0gaXMgY2xvc2VkLCBlcnJvcmVkIG9yIHdpbGwgYmUgc29vbi4gVGhlIHNpbmsgY2FuJ3QgZG8gYW55dGhpbmcgdXNlZnVsIGlmIGl0IGdldHMgYW4gZXJyb3IgaGVyZSwgc29cbiAgICAgIC8vIGp1c3QgdHJlYXQgaXQgYXMgYSBuby1vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtBYm9ydFN0ZXBzXShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbRXJyb3JTdGVwc10oKSB7XG4gICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICBhYm9ydFJlYXNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBpbXBsZW1lbnRpbmcgaW50ZXJmYWNlIHJlcXVpcmVkIGJ5IHRoZSBXcml0YWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHg6IGFueSk6IHggaXMgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVBbGdvcml0aG06IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Vz4pIHtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAvLyBOZWVkIHRvIHNldCB0aGUgc2xvdHMgc28gdGhhdCB0aGUgYXNzZXJ0IGRvZXNuJ3QgZmlyZS4gSW4gdGhlIHNwZWMgdGhlIHNsb3RzIGFscmVhZHkgZXhpc3QgaW1wbGljaXRseS5cbiAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZCE7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cbiAgY29udHJvbGxlci5fYWJvcnRSZWFzb24gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gY2xvc2VBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gYWJvcnRBbGdvcml0aG07XG5cbiAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgY29uc3Qgc3RhcnRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHN0YXJ0UHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIHIpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJseWluZ1Npbms6IFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Vz4pIHtcbiAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+ID0gKCkgPT4gdW5kZWZpbmVkO1xuICBsZXQgd3JpdGVBbGdvcml0aG06IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGNsb3NlQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgYWJvcnRBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblxuICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1Npbmsuc3RhcnQhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay53cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd3JpdGVBbGdvcml0aG0gPSBjaHVuayA9PiB1bmRlcmx5aW5nU2luay53cml0ZSEoY2h1bmssIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay5jbG9zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5jbG9zZSEoKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1NpbmsuYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFib3J0QWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTaW5rLmFib3J0IShyZWFzb24pO1xuICB9XG5cbiAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKFxuICAgIHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG1cbiAgKTtcbn1cblxuLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KSB7XG4gIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNsb3NlU2VudGluZWwsIDApO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemU8Vz4oY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IFcpOiBudW1iZXIge1xuICB0cnkge1xuICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0oY2h1bmspO1xuICB9IGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IG51bWJlciB7XG4gIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGU8Vz4oY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NpemU6IG51bWJlcikge1xuICB0cnkge1xuICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gIH1cblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQ8Vz4oY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPikge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgYXNzZXJ0KHN0YXRlICE9PSAnY2xvc2VkJyAmJiBzdGF0ZSAhPT0gJ2Vycm9yZWQnKTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IFBlZWtRdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICBpZiAodmFsdWUgPT09IGNsb3NlU2VudGluZWwpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXIpO1xuICB9IGVsc2Uge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiwgZXJyb3I6IGFueSkge1xuICBpZiAoY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXG4gIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSk7XG5cbiAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICBhc3NlcnQoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKTtcblxuICBjb25zdCBzaW5rQ2xvc2VQcm9taXNlID0gY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0oKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgdXBvblByb21pc2UoXG4gICAgc2lua0Nsb3NlUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcbiAgICB9LFxuICAgIHJlYXNvbiA9PiB7XG4gICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LCBjaHVuazogVykge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuXG4gIGNvbnN0IHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHNpbmtXcml0ZVByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblxuICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgIH1cblxuICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgcmVhc29uID0+IHtcbiAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pOiBib29sZWFuIHtcbiAgY29uc3QgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xufVxuXG4vLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiwgZXJyb3I6IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xufVxuXG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHdyaXRlcicpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpO1xuXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlICE9PSAncGVuZGluZycpO1xuXG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpO1xuXG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9yZWFkeVByb21pc2UpO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3JlamVjdGVkJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuXG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuXG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdmdWxmaWxsZWQnO1xufVxuIiwiLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbmV4cG9ydCBjb25zdCBOYXRpdmVET01FeGNlcHRpb246IHR5cGVvZiBET01FeGNlcHRpb24gfCB1bmRlZmluZWQgPVxuICB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyA/IERPTUV4Y2VwdGlvbiA6IHVuZGVmaW5lZDtcbiIsIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwibm9kZVwiIC8+XG5pbXBvcnQgeyBOYXRpdmVET01FeGNlcHRpb24gfSBmcm9tICcuL25hdGl2ZSc7XG5cbmRlY2xhcmUgY2xhc3MgRE9NRXhjZXB0aW9uQ2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpO1xuXG4gIG5hbWU6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG50eXBlIERPTUV4Y2VwdGlvbiA9IERPTUV4Y2VwdGlvbkNsYXNzO1xudHlwZSBET01FeGNlcHRpb25Db25zdHJ1Y3RvciA9IHR5cGVvZiBET01FeGNlcHRpb25DbGFzcztcblxuZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yOiB1bmtub3duKTogY3RvciBpcyBET01FeGNlcHRpb25Db25zdHJ1Y3RvciB7XG4gIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgKGN0b3IgYXMgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IpKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpOiBET01FeGNlcHRpb25Db25zdHJ1Y3RvciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbih0aGlzOiBET01FeGNlcHRpb24sIG1lc3NhZ2U/OiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfSBhcyBhbnk7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIHJldHVybiBjdG9yO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBET01FeGNlcHRpb246IERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yID1cbiAgaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihOYXRpdmVET01FeGNlcHRpb24pID8gTmF0aXZlRE9NRXhjZXB0aW9uIDogY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKTtcblxuZXhwb3J0IHsgRE9NRXhjZXB0aW9uIH07XG4iLCJpbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtLCBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1DYW5jZWwgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciwgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCB9IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSB9IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgSXNXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbUxvY2tlZCxcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtQWJvcnQsXG4gIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0LFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZVxufSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBuZXdQcm9taXNlLFxuICBQZXJmb3JtUHJvbWlzZVRoZW4sXG4gIHByb21pc2VSZXNvbHZlZFdpdGgsXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUsXG4gIHVwb25GdWxmaWxsbWVudCxcbiAgdXBvblByb21pc2UsXG4gIHVwb25SZWplY3Rpb25cbn0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEFib3J0U2lnbmFsLCBpc0Fib3J0U2lnbmFsIH0gZnJvbSAnLi4vYWJvcnQtc2lnbmFsJztcbmltcG9ydCB7IERPTUV4Y2VwdGlvbiB9IGZyb20gJy4uLy4uL3N0dWIvZG9tLWV4Y2VwdGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVBpcGVUbzxUPihzb3VyY2U6IFJlYWRhYmxlU3RyZWFtPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Q6IFdyaXRhYmxlU3RyZWFtPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRDbG9zZTogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50QWJvcnQ6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENhbmNlbDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc291cmNlKSk7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtKGRlc3QpKTtcbiAgYXNzZXJ0KHR5cGVvZiBwcmV2ZW50Q2xvc2UgPT09ICdib29sZWFuJyk7XG4gIGFzc2VydCh0eXBlb2YgcHJldmVudEFib3J0ID09PSAnYm9vbGVhbicpO1xuICBhc3NlcnQodHlwZW9mIHByZXZlbnRDYW5jZWwgPT09ICdib29sZWFuJyk7XG4gIGFzc2VydChzaWduYWwgPT09IHVuZGVmaW5lZCB8fCBpc0Fib3J0U2lnbmFsKHNpZ25hbCkpO1xuICBhc3NlcnQoIUlzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc291cmNlKSk7XG4gIGFzc2VydCghSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0KSk7XG5cbiAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxUPihzb3VyY2UpO1xuICBjb25zdCB3cml0ZXIgPSBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFQ+KGRlc3QpO1xuXG4gIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBsZXQgc2h1dHRpbmdEb3duID0gZmFsc2U7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHNwZWMncyByZXF1aXJlbWVudCB0aGF0IHdlIHdhaXQgZm9yIG9uZ29pbmcgd3JpdGVzIGR1cmluZyBzaHV0ZG93bi5cbiAgbGV0IGN1cnJlbnRXcml0ZSA9IHByb21pc2VSZXNvbHZlZFdpdGg8dm9pZD4odW5kZWZpbmVkKTtcblxuICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGFib3J0QWxnb3JpdGhtOiAoKSA9PiB2b2lkO1xuICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnM6IEFycmF5PCgpID0+IFByb21pc2U8dm9pZD4+ID0gW107XG4gICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBQcm9taXNlLmFsbChhY3Rpb25zLm1hcChhY3Rpb24gPT4gYWN0aW9uKCkpKSwgdHJ1ZSwgZXJyb3IpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0QWxnb3JpdGhtKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIHJlYWRlciBhbmQgd3JpdGVyLCByZWFkIGFsbCBjaHVua3MgZnJvbSB0aGlzIGFuZCB3cml0ZSB0aGVtIHRvIGRlc3RcbiAgICAvLyAtIEJhY2twcmVzc3VyZSBtdXN0IGJlIGVuZm9yY2VkXG4gICAgLy8gLSBTaHV0ZG93biBtdXN0IHN0b3AgYWxsIGFjdGl2aXR5XG4gICAgZnVuY3Rpb24gcGlwZUxvb3AoKSB7XG4gICAgICByZXR1cm4gbmV3UHJvbWlzZTx2b2lkPigocmVzb2x2ZUxvb3AsIHJlamVjdExvb3ApID0+IHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChkb25lOiBib29sZWFuKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmVMb29wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBgUGVyZm9ybVByb21pc2VUaGVuYCBpbnN0ZWFkIG9mIGB1cG9uUHJvbWlzZWAgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXG4gICAgICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaXBlU3RlcCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4od3JpdGVyLl9yZWFkeVByb21pc2UsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U8Ym9vbGVhbj4oKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG4gICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V3JpdGUgPSBQZXJmb3JtUHJvbWlzZVRoZW4oV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUod3JpdGVyLCBjaHVuayksIHVuZGVmaW5lZCwgbm9vcCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlYWQoZmFsc2UpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXG4gICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcbiAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgIGlzT3JCZWNvbWVzRXJyb3JlZChkZXN0LCB3cml0ZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcbiAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICBpc09yQmVjb21lc0Nsb3NlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50Q2xvc2UpIHtcbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcbiAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICBjb25zdCBkZXN0Q2xvc2VkID0gbmV3IFR5cGVFcnJvcigndGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0Jyk7XG5cbiAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBkZXN0Q2xvc2VkKSwgdHJ1ZSwgZGVzdENsb3NlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xuXG4gICAgZnVuY3Rpb24gd2FpdEZvcldyaXRlc1RvRmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcbiAgICAgIC8vIGZvciB0aGF0IHRvby5cbiAgICAgIGNvbnN0IG9sZEN1cnJlbnRXcml0ZSA9IGN1cnJlbnRXcml0ZTtcbiAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oXG4gICAgICAgIGN1cnJlbnRXcml0ZSxcbiAgICAgICAgKCkgPT4gb2xkQ3VycmVudFdyaXRlICE9PSBjdXJyZW50V3JpdGUgPyB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Vycm9yZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSB8IFdyaXRhYmxlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChyZWFzb246IGFueSkgPT4gdm9pZCkge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICBhY3Rpb24oc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cG9uUmVqZWN0aW9uKHByb21pc2UsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSB8IFdyaXRhYmxlU3RyZWFtLCBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LCBhY3Rpb246ICgpID0+IHZvaWQpIHtcbiAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICBhY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNodXRkb3duV2l0aEFjdGlvbihhY3Rpb246ICgpID0+IFByb21pc2U8dW5rbm93bj4sIG9yaWdpbmFsSXNFcnJvcj86IGJvb2xlYW4sIG9yaWdpbmFsRXJyb3I/OiBhbnkpIHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1RoZVJlc3QoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9UaGVSZXN0KCkge1xuICAgICAgICB1cG9uUHJvbWlzZShcbiAgICAgICAgICBhY3Rpb24oKSxcbiAgICAgICAgICAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLFxuICAgICAgICAgIG5ld0Vycm9yID0+IGZpbmFsaXplKHRydWUsIG5ld0Vycm9yKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNodXRkb3duKGlzRXJyb3I/OiBib29sZWFuLCBlcnJvcj86IGFueSkge1xuICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXG4gICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgKCkgPT4gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZShpc0Vycm9yPzogYm9vbGVhbiwgZXJyb3I/OiBhbnkpIHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblxuICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBEZXF1ZXVlVmFsdWUsIEVucXVldWVWYWx1ZVdpdGhTaXplLCBRdWV1ZVBhaXIsIFJlc2V0UXVldWUgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvcXVldWUtd2l0aC1zaXplcyc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMsXG4gIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtQ2xvc2UsIFJlYWRhYmxlU3RyZWFtRXJyb3IgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgVmFsaWRhdGVkVW5kZXJseWluZ1NvdXJjZSB9IGZyb20gJy4vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IENhbmNlbFN0ZXBzLCBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBwcm9taXNlUmVzb2x2ZWRXaXRoLCB1cG9uUHJvbWlzZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPFF1ZXVlUGFpcjxSPj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGFydGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VSZXF1ZXN0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsQWdhaW4hOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsaW5nICE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSE6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jYW5jZWxBbGdvcml0aG0hOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgYGNodW5rYCBpbiB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBSKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogUiA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtDYW5jZWxTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8UiA9IGFueT4oeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pOiB2b2lkIHtcbiAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgaWYgKCFzaG91bGRQdWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcbiAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcblxuICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHVsbFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGUgPT4ge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IGJvb2xlYW4ge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgYXNzZXJ0KGRlc2lyZWRTaXplICE9PSBudWxsKTtcbiAgaWYgKGRlc2lyZWRTaXplISA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZTxSPihcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPixcbiAgY2h1bms6IFJcbik6IHZvaWQge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGxldCBjaHVua1NpemU7XG4gICAgdHJ5IHtcbiAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgICAgdGhyb3cgY2h1bmtTaXplRTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICAgfSBjYXRjaCAoZW5xdWV1ZUUpIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgICB0aHJvdyBlbnF1ZXVlRTtcbiAgICB9XG4gIH1cblxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGU6IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PlxuKTogYm9vbGVhbiB7XG4gIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBib29sZWFuIHtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpO1xuXG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblxuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cbiAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbGluZyk7XG4gICAgICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2U8Uj4oXG4gIHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gIHVuZGVybHlpbmdTb3VyY2U6IFZhbGlkYXRlZFVuZGVybHlpbmdTb3VyY2U8Uj4sXG4gIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+XG4pIHtcbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+ID0gKCkgPT4gdW5kZWZpbmVkO1xuICBsZXQgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIShyZWFzb24pO1xuICB9XG5cbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKFxuICAgIHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG4iLCJpbXBvcnQge1xuICBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIENyZWF0ZVJlYWRhYmxlU3RyZWFtLFxuICBJc1JlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbUNhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UgfSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkLFxuICBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkLFxuICBSZWFkSW50b1JlcXVlc3Rcbn0gZnJvbSAnLi9ieW9iLXJlYWRlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZXNvbHZlZFdpdGgsIHF1ZXVlTWljcm90YXNrLCB1cG9uUmVqZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yXG59IGZyb20gJy4vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3XG59IGZyb20gJy4vYnl0ZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBDcmVhdGVBcnJheUZyb21MaXN0IH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2xvbmVBc1VpbnQ4QXJyYXkgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lRm9yQnJhbmNoMjogYm9vbGVhbik6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydCh0eXBlb2YgY2xvbmVGb3JCcmFuY2gyID09PSAnYm9vbGVhbicpO1xuICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtKSBhc1xuICAgICAgdW5rbm93biBhcyBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XTtcbiAgfVxuICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUZvckJyYW5jaDI6IGJvb2xlYW4pOiBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQodHlwZW9mIGNsb25lRm9yQnJhbmNoMiA9PT0gJ2Jvb2xlYW4nKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbSk7XG5cbiAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgbGV0IHJlYXNvbjE6IGFueTtcbiAgbGV0IHJlYXNvbjI6IGFueTtcbiAgbGV0IGJyYW5jaDE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICBsZXQgYnJhbmNoMjogUmVhZGFibGVTdHJlYW08Uj47XG5cbiAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlOiAodmFsdWU6IHVuZGVmaW5lZCB8IFByb21pc2U8dW5kZWZpbmVkPikgPT4gdm9pZDtcbiAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPihyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbiA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlYWRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBjaHVuazIgPSBjaHVuaztcblxuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAvLyBJZiB3ZSBhZGQgb25lIHRoZW4gd2UnbGwgbmVlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3Igc2VyaWFsaXphYmxlIG9iamVjdHMuXG4gICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoXG4gICAgICAgICAgICAgIGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICAgICAgICAgICAgICBjaHVuazFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShcbiAgICAgICAgICAgICAgYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gICAgICAgICAgICAgIGNodW5rMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2Fpbikge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblxuICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHI6IGFueSkgPT4ge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiwgcik7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LCByKTtcbiAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbVRlZShzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IFtSZWFkYWJsZUJ5dGVTdHJlYW0sIFJlYWRhYmxlQnl0ZVN0cmVhbV0ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpO1xuXG4gIGxldCByZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFVpbnQ4QXJyYXk+ID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgbGV0IHJlYXNvbjE6IGFueTtcbiAgbGV0IHJlYXNvbjI6IGFueTtcbiAgbGV0IGJyYW5jaDE6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgbGV0IGJyYW5jaDI6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U6ICh2YWx1ZTogdW5kZWZpbmVkIHwgUHJvbWlzZTx1bmRlZmluZWQ+KSA9PiB2b2lkO1xuICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxVaW50OEFycmF5Pikge1xuICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG4gICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKSB7XG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgIGFzc2VydChyZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID09PSAwKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblxuICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFVpbnQ4QXJyYXk+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGxXaXRoQllPQlJlYWRlcih2aWV3OiBBcnJheUJ1ZmZlclZpZXcsIGZvckJyYW5jaDI6IGJvb2xlYW4pIHtcbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4ocmVhZGVyKSkge1xuICAgICAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ5b2JCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMiA6IGJyYW5jaDE7XG4gICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG5cbiAgICBjb25zdCByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxBcnJheUJ1ZmZlclZpZXc+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblxuICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cbiAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydChjaHVuay5ieXRlTGVuZ3RoID09PSAwKTtcblxuICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCB8fCAhb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldyEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3ISwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG5cbiAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cbiAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbn1cbiIsImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uLCBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyBwcm9taXNlQ2FsbCwgcmVmbGVjdENhbGwgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4oXG4gIHNvdXJjZTogVW5kZXJseWluZ1NvdXJjZTxSPiB8IFVuZGVybHlpbmdCeXRlU291cmNlIHwgbnVsbCxcbiAgY29udGV4dDogc3RyaW5nXG4pOiBWYWxpZGF0ZWRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPiB7XG4gIGFzc2VydERpY3Rpb25hcnkoc291cmNlLCBjb250ZXh0KTtcbiAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2UgYXMgKFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+IHwgbnVsbCk7XG4gIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IG9yaWdpbmFsPy5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gIGNvbnN0IGNhbmNlbCA9IG9yaWdpbmFsPy5jYW5jZWw7XG4gIGNvbnN0IHB1bGwgPSBvcmlnaW5hbD8ucHVsbDtcbiAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbD8uc3RhcnQ7XG4gIGNvbnN0IHR5cGUgPSBvcmlnaW5hbD8udHlwZTtcbiAgcmV0dXJuIHtcbiAgICBhdXRvQWxsb2NhdGVDaHVua1NpemU6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoXG4gICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YFxuICAgICAgKSxcbiAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKGNhbmNlbCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjYW5jZWwnIHRoYXRgKSxcbiAgICBwdWxsOiBwdWxsID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKHB1bGwsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLFxuICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICB0eXBlOiB0eXBlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3R5cGUnIHRoYXRgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UsXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKHJlYXNvbjogYW55KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2s8Uj4oXG4gIGZuOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVB1bGxDYWxsYmFjazxSPixcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8Uj4pID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFI+KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjazxSPihcbiAgZm46IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlU3RhcnRDYWxsYmFjazxSPixcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlU3RhcnRDYWxsYmFjazxSPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8Uj4pID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlOiBzdHJpbmcsIGNvbnRleHQ6IHN0cmluZyk6ICdieXRlcycge1xuICB0eXBlID0gYCR7dHlwZX1gO1xuICBpZiAodHlwZSAhPT0gJ2J5dGVzJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7dHlwZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cbiIsImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnkgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9yZWFkZXItb3B0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zOiBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IG1vZGUgPSBvcHRpb25zPy5tb2RlO1xuICByZXR1cm4ge1xuICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZTogc3RyaW5nLCBjb250ZXh0OiBzdHJpbmcpOiAnYnlvYicge1xuICBtb2RlID0gYCR7bW9kZX1gO1xuICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuICB9XG4gIHJldHVybiBtb2RlO1xufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMsXG4gIFZhbGlkYXRlZFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9pdGVyYXRvci1vcHRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRJdGVyYXRvck9wdGlvbnMob3B0aW9uczogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucz8ucHJldmVudENhbmNlbDtcbiAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xufVxuIiwiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgU3RyZWFtUGlwZU9wdGlvbnMsIFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL3BpcGUtb3B0aW9ucyc7XG5pbXBvcnQgeyBBYm9ydFNpZ25hbCwgaXNBYm9ydFNpZ25hbCB9IGZyb20gJy4uL2Fib3J0LXNpZ25hbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UGlwZU9wdGlvbnMob3B0aW9uczogU3RyZWFtUGlwZU9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBWYWxpZGF0ZWRTdHJlYW1QaXBlT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnM/LnByZXZlbnRBYm9ydDtcbiAgY29uc3QgcHJldmVudENhbmNlbCA9IG9wdGlvbnM/LnByZXZlbnRDYW5jZWw7XG4gIGNvbnN0IHByZXZlbnRDbG9zZSA9IG9wdGlvbnM/LnByZXZlbnRDbG9zZTtcbiAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpZ25hbCcgdGhhdGApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJldmVudEFib3J0OiBCb29sZWFuKHByZXZlbnRBYm9ydCksXG4gICAgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSxcbiAgICBwcmV2ZW50Q2xvc2U6IEJvb2xlYW4ocHJldmVudENsb3NlKSxcbiAgICBzaWduYWxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsOiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHNpZ25hbCBpcyBBYm9ydFNpZ25hbCB7XG4gIGlmICghaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gQWJvcnRTaWduYWwuYCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydFJlcXVpcmVkRmllbGQgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IGFzc2VydFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgYXNzZXJ0V3JpdGFibGVTdHJlYW0gfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXI8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSwgV1MgZXh0ZW5kcyBXcml0YWJsZVN0cmVhbT4oXG4gIHBhaXI6IHsgcmVhZGFibGU6IFJTOyB3cml0YWJsZTogV1MgfSB8IG51bGwgfCB1bmRlZmluZWQsXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXUyB9IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShwYWlyLCBjb250ZXh0KTtcblxuICBjb25zdCByZWFkYWJsZSA9IHBhaXI/LnJlYWRhYmxlO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKHJlYWRhYmxlLCAncmVhZGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XG5cbiAgY29uc3Qgd3JpdGFibGUgPSBwYWlyPy53cml0YWJsZTtcbiAgYXNzZXJ0UmVxdWlyZWRGaWVsZCh3cml0YWJsZSwgJ3dyaXRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuXG4gIHJldHVybiB7IHJlYWRhYmxlLCB3cml0YWJsZSB9O1xufVxuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlLFxuICB0cmFuc2Zvcm1Qcm9taXNlV2l0aFxufSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IsIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2FzeW5jLWl0ZXJhdG9yJztcbmltcG9ydCB7IGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0LCBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0XG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHRcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vYnlvYi1yZWFkZXInO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1QaXBlVG8gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9waXBlJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtVGVlIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdGVlJztcbmltcG9ydCB7IElzV3JpdGFibGVTdHJlYW0sIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQsIFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQge1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2tcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IENyZWF0ZUFycmF5RnJvbUxpc3QgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IENhbmNlbFN0ZXBzIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRPYmplY3QsIGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgY29udmVydFF1ZXVpbmdTdHJhdGVneSB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEV4dHJhY3RIaWdoV2F0ZXJNYXJrLCBFeHRyYWN0U2l6ZUFsZ29yaXRobSB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIH0gZnJvbSAnLi92YWxpZGF0b3JzL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi92YWxpZGF0b3JzL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IFN0cmVhbVBpcGVPcHRpb25zLCBWYWxpZGF0ZWRTdHJlYW1QaXBlT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3BpcGUtb3B0aW9ucyc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2l0ZXJhdG9yLW9wdGlvbnMnO1xuaW1wb3J0IHsgY29udmVydEl0ZXJhdG9yT3B0aW9ucyB9IGZyb20gJy4vdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRQaXBlT3B0aW9ucyB9IGZyb20gJy4vdmFsaWRhdG9ycy9waXBlLW9wdGlvbnMnO1xuaW1wb3J0IHsgUmVhZGFibGVXcml0YWJsZVBhaXIgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciB9IGZyb20gJy4vdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVCeXRlU3RyZWFtID0gUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gJiB7XG4gIF9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcbn07XG5cbnR5cGUgUmVhZGFibGVTdHJlYW1TdGF0ZSA9ICdyZWFkYWJsZScgfCAnY2xvc2VkJyB8ICdlcnJvcmVkJztcblxuLyoqXG4gKiBBIHJlYWRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgc291cmNlIG9mIGRhdGEsIGZyb20gd2hpY2ggeW91IGNhbiByZWFkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtPFIgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBSZWFkYWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF9kaXN0dXJiZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIhOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHwgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3Rvcih1bmRlcmx5aW5nU291cmNlOiBVbmRlcmx5aW5nQnl0ZVNvdXJjZSwgc3RyYXRlZ3k/OiB7IGhpZ2hXYXRlck1hcms/OiBudW1iZXI7IHNpemU/OiB1bmRlZmluZWQgfSk7XG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTb3VyY2U/OiBVbmRlcmx5aW5nU291cmNlPFI+LCBzdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxSPik7XG4gIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2U6IFVuZGVybHlpbmdTb3VyY2U8Uj4gfCBVbmRlcmx5aW5nQnl0ZVNvdXJjZSB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3U3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxSPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdVbmRlcmx5aW5nU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSh0aGlzKTtcblxuICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG4gICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgICAgICAgdGhpcyBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgdW5kZXJseWluZ1NvdXJjZSxcbiAgICAgICAgaGlnaFdhdGVyTWFya1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHVuZGVybHlpbmdTb3VyY2UsXG4gICAgICAgIGhpZ2hXYXRlck1hcmssXG4gICAgICAgIHNpemVBbGdvcml0aG1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkYWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB8IHJlYWRlcn0uXG4gICAqL1xuICBnZXQgbG9ja2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cbiAgICpcbiAgICogVGhlIHN1cHBsaWVkIGByZWFzb25gIGFyZ3VtZW50IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHVuZGVybHlpbmcgc291cmNlJ3Mge0BsaW5rIFVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIHwgY2FuY2VsKCl9XG4gICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgYmVoYXZlcyB0aGUgc2FtZSB3YXkgYXMgdGhlIG5vLWFyZ3VtZW50IHZhcmlhbnQsIGV4Y2VwdCB0aGF0IGl0IG9ubHkgd29ya3Mgb24gcmVhZGFibGUgYnl0ZSBzdHJlYW1zLFxuICAgKiBpLmUuIHN0cmVhbXMgd2hpY2ggd2VyZSBjb25zdHJ1Y3RlZCBzcGVjaWZpY2FsbHkgd2l0aCB0aGUgYWJpbGl0eSB0byBoYW5kbGUgXCJicmluZyB5b3VyIG93biBidWZmZXJcIiByZWFkaW5nLlxuICAgKiBUaGUgcmV0dXJuZWQgQllPQiByZWFkZXIgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gZGlyZWN0bHkgcmVhZCBpbmRpdmlkdWFsIGNodW5rcyBmcm9tIHRoZSBzdHJlYW0gdmlhIGl0c1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCwgaW50byBkZXZlbG9wZXItc3VwcGxpZWQgYnVmZmVycywgYWxsb3dpbmcgbW9yZSBwcmVjaXNlXG4gICAqIGNvbnRyb2wgb3ZlciBhbGxvY2F0aW9uLlxuICAgKi9cbiAgZ2V0UmVhZGVyKHsgbW9kZSB9OiB7IG1vZGU6ICdieW9iJyB9KTogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKiBXaGlsZSB0aGUgc3RyZWFtIGlzIGxvY2tlZCwgbm8gb3RoZXIgcmVhZGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gY29uc3VtZSBhIHN0cmVhbVxuICAgKiBpbiBpdHMgZW50aXJldHkuIEJ5IGdldHRpbmcgYSByZWFkZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiBpbnRlcmxlYXZlIHJlYWRzIHdpdGggeW91cnNcbiAgICogb3IgY2FuY2VsIHRoZSBzdHJlYW0sIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHlvdXIgYWJzdHJhY3Rpb24uXG4gICAqL1xuICBnZXRSZWFkZXIoKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuICBnZXRSZWFkZXIoXG4gICAgcmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICApOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignZ2V0UmVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRSZWFkZXJPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KG9wdGlvbnMubW9kZSA9PT0gJ2J5b2InKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQsIGNoYWluYWJsZSB3YXkgb2YgcGlwaW5nIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRocm91Z2ggYSB0cmFuc2Zvcm0gc3RyZWFtXG4gICAqIChvciBhbnkgb3RoZXIgYHsgd3JpdGFibGUsIHJlYWRhYmxlIH1gIHBhaXIpLiBJdCBzaW1wbHkge0BsaW5rIFJlYWRhYmxlU3RyZWFtLnBpcGVUbyB8IHBpcGVzfSB0aGUgc3RyZWFtXG4gICAqIGludG8gdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHN1cHBsaWVkIHBhaXIsIGFuZCByZXR1cm5zIHRoZSByZWFkYWJsZSBzaWRlIGZvciBmdXJ0aGVyIHVzZS5cbiAgICpcbiAgICogUGlwaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBwaXBlLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICovXG4gIHBpcGVUaHJvdWdoPFJTIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0+KFxuICAgIHRyYW5zZm9ybTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbTxSPiB9LFxuICAgIG9wdGlvbnM/OiBTdHJlYW1QaXBlT3B0aW9uc1xuICApOiBSUztcbiAgcGlwZVRocm91Z2g8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbT4oXG4gICAgcmF3VHJhbnNmb3JtOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFI+IH0gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIHJhd09wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9XG4gICk6IFJTIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3BpcGVUaHJvdWdoJyk7XG4gICAgfVxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQocmF3VHJhbnNmb3JtLCAxLCAncGlwZVRocm91Z2gnKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyhcbiAgICAgIHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcblxuICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRvIGEgZ2l2ZW4gd3JpdGFibGUgc3RyZWFtLiBUaGUgd2F5IGluIHdoaWNoIHRoZSBwaXBpbmcgcHJvY2VzcyBiZWhhdmVzIHVuZGVyXG4gICAqIHZhcmlvdXMgZXJyb3IgY29uZGl0aW9ucyBjYW4gYmUgY3VzdG9taXplZCB3aXRoIGEgbnVtYmVyIG9mIHBhc3NlZCBvcHRpb25zLiBJdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzXG4gICAqIHdoZW4gdGhlIHBpcGluZyBwcm9jZXNzIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIG9yIHJlamVjdHMgaWYgYW55IGVycm9ycyB3ZXJlIGVuY291bnRlcmVkLlxuICAgKlxuICAgKiBQaXBpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBpcGUsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKi9cbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiwgb3B0aW9ucz86IFN0cmVhbVBpcGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICByYXdPcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncGlwZVRvJykpO1xuICAgIH1cblxuICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChgUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuYCk7XG4gICAgfVxuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJylcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG88Uj4oXG4gICAgICB0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG4gICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cbiAgICpcbiAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcbiAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxuICAgKi9cbiAgdGVlKCk6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3RlZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcywgZmFsc2UpO1xuICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRlcyBvdmVyIHRoZSBjaHVua3MgaW4gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRpbmcgb3ZlciB0aGUgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRoZSBsb2NrIHdpbGwgYmUgcmVsZWFzZWQgaWYgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kXG4gICAqIGlzIGNhbGxlZCwgZS5nLiBieSBicmVha2luZyBvdXQgb2YgdGhlIGxvb3AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGNhbGxpbmcgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kIHdpbGwgYWxzb1xuICAgKiBjYW5jZWwgdGhlIHN0cmVhbS4gVG8gcHJldmVudCB0aGlzLCB1c2UgdGhlIHN0cmVhbSdzIHtAbGluayBSZWFkYWJsZVN0cmVhbS52YWx1ZXMgfCB2YWx1ZXMoKX0gbWV0aG9kLCBwYXNzaW5nXG4gICAqIGB0cnVlYCBmb3IgdGhlIGBwcmV2ZW50Q2FuY2VsYCBvcHRpb24uXG4gICAqL1xuICB2YWx1ZXMob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+O1xuICB2YWx1ZXMocmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZhbHVlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAaW5oZXJpdERvYyBSZWFkYWJsZVN0cmVhbS52YWx1ZXN9XG4gICAqL1xuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKSA9PiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj47XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBwaXBlVGhyb3VnaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHBpcGVUbzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmlmICh0eXBlb2YgU3ltYm9sLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCB7XG4gICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBTdHJlYW1QaXBlT3B0aW9ucyxcbiAgUmVhZGFibGVXcml0YWJsZVBhaXIsXG4gIFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zXG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW08Uj4oc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcmsgPSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPiA9ICgpID0+IDEpOiBSZWFkYWJsZVN0cmVhbTxSPiB7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKGhpZ2hXYXRlck1hcmspKTtcblxuICBjb25zdCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG1cbiAgKTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShcbiAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD5cbik6IFJlYWRhYmxlQnl0ZVN0cmVhbSB7XG4gIGNvbnN0IHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDAsIHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdyZWFkYWJsZSc7XG4gIHN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4OiB1bmtub3duKTogeCBpcyBSZWFkYWJsZVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGlzdHVyYmVkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG5cbiAgcmV0dXJuIHN0cmVhbS5fZGlzdHVyYmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIGlmIChzdHJlYW0uX3JlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHModW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuXG4gIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DbG9zZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KTogdm9pZCB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHJlYWRlcikpIHtcbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgfSk7XG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LCBlOiBhbnkpOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIGUpO1xuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihyZWFkZXIpKSB7XG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICB9KTtcblxuICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpO1xuXG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICB9KTtcblxuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1SZWFkZXI8Uj4gPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG5cbmV4cG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXG59O1xuXG4vLyBDb250cm9sbGVyc1xuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xufVxuIiwiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0UmVxdWlyZWRGaWVsZCwgY29udmVydFVucmVzdHJpY3RlZERvdWJsZSB9IGZyb20gJy4vYmFzaWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQoaW5pdDogUXVldWluZ1N0cmF0ZWd5SW5pdCB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUXVldWluZ1N0cmF0ZWd5SW5pdCB7XG4gIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0Py5oaWdoV2F0ZXJNYXJrO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcbiAgcmV0dXJuIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG4gIH07XG59XG4iLCJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5LWluaXQnO1xuXG4vLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG5jb25zdCBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uID0gKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbn07XG50cnkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdzaXplJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59IGNhdGNoIHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG59XG5cbi8qKlxuICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gZWFjaCBjaHVuay5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kgaW1wbGVtZW50cyBRdWV1aW5nU3RyYXRlZ3k8QXJyYXlCdWZmZXJWaWV3PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVhZG9ubHkgX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUXVldWluZ1N0cmF0ZWd5SW5pdCkge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBnZXQgaGlnaFdhdGVyTWFyaygpOiBudW1iZXIge1xuICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIGl0cyBgYnl0ZUxlbmd0aGAgcHJvcGVydHkuXG4gICAqL1xuICBnZXQgc2l6ZSgpOiAoY2h1bms6IEFycmF5QnVmZmVyVmlldykgPT4gbnVtYmVyIHtcbiAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4OiBhbnkpOiB4IGlzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbn1cbiIsImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGNvdW50U2l6ZUZ1bmN0aW9uID0gKCk6IDEgPT4ge1xuICByZXR1cm4gMTtcbn07XG50cnkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY291bnRTaXplRnVuY3Rpb24sICduYW1lJywge1xuICAgIHZhbHVlOiAnc2l6ZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufSBjYXRjaCB7XG4gIC8vIFRoaXMgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSBpbiBvbGRlciBicm93c2Vycywgc28gaWdub3JlIGlmIHRoaXMgdGhyb3dzLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxufVxuXG4vKipcbiAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGNodW5rcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IGltcGxlbWVudHMgUXVldWluZ1N0cmF0ZWd5PGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IF9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmshOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUXVldWluZ1N0cmF0ZWd5SW5pdCkge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XG4gICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdldCBoaWdoV2F0ZXJNYXJrKCk6IG51bWJlciB7XG4gICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IGFsd2F5cyByZXR1cm5pbmcgMS5cbiAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG4gICAqL1xuICBnZXQgc2l6ZSgpOiAoY2h1bms6IGFueSkgPT4gMSB7XG4gICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnQ291bnRRdWV1aW5nU3RyYXRlZ3knLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIENvdW50UXVldWluZ1N0cmF0ZWd5LlxuXG5mdW5jdGlvbiBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBDb3VudFF1ZXVpbmdTdHJhdGVneWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4OiBhbnkpOiB4IGlzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBDb3VudFF1ZXVpbmdTdHJhdGVneTtcbn1cbiIsImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBwcm9taXNlQ2FsbCwgcmVmbGVjdENhbGwgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBUcmFuc2Zvcm1lcixcbiAgVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFRyYW5zZm9ybWVyXG59IGZyb20gJy4uL3RyYW5zZm9ybS1zdHJlYW0vdHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgfSBmcm9tICcuLi90cmFuc2Zvcm0tc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lcjxJLCBPPihvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4gfCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBWYWxpZGF0ZWRUcmFuc2Zvcm1lcjxJLCBPPiB7XG4gIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICBjb25zdCBmbHVzaCA9IG9yaWdpbmFsPy5mbHVzaDtcbiAgY29uc3QgcmVhZGFibGVUeXBlID0gb3JpZ2luYWw/LnJlYWRhYmxlVHlwZTtcbiAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbD8uc3RhcnQ7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IG9yaWdpbmFsPy50cmFuc2Zvcm07XG4gIGNvbnN0IHdyaXRhYmxlVHlwZSA9IG9yaWdpbmFsPy53cml0YWJsZVR5cGU7XG4gIHJldHVybiB7XG4gICAgZmx1c2g6IGZsdXNoID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZmx1c2gsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnZmx1c2gnIHRoYXRgKSxcbiAgICByZWFkYWJsZVR5cGUsXG4gICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayh0cmFuc2Zvcm0sIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksXG4gICAgd3JpdGFibGVUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2s8SSwgTz4oXG4gIGZuOiBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2s8Tz4sXG4gIG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjazxPPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2s8SSwgTz4sXG4gIG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY2h1bms6IEksIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNodW5rOiBJLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlamVjdGVkV2l0aCwgcHJvbWlzZVJlc29sdmVkV2l0aCwgdHJhbnNmb3JtUHJvbWlzZVdpdGggfSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IENyZWF0ZVJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmVcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IENyZWF0ZVdyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSwgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQgfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRXh0cmFjdEhpZ2hXYXRlck1hcmssIEV4dHJhY3RTaXplQWxnb3JpdGhtIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQge1xuICBUcmFuc2Zvcm1lcixcbiAgVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFRyYW5zZm9ybWVyXG59IGZyb20gJy4vdHJhbnNmb3JtLXN0cmVhbS90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBjb252ZXJ0VHJhbnNmb3JtZXIgfSBmcm9tICcuL3ZhbGlkYXRvcnMvdHJhbnNmb3JtZXInO1xuXG4vLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1cblxuLyoqXG4gKiBBIHRyYW5zZm9ybSBzdHJlYW0gY29uc2lzdHMgb2YgYSBwYWlyIG9mIHN0cmVhbXM6IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSxcbiAqIGtub3duIGFzIGl0cyB3cml0YWJsZSBzaWRlLCBhbmQgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19LCBrbm93biBhcyBpdHMgcmVhZGFibGUgc2lkZS5cbiAqIEluIGEgbWFubmVyIHNwZWNpZmljIHRvIHRoZSB0cmFuc2Zvcm0gc3RyZWFtIGluIHF1ZXN0aW9uLCB3cml0ZXMgdG8gdGhlIHdyaXRhYmxlIHNpZGUgcmVzdWx0IGluIG5ldyBkYXRhIGJlaW5nXG4gKiBtYWRlIGF2YWlsYWJsZSBmb3IgcmVhZGluZyBmcm9tIHRoZSByZWFkYWJsZSBzaWRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybVN0cmVhbTxJID0gYW55LCBPID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRhYmxlITogV3JpdGFibGVTdHJlYW08ST47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRhYmxlITogUmVhZGFibGVTdHJlYW08Tz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZSE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UhOiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUhOiAoKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyITogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdHJhbnNmb3JtZXI/OiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgICB3cml0YWJsZVN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PEk+LFxuICAgIHJlYWRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Tz5cbiAgKTtcbiAgY29uc3RydWN0b3IocmF3VHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyPEksIE8+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdXcml0YWJsZVN0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3k8ST4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1JlYWRhYmxlU3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxPPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByYXdUcmFuc2Zvcm1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3V3JpdGFibGVTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdSZWFkYWJsZVN0cmF0ZWd5LCAnVGhpcmQgcGFyYW1ldGVyJyk7XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgcmVhZGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZXIud3JpdGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhyZWFkYWJsZVN0cmF0ZWd5LCAwKTtcbiAgICBjb25zdCByZWFkYWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShyZWFkYWJsZVN0cmF0ZWd5KTtcbiAgICBjb25zdCB3cml0YWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayh3cml0YWJsZVN0cmF0ZWd5LCAxKTtcbiAgICBjb25zdCB3cml0YWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobSh3cml0YWJsZVN0cmF0ZWd5KTtcblxuICAgIGxldCBzdGFydFByb21pc2VfcmVzb2x2ZSE6ICh2YWx1ZTogdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KSA9PiB2b2lkO1xuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKFxuICAgICAgdGhpcywgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG1cbiAgICApO1xuICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIodGhpcywgdHJhbnNmb3JtZXIpO1xuXG4gICAgaWYgKHRyYW5zZm9ybWVyLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHRyYW5zZm9ybWVyLnN0YXJ0KHRoaXMuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBnZXQgcmVhZGFibGUoKTogUmVhZGFibGVTdHJlYW08Tz4ge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWRhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgKi9cbiAgZ2V0IHdyaXRhYmxlKCk6IFdyaXRhYmxlU3RyZWFtPEk+IHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0YWJsZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG4gIHJlYWRhYmxlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgVHJhbnNmb3JtZXIsXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrXG59O1xuXG4vLyBUcmFuc2Zvcm0gU3RyZWFtIEFic3RyYWN0IE9wZXJhdGlvbnNcblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVRyYW5zZm9ybVN0cmVhbTxJLCBPPihzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG06IChjaHVuazogSSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPEk+ID0gKCkgPT4gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Tz4gPSAoKSA9PiAxKSB7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKHdyaXRhYmxlSGlnaFdhdGVyTWFyaykpO1xuICBhc3NlcnQoSXNOb25OZWdhdGl2ZU51bWJlcihyZWFkYWJsZUhpZ2hXYXRlck1hcmspKTtcblxuICBjb25zdCBzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlITogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ7XG4gIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgc3RhcnRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcblxuICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSwgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4gPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgc3RhcnRQcm9taXNlX3Jlc29sdmUoc3RhcnRSZXN1bHQpO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFByb21pc2U6IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxJPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPE8+KSB7XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBzdGFydFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuazogSSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZSA9IENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuXG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgcmVhc29uKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgLy8gVGhlIFtbYmFja3ByZXNzdXJlXV0gc2xvdCBpcyBzZXQgdG8gdW5kZWZpbmVkIHNvIHRoYXQgaXQgY2FuIGJlIGluaXRpYWxpc2VkIGJ5IFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZS5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZCE7XG4gIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXG4gIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcbn1cblxuLy8gVGhpcyBpcyBhIG5vLW9wIGlmIGJvdGggc2lkZXMgYXJlIGFscmVhZHkgZXJyb3JlZC5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtLCBlOiBhbnkpIHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKFxuICAgIHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sXG4gICAgZVxuICApO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGU6IGFueSkge1xuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChzdHJlYW0uX3dyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAvLyBQcmV0ZW5kIHRoYXQgcHVsbCgpIHdhcyBjYWxsZWQgdG8gcGVybWl0IGFueSBwZW5kaW5nIHdyaXRlKCkgY2FsbHMgdG8gY29tcGxldGUuIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZSgpXG4gICAgLy8gY2Fubm90IGJlIGNhbGxlZCBmcm9tIGVucXVldWUoKSBvciBwdWxsKCkgb25jZSB0aGUgUmVhZGFibGVTdHJlYW0gaXMgZXJyb3JlZCwgc28gdGhpcyB3aWxsIHdpbGwgYmUgdGhlIGZpbmFsIHRpbWVcbiAgICAvLyBfYmFja3ByZXNzdXJlIGlzIHNldC5cbiAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtLCBiYWNrcHJlc3N1cmU6IGJvb2xlYW4pIHtcbiAgLy8gUGFzc2VzIGFsc28gd2hlbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgYXNzZXJ0KHN0cmVhbS5fYmFja3ByZXNzdXJlICE9PSBiYWNrcHJlc3N1cmUpO1xuXG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG4gIH1cblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG59XG5cbi8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXG5cbi8qKlxuICogQWxsb3dzIGNvbnRyb2wgb2YgdGhlIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gYW5kIHtAbGluayBXcml0YWJsZVN0cmVhbX0gb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRyYW5zZm9ybVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08YW55LCBPPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHJlYWRhYmxlIHNpZGXigJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgYGNodW5rYCBpbiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgKi9cbiAgZW5xdWV1ZShjaHVuazogTyk6IHZvaWQ7XG4gIGVucXVldWUoY2h1bms6IE8gPSB1bmRlZmluZWQhKTogdm9pZCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyBib3RoIHRoZSByZWFkYWJsZSBzaWRlIGFuZCB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZVxuICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKi9cbiAgZXJyb3IocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSByZWFkYWJsZSBzaWRlIGFuZCBlcnJvcnMgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGVcbiAgICogdHJhbnNmb3JtZXIgb25seSBuZWVkcyB0byBjb25zdW1lIGEgcG9ydGlvbiBvZiB0aGUgY2h1bmtzIHdyaXR0ZW4gdG8gdGhlIHdyaXRhYmxlIHNpZGUuXG4gICAqL1xuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Rlcm1pbmF0ZScpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0ZXJtaW5hdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gVHJhbnNmb3JtIFN0cmVhbSBEZWZhdWx0IENvbnRyb2xsZXIgQWJzdHJhY3QgT3BlcmF0aW9uc1xuXG5mdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8gPSBhbnk+KHg6IGFueSk6IHggaXMgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobTogKGNodW5rOiBJKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPikge1xuICBhc3NlcnQoSXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG59XG5cbmZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXI8SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBWYWxpZGF0ZWRUcmFuc2Zvcm1lcjxJLCBPPikge1xuICBjb25zdCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuayBhcyB1bmtub3duIGFzIE8pO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9IGNhdGNoICh0cmFuc2Zvcm1SZXN1bHRFKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSEoY2h1bmssIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiB0cmFuc2Zvcm1lci5mbHVzaCEoY29udHJvbGxlcik7XG4gIH1cblxuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWU8Tz4oY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4sIGNodW5rOiBPKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG4gIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+O1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGUgc2lkZSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICB9XG5cbiAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcbiAgLy8gYWNjZXB0IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSgpIGNhbGxzLlxuXG4gIHRyeSB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiByZWFkYWJsZVN0cmF0ZWd5LnNpemUoKSB0aHJvd3MuXG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXG4gICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gIH1cblxuICBjb25zdCBiYWNrcHJlc3N1cmUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gIGlmIChiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgYXNzZXJ0KGJhY2twcmVzc3VyZSk7XG4gICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlOiBhbnkpIHtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgZSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogSSkge1xuICBjb25zdCB0cmFuc2Zvcm1Qcm9taXNlID0gY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtKGNodW5rKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHRyYW5zZm9ybVByb21pc2UsIHVuZGVmaW5lZCwgciA9PiB7XG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgcik7XG4gICAgdGhyb3cgcjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlPE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG4gIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+O1xuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcignVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWQnKTtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmsgQWxnb3JpdGhtc1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LCBjaHVuazogSSk6IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnQoc3RyZWFtLl93cml0YWJsZS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgdGhyb3cgd3JpdGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnKTtcbiAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm08SSwgTz4oY29udHJvbGxlciwgY2h1bmspO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyLCBjaHVuayk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIGFib3J0KCkgaXMgbm90IGNhbGxlZCBzeW5jaHJvbm91c2x5LCBzbyBpdCBpcyBwb3NzaWJsZSBmb3IgYWJvcnQoKSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGFscmVhZHlcbiAgLy8gZXJyb3JlZC5cbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cbiAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXG4gIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWQgb24gc3VjY2Vzcy5cbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KTtcbiAgfSwgciA9PiB7XG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByKTtcbiAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gIH0pO1xufVxuXG4vLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlIEFsZ29yaXRobXNcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gSW52YXJpYW50LiBFbmZvcmNlZCBieSB0aGUgcHJvbWlzZXMgcmV0dXJuZWQgYnkgc3RhcnQoKSBhbmQgcHVsbCgpLlxuICBhc3NlcnQoc3RyZWFtLl9iYWNrcHJlc3N1cmUpO1xuXG4gIGFzc2VydChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCk7XG5cbiAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuXG4gIC8vIFByZXZlbnQgdGhlIG5leHQgcHVsbCgpIGNhbGwgdW50aWwgdGhlcmUgaXMgYmFja3ByZXNzdXJlLlxuICByZXR1cm4gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtYCk7XG59XG4iLCIvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8vIDY0IEtpQiAoc2FtZSBzaXplIGNocm9tZSBzbGljZSB0aGVpcnMgYmxvYiBpbnRvIFVpbnQ4YXJyYXkncylcbmNvbnN0IFBPT0xfU0laRSA9IDY1NTM2XG5cbmlmICghZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkge1xuICAvLyBgbm9kZTpzdHJlYW0vd2ViYCBnb3QgaW50cm9kdWNlZCBpbiB2MTYuNS4wIGFzIGV4cGVyaW1lbnRhbFxuICAvLyBhbmQgaXQncyBwcmVmZXJyZWQgb3ZlciB0aGUgcG9seWZpbGxlZCB2ZXJzaW9uLiBTbyB3ZSBhbHNvXG4gIC8vIHN1cHByZXNzIHRoZSB3YXJuaW5nIHRoYXQgZ2V0cyBlbWl0dGVkIGJ5IE5vZGVKUyBmb3IgdXNpbmcgaXQuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ25vZGU6cHJvY2VzcycpXG4gICAgY29uc3QgeyBlbWl0V2FybmluZyB9ID0gcHJvY2Vzc1xuICAgIHRyeSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gKCkgPT4ge31cbiAgICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZSgnbm9kZTpzdHJlYW0vd2ViJykpXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmdcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9IGVtaXRXYXJuaW5nXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBmYWxsYmFjayB0byBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvblxuICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZSgnd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanMnKSlcbiAgfVxufVxuXG50cnkge1xuICAvLyBEb24ndCB1c2Ugbm9kZTogcHJlZml4IGZvciB0aGlzLCByZXF1aXJlK25vZGU6IGlzIG5vdCBzdXBwb3J0ZWQgdW50aWwgbm9kZSB2MTQuMTRcbiAgLy8gT25seSBgaW1wb3J0KClgIGNhbiB1c2UgcHJlZml4IGluIDEyLjIwIGFuZCBsYXRlclxuICBjb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGlmIChCbG9iICYmICFCbG9iLnByb3RvdHlwZS5zdHJlYW0pIHtcbiAgICBCbG9iLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiBuYW1lIChwYXJhbXMpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IDBcbiAgICAgIGNvbnN0IGJsb2IgPSB0aGlzXG5cbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBibG9iLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihibG9iLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFKSlcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpXG4gICAgICAgICAgcG9zaXRpb24gKz0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICBjdHJsLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcblxuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gYmxvYi5zaXplKSB7XG4gICAgICAgICAgICBjdHJsLmNsb3NlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59IGNhdGNoIChlcnJvcikge31cbi8qIGM4IGlnbm9yZSBlbmQgKi9cbiIsbnVsbCwiaW1wb3J0IEJsb2IgZnJvbSAnLi9pbmRleC5qcydcblxuY29uc3QgX0ZpbGUgPSBjbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XG4gICNsYXN0TW9kaWZpZWQgPSAwXG4gICNuYW1lID0gJydcblxuICAvKipcbiAgICogQHBhcmFtIHsqW119IGZpbGVCaXRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZVxuICAgKiBAcGFyYW0ge3tsYXN0TW9kaWZpZWQ/OiBudW1iZXIsIHR5cGU/OiBzdHJpbmd9fSBvcHRpb25zXG4gICAqLy8vIEB0cy1pZ25vcmVcbiAgY29uc3RydWN0b3IgKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdGaWxlJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gKVxuICAgIH1cbiAgICBzdXBlcihmaWxlQml0cywgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICAgIC8vIFNpbXVsYXRlIFdlYklETCB0eXBlIGNhc3RpbmcgZm9yIE5hTiB2YWx1ZSBpbiBsYXN0TW9kaWZpZWQgb3B0aW9uLlxuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB1bmRlZmluZWQgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKVxuICAgIGlmICghTnVtYmVyLmlzTmFOKGxhc3RNb2RpZmllZCkpIHtcbiAgICAgIHRoaXMuI2xhc3RNb2RpZmllZCA9IGxhc3RNb2RpZmllZFxuICAgIH1cblxuICAgIHRoaXMuI25hbWUgPSBTdHJpbmcoZmlsZU5hbWUpXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI25hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdGaWxlJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gISFvYmplY3QgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYiAmJlxuICAgICAgL14oRmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuRmlsZX0gKi8vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgRmlsZSA9IF9GaWxlXG5leHBvcnQgZGVmYXVsdCBGaWxlXG4iLCJpbXBvcnQgeyBzdGF0U3luYywgY3JlYXRlUmVhZFN0cmVhbSwgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgYmFzZW5hbWUgfSBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgRE9NRXhjZXB0aW9uIGZyb20gJ25vZGUtZG9tZXhjZXB0aW9uJ1xuXG5pbXBvcnQgRmlsZSBmcm9tICcuL2ZpbGUuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xuXG5jb25zdCB7IHN0YXQgfSA9IGZzXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKi9cbmNvbnN0IGJsb2JGcm9tU3luYyA9IChwYXRoLCB0eXBlKSA9PiBmcm9tQmxvYihzdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2I+fVxuICovXG5jb25zdCBibG9iRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oc3RhdCA9PiBmcm9tQmxvYihzdGF0LCBwYXRoLCB0eXBlKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGU+fVxuICovXG5jb25zdCBmaWxlRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oc3RhdCA9PiBmcm9tRmlsZShzdGF0LCBwYXRoLCB0eXBlKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgZmlsZUZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21GaWxlKHN0YXRTeW5jKHBhdGgpLCBwYXRoLCB0eXBlKVxuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQmxvYiA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBCbG9iKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgeyB0eXBlIH0pXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IEZpbGUoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCBiYXNlbmFtZShwYXRoKSwgeyB0eXBlLCBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyB9KVxuXG4vKipcbiAqIFRoaXMgaXMgYSBibG9iIGJhY2tlZCB1cCBieSBhIGZpbGUgb24gdGhlIGRpc2tcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcbiAqIHNvIHlvdSBoYXZlIG5vIGRpcmVjdCBhY2Nlc3MgdG8gdGhpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCbG9iRGF0YUl0ZW0ge1xuICAjcGF0aFxuICAjc3RhcnRcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuI3BhdGggPSBvcHRpb25zLnBhdGhcbiAgICB0aGlzLiNzdGFydCA9IG9wdGlvbnMuc3RhcnRcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemVcbiAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkXG4gIH1cblxuICAvKipcbiAgICogU2xpY2luZyBhcmd1bWVudHMgaXMgZmlyc3QgdmFsaWRhdGVkIGFuZCBmb3JtYXR0ZWRcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgIHNpemU6IGVuZCAtIHN0YXJ0LFxuICAgICAgc3RhcnQ6IHRoaXMuI3N0YXJ0ICsgc3RhcnRcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgKiBzdHJlYW0gKCkge1xuICAgIGNvbnN0IHsgbXRpbWVNcyB9ID0gYXdhaXQgc3RhdCh0aGlzLiNwYXRoKVxuICAgIGlmIChtdGltZU1zID4gdGhpcy5sYXN0TW9kaWZpZWQpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSByZXF1ZXN0ZWQgZmlsZSBjb3VsZCBub3QgYmUgcmVhZCwgdHlwaWNhbGx5IGR1ZSB0byBwZXJtaXNzaW9uIHByb2JsZW1zIHRoYXQgaGF2ZSBvY2N1cnJlZCBhZnRlciBhIHJlZmVyZW5jZSB0byBhIGZpbGUgd2FzIGFjcXVpcmVkLicsICdOb3RSZWFkYWJsZUVycm9yJylcbiAgICB9XG4gICAgeWllbGQgKiBjcmVhdGVSZWFkU3RyZWFtKHRoaXMuI3BhdGgsIHtcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCxcbiAgICAgIGVuZDogdGhpcy4jc3RhcnQgKyB0aGlzLnNpemUgLSAxXG4gICAgfSlcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJsb2JGcm9tU3luY1xuZXhwb3J0IHsgRmlsZSwgQmxvYiwgYmxvYkZyb20sIGJsb2JGcm9tU3luYywgZmlsZUZyb20sIGZpbGVGcm9tU3luYyB9XG4iLCIvKiEgZmV0Y2gtYmxvYi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuLy8gVE9ETyAoamltbXl3YXJ0aW5nKTogaW4gdGhlIGZlYXR1cmUgdXNlIGNvbmRpdGlvbmFsIGxvYWRpbmcgd2l0aCB0b3AgbGV2ZWwgYXdhaXQgKHJlcXVpcmVzIDE0LngpXG4vLyBOb2RlIGhhcyByZWNlbnRseSBhZGRlZCB3aGF0d2cgc3RyZWFtIGludG8gY29yZVxuXG5pbXBvcnQgJy4vc3RyZWFtcy5janMnXG5cbi8vIDY0IEtpQiAoc2FtZSBzaXplIGNocm9tZSBzbGljZSB0aGVpcnMgYmxvYiBpbnRvIFVpbnQ4YXJyYXkncylcbmNvbnN0IFBPT0xfU0laRSA9IDY1NTM2XG5cbi8qKiBAcGFyYW0geyhCbG9iIHwgVWludDhBcnJheSlbXX0gcGFydHMgKi9cbmFzeW5jIGZ1bmN0aW9uICogdG9JdGVyYXRvciAocGFydHMsIGNsb25lID0gdHJ1ZSkge1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoJ3N0cmVhbScgaW4gcGFydCkge1xuICAgICAgeWllbGQgKiAoLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VWludDhBcnJheT59ICovIChwYXJ0LnN0cmVhbSgpKSlcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnQuYnl0ZU9mZnNldFxuICAgICAgICBjb25zdCBlbmQgPSBwYXJ0LmJ5dGVPZmZzZXQgKyBwYXJ0LmJ5dGVMZW5ndGhcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBlbmQpIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oZW5kIC0gcG9zaXRpb24sIFBPT0xfU0laRSlcbiAgICAgICAgICBjb25zdCBjaHVuayA9IHBhcnQuYnVmZmVyLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpXG4gICAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGNodW5rKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBwYXJ0XG4gICAgICB9XG4gICAgLyogYzggaWdub3JlIG5leHQgMTAgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGJsb2JzIHRoYXQgaGF2ZSBhcnJheUJ1ZmZlciBidXQgbm8gc3RyZWFtIG1ldGhvZCAobm9kZXMgYnVmZmVyLkJsb2IpXG4gICAgICBsZXQgcG9zaXRpb24gPSAwLCBiID0gKC8qKiBAdHlwZSB7QmxvYn0gKi8gKHBhcnQpKVxuICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBiLnNpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBiLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihiLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFKSlcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKVxuICAgICAgICBwb3NpdGlvbiArPSBidWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICB5aWVsZCBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IF9CbG9iID0gY2xhc3MgQmxvYiB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPChCbG9ifFVpbnQ4QXJyYXkpPn0gKi9cbiAgI3BhcnRzID0gW11cbiAgI3R5cGUgPSAnJ1xuICAjc2l6ZSA9IDBcbiAgI2VuZGluZ3MgPSAndHJhbnNwYXJlbnQnXG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iKCkgY29uc3RydWN0b3IgcmV0dXJucyBhIG5ldyBCbG9iIG9iamVjdC4gVGhlIGNvbnRlbnRcbiAgICogb2YgdGhlIGJsb2IgY29uc2lzdHMgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHZhbHVlcyBnaXZlblxuICAgKiBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGJsb2JQYXJ0c1xuICAgKiBAcGFyYW0ge3sgdHlwZT86IHN0cmluZywgZW5kaW5ncz86IHN0cmluZyB9fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yIChibG9iUGFydHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHMgIT09ICdvYmplY3QnIHx8IGJsb2JQYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBUaGUgcHJvdmlkZWQgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlLicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBUaGUgb2JqZWN0IG11c3QgaGF2ZSBhIGNhbGxhYmxlIEBAaXRlcmF0b3IgcHJvcGVydHkuJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IHBhcmFtZXRlciAyIGNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuJylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9XG5cbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICBsZXQgcGFydFxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlbGVtZW50KSkge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5idWZmZXIuc2xpY2UoZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVPZmZzZXQgKyBlbGVtZW50LmJ5dGVMZW5ndGgpKVxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcGFydCA9IG5ldyBVaW50OEFycmF5KGVsZW1lbnQuc2xpY2UoMCkpXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHBhcnQgPSBlbGVtZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gZW5jb2Rlci5lbmNvZGUoYCR7ZWxlbWVudH1gKVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNzaXplICs9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZVxuICAgICAgdGhpcy4jcGFydHMucHVzaChwYXJ0KVxuICAgIH1cblxuICAgIHRoaXMuI2VuZGluZ3MgPSBgJHtvcHRpb25zLmVuZGluZ3MgPT09IHVuZGVmaW5lZCA/ICd0cmFuc3BhcmVudCcgOiBvcHRpb25zLmVuZGluZ3N9YFxuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKG9wdGlvbnMudHlwZSlcbiAgICB0aGlzLiN0eXBlID0gL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QodHlwZSkgPyB0eXBlIDogJydcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQmxvYiBpbnRlcmZhY2UncyBzaXplIHByb3BlcnR5IHJldHVybnMgdGhlXG4gICAqIHNpemUgb2YgdGhlIEJsb2IgaW4gYnl0ZXMuXG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpemVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBwcm9wZXJ0eSBvZiBhIEJsb2Igb2JqZWN0IHJldHVybnMgdGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHlwZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0KCkgbWV0aG9kIGluIHRoZSBCbG9iIGludGVyZmFjZSByZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgY29udGVudHMgb2ZcbiAgICogdGhlIGJsb2IsIGludGVycHJldGVkIGFzIFVURi04LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBhc3luYyB0ZXh0ICgpIHtcbiAgICAvLyBNb3JlIG9wdGltaXplZCB0aGFuIHVzaW5nIHRoaXMuYXJyYXlCdWZmZXIoKVxuICAgIC8vIHRoYXQgcmVxdWlyZXMgdHdpY2UgYXMgbXVjaCByYW1cbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBsZXQgc3RyID0gJydcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgZmFsc2UpKSB7XG4gICAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUocGFydCwgeyBzdHJlYW06IHRydWUgfSlcbiAgICB9XG4gICAgLy8gUmVtYWluaW5nXG4gICAgc3RyICs9IGRlY29kZXIuZGVjb2RlKClcbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIGluIHRoZSBCbG9iIGludGVyZmFjZSByZXR1cm5zIGFcbiAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBibG9iIGFzXG4gICAqIGJpbmFyeSBkYXRhIGNvbnRhaW5lZCBpbiBhbiBBcnJheUJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgLy8gRWFzaWVyIHdheS4uLiBKdXN0IGEgdW5uZWNlc3Nhcnkgb3ZlcmhlYWRcbiAgICAvLyBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICAvLyBhd2FpdCB0aGlzLnN0cmVhbSgpLmdldFJlYWRlcih7bW9kZTogJ2J5b2InfSkucmVhZCh2aWV3KTtcbiAgICAvLyByZXR1cm4gdmlldy5idWZmZXI7XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKVxuICAgIGxldCBvZmZzZXQgPSAwXG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCBmYWxzZSkpIHtcbiAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuYnVmZmVyXG4gIH1cblxuICBzdHJlYW0gKCkge1xuICAgIGNvbnN0IGl0ID0gdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgdHJ1ZSlcblxuICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSh7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgYXN5bmMgcHVsbCAoY3RybCkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IGl0Lm5leHQoKVxuICAgICAgICBjaHVuay5kb25lID8gY3RybC5jbG9zZSgpIDogY3RybC5lbnF1ZXVlKGNodW5rLnZhbHVlKVxuICAgICAgfSxcblxuICAgICAgYXN5bmMgY2FuY2VsICgpIHtcbiAgICAgICAgYXdhaXQgaXQucmV0dXJuKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNsaWNlKCkgbWV0aG9kIGNyZWF0ZXMgYW5kIHJldHVybnMgYVxuICAgKiBuZXcgQmxvYiBvYmplY3Qgd2hpY2ggY29udGFpbnMgZGF0YSBmcm9tIGEgc3Vic2V0IG9mIHRoZVxuICAgKiBibG9iIG9uIHdoaWNoIGl0J3MgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5zaXplLCB0eXBlID0gJycpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IHRoaXNcblxuICAgIGxldCByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBzaXplKVxuICAgIGxldCByZWxhdGl2ZUVuZCA9IGVuZCA8IDAgPyBNYXRoLm1heChzaXplICsgZW5kLCAwKSA6IE1hdGgubWluKGVuZCwgc2l6ZSlcblxuICAgIGNvbnN0IHNwYW4gPSBNYXRoLm1heChyZWxhdGl2ZUVuZCAtIHJlbGF0aXZlU3RhcnQsIDApXG4gICAgY29uc3QgcGFydHMgPSB0aGlzLiNwYXJ0c1xuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdXG4gICAgbGV0IGFkZGVkID0gMFxuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcbiAgICAgIGlmIChhZGRlZCA+PSBzcGFuKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemVcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0ICYmIHNpemUgPD0gcmVsYXRpdmVTdGFydCkge1xuICAgICAgICAvLyBTa2lwIHRoZSBiZWdpbm5pbmcgYW5kIGNoYW5nZSB0aGUgcmVsYXRpdmVcbiAgICAgICAgLy8gc3RhcnQgJiBlbmQgcG9zaXRpb24gYXMgd2Ugc2tpcCB0aGUgdW53YW50ZWQgcGFydHNcbiAgICAgICAgcmVsYXRpdmVTdGFydCAtPSBzaXplXG4gICAgICAgIHJlbGF0aXZlRW5kIC09IHNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaHVua1xuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICAgICAgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUsIHJlbGF0aXZlRW5kKSlcbiAgICAgICAgICBhZGRlZCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBwYXJ0LnNsaWNlKHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUsIHJlbGF0aXZlRW5kKSlcbiAgICAgICAgICBhZGRlZCArPSBjaHVuay5zaXplXG4gICAgICAgIH1cbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICAgICAgcmVsYXRpdmVTdGFydCA9IDAgLy8gQWxsIG5leHQgc2VxdWVudGlhbCBwYXJ0cyBzaG91bGQgc3RhcnQgYXQgMFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXSwgeyB0eXBlOiBTdHJpbmcodHlwZSkudG9Mb3dlckNhc2UoKSB9KVxuICAgIGJsb2IuI3NpemUgPSBzcGFuXG4gICAgYmxvYi4jcGFydHMgPSBibG9iUGFydHNcblxuICAgIHJldHVybiBibG9iXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnQmxvYidcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAob2JqZWN0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChcbiAgICAgICAgdHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSAmJlxuICAgICAgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gICAgKVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9CbG9iLnByb3RvdHlwZSwge1xuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSlcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5CbG9ifSAqL1xuZXhwb3J0IGNvbnN0IEJsb2IgPSBfQmxvYlxuZXhwb3J0IGRlZmF1bHQgQmxvYlxuIiwiLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG5pbXBvcnQgQyBmcm9tICdmZXRjaC1ibG9iJ1xuaW1wb3J0IEYgZnJvbSAnZmV0Y2gtYmxvYi9maWxlLmpzJ1xuXG52YXIge3RvU3RyaW5nVGFnOnQsaXRlcmF0b3I6aSxoYXNJbnN0YW5jZTpofT1TeW1ib2wsXG5yPU1hdGgucmFuZG9tLFxubT0nYXBwZW5kLHNldCxnZXQsZ2V0QWxsLGRlbGV0ZSxrZXlzLHZhbHVlcyxlbnRyaWVzLGZvckVhY2gsY29uc3RydWN0b3InLnNwbGl0KCcsJyksXG5mPShhLGIsYyk9PihhKz0nJywvXihCbG9ifEZpbGUpJC8udGVzdChiICYmIGJbdF0pP1soYz1jIT09dm9pZCAwP2MrJyc6Ylt0XT09J0ZpbGUnP2IubmFtZTonYmxvYicsYSksYi5uYW1lIT09Y3x8Ylt0XT09J2Jsb2InP25ldyBGKFtiXSxjLGIpOmJdOlthLGIrJyddKSxcbmU9KGMsZik9PihmP2M6Yy5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCdcXHJcXG4nKSkucmVwbGFjZSgvXFxuL2csJyUwQScpLnJlcGxhY2UoL1xcci9nLCclMEQnKS5yZXBsYWNlKC9cIi9nLCclMjInKSxcbng9KG4sIGEsIGUpPT57aWYoYS5sZW5ndGg8ZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bn0nIG9uICdGb3JtRGF0YSc6ICR7ZX0gYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2EubGVuZ3RofSBwcmVzZW50LmApfX1cblxuZXhwb3J0IGNvbnN0IEZpbGUgPSBGXG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuRm9ybURhdGF9ICovXG5leHBvcnQgY29uc3QgRm9ybURhdGEgPSBjbGFzcyBGb3JtRGF0YSB7XG4jZD1bXTtcbmNvbnN0cnVjdG9yKC4uLmEpe2lmKGEubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0hUTUxGb3JtRWxlbWVudCcuYCl9XG5nZXQgW3RdKCkge3JldHVybiAnRm9ybURhdGEnfVxuW2ldKCl7cmV0dXJuIHRoaXMuZW50cmllcygpfVxuc3RhdGljIFtoXShvKSB7cmV0dXJuIG8mJnR5cGVvZiBvPT09J29iamVjdCcmJm9bdF09PT0nRm9ybURhdGEnJiYhbS5zb21lKG09PnR5cGVvZiBvW21dIT0nZnVuY3Rpb24nKX1cbmFwcGVuZCguLi5hKXt4KCdhcHBlbmQnLGFyZ3VtZW50cywyKTt0aGlzLiNkLnB1c2goZiguLi5hKSl9XG5kZWxldGUoYSl7eCgnZGVsZXRlJyxhcmd1bWVudHMsMSk7YSs9Jyc7dGhpcy4jZD10aGlzLiNkLmZpbHRlcigoW2JdKT0+YiE9PWEpfVxuZ2V0KGEpe3goJ2dldCcsYXJndW1lbnRzLDEpO2ErPScnO2Zvcih2YXIgYj10aGlzLiNkLGw9Yi5sZW5ndGgsYz0wO2M8bDtjKyspaWYoYltjXVswXT09PWEpcmV0dXJuIGJbY11bMV07cmV0dXJuIG51bGx9XG5nZXRBbGwoYSxiKXt4KCdnZXRBbGwnLGFyZ3VtZW50cywxKTtiPVtdO2ErPScnO3RoaXMuI2QuZm9yRWFjaChjPT5jWzBdPT09YSYmYi5wdXNoKGNbMV0pKTtyZXR1cm4gYn1cbmhhcyhhKXt4KCdoYXMnLGFyZ3VtZW50cywxKTthKz0nJztyZXR1cm4gdGhpcy4jZC5zb21lKGI9PmJbMF09PT1hKX1cbmZvckVhY2goYSxiKXt4KCdmb3JFYWNoJyxhcmd1bWVudHMsMSk7Zm9yKHZhciBbYyxkXW9mIHRoaXMpYS5jYWxsKGIsZCxjLHRoaXMpfVxuc2V0KC4uLmEpe3goJ3NldCcsYXJndW1lbnRzLDIpO3ZhciBiPVtdLGM9ITA7YT1mKC4uLmEpO3RoaXMuI2QuZm9yRWFjaChkPT57ZFswXT09PWFbMF0/YyYmKGM9IWIucHVzaChhKSk6Yi5wdXNoKGQpfSk7YyYmYi5wdXNoKGEpO3RoaXMuI2Q9Yn1cbiplbnRyaWVzKCl7eWllbGQqdGhpcy4jZH1cbiprZXlzKCl7Zm9yKHZhclthXW9mIHRoaXMpeWllbGQgYX1cbip2YWx1ZXMoKXtmb3IodmFyWyxhXW9mIHRoaXMpeWllbGQgYX19XG5cbi8qKiBAcGFyYW0ge0Zvcm1EYXRhfSBGICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybURhdGFUb0Jsb2IgKEYsQj1DKXtcbnZhciBiPWAke3IoKX0ke3IoKX1gLnJlcGxhY2UoL1xcLi9nLCAnJykuc2xpY2UoLTI4KS5wYWRTdGFydCgzMiwgJy0nKSxjPVtdLHA9YC0tJHtifVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cImBcbkYuZm9yRWFjaCgodixuKT0+dHlwZW9mIHY9PSdzdHJpbmcnXG4/Yy5wdXNoKHArZShuKStgXCJcXHJcXG5cXHJcXG4ke3YucmVwbGFjZSgvXFxyKD8hXFxuKXwoPzwhXFxyKVxcbi9nLCAnXFxyXFxuJyl9XFxyXFxuYClcbjpjLnB1c2gocCtlKG4pK2BcIjsgZmlsZW5hbWU9XCIke2Uodi5uYW1lLCAxKX1cIlxcclxcbkNvbnRlbnQtVHlwZTogJHt2LnR5cGV8fFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9XFxyXFxuXFxyXFxuYCwgdiwgJ1xcclxcbicpKVxuYy5wdXNoKGAtLSR7Yn0tLWApXG5yZXR1cm4gbmV3IEIoYyx7dHlwZTpcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PVwiK2J9KX1cbiIsImltcG9ydCBmZXRjaCwge0hlYWRlcnMsIFJlcXVlc3QsIFJlc3BvbnNlfSBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCBBYm9ydENvbnRyb2xsZXIgZnJvbSAnYWJvcnQtY29udHJvbGxlcic7XG5cbmNvbnN0IFRFTl9NRUdBQllURVMgPSAxMDAwICogMTAwMCAqIDEwO1xuXG5pZiAoIWdsb2JhbFRoaXMuZmV0Y2gpIHtcblx0Z2xvYmFsVGhpcy5mZXRjaCA9ICh1cmwsIG9wdGlvbnMpID0+IGZldGNoKHVybCwge2hpZ2hXYXRlck1hcms6IFRFTl9NRUdBQllURVMsIC4uLm9wdGlvbnN9KTtcbn1cblxuaWYgKCFnbG9iYWxUaGlzLkhlYWRlcnMpIHtcblx0Z2xvYmFsVGhpcy5IZWFkZXJzID0gSGVhZGVycztcbn1cblxuaWYgKCFnbG9iYWxUaGlzLlJlcXVlc3QpIHtcblx0Z2xvYmFsVGhpcy5SZXF1ZXN0ID0gUmVxdWVzdDtcbn1cblxuaWYgKCFnbG9iYWxUaGlzLlJlc3BvbnNlKSB7XG5cdGdsb2JhbFRoaXMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbn1cblxuaWYgKCFnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcikge1xuXHRnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjtcbn1cblxuaWYgKCFnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSB7XG5cdHRyeSB7XG5cdFx0Z2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9IGF3YWl0IGltcG9ydCgnd2ViLXN0cmVhbXMtcG9seWZpbGwvcG9ueWZpbGwvZXMyMDE4Jyk7XG5cdH0gY2F0Y2gge31cbn1cblxuY29uc3Qge2RlZmF1bHQ6IGt5LCBIVFRQRXJyb3IsIFRpbWVvdXRFcnJvcn0gPSBhd2FpdCBpbXBvcnQoJ2t5Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IGt5O1xuZXhwb3J0IHtIVFRQRXJyb3IsIFRpbWVvdXRFcnJvcn07XG4iLCJcbi8qKlxuICogQm9keS5qc1xuICpcbiAqIEJvZHkgaW50ZXJmYWNlIHByb3ZpZGVzIGNvbW1vbiBtZXRob2RzIGZvciBSZXF1ZXN0IGFuZCBSZXNwb25zZVxuICovXG5cbmltcG9ydCBTdHJlYW0sIHtQYXNzVGhyb3VnaH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHt0eXBlcywgZGVwcmVjYXRlLCBwcm9taXNpZnl9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnbm9kZTpidWZmZXInO1xuXG5pbXBvcnQgQmxvYiBmcm9tICdmZXRjaC1ibG9iJztcbmltcG9ydCB7Rm9ybURhdGEsIGZvcm1EYXRhVG9CbG9ifSBmcm9tICdmb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzJztcblxuaW1wb3J0IHtGZXRjaEVycm9yfSBmcm9tICcuL2Vycm9ycy9mZXRjaC1lcnJvci5qcyc7XG5pbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Vycm9ycy9iYXNlLmpzJztcbmltcG9ydCB7aXNCbG9iLCBpc1VSTFNlYXJjaFBhcmFtZXRlcnN9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuXG5jb25zdCBwaXBlbGluZSA9IHByb21pc2lmeShTdHJlYW0ucGlwZWxpbmUpO1xuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdCb2R5IGludGVybmFscycpO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSwge1xuXHRcdHNpemUgPSAwXG5cdH0gPSB7fSkge1xuXHRcdGxldCBib3VuZGFyeSA9IG51bGw7XG5cblx0XHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0Ym9keSA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChpc1VSTFNlYXJjaFBhcmFtZXRlcnMoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuXHRcdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIGJsb2Jcblx0XHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBCdWZmZXJcblx0XHR9IGVsc2UgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdFx0Ly8gQm9keSBpcyBzdHJlYW1cblx0XHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0Ly8gQm9keSBpcyBGb3JtRGF0YVxuXHRcdFx0Ym9keSA9IGZvcm1EYXRhVG9CbG9iKGJvZHkpO1xuXHRcdFx0Ym91bmRhcnkgPSBib2R5LnR5cGUuc3BsaXQoJz0nKVsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gTm9uZSBvZiB0aGUgYWJvdmVcblx0XHRcdC8vIGNvZXJjZSB0byBzdHJpbmcgdGhlbiBidWZmZXJcblx0XHRcdGJvZHkgPSBCdWZmZXIuZnJvbShTdHJpbmcoYm9keSkpO1xuXHRcdH1cblxuXHRcdGxldCBzdHJlYW0gPSBib2R5O1xuXG5cdFx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0c3RyZWFtID0gU3RyZWFtLlJlYWRhYmxlLmZyb20oYm9keSk7XG5cdFx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRcdHN0cmVhbSA9IFN0cmVhbS5SZWFkYWJsZS5mcm9tKGJvZHkuc3RyZWFtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdGJvZHksXG5cdFx0XHRzdHJlYW0sXG5cdFx0XHRib3VuZGFyeSxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0XHRib2R5Lm9uKCdlcnJvcicsIGVycm9yXyA9PiB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZXJyb3JfIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgP1xuXHRcdFx0XHRcdGVycm9yXyA6XG5cdFx0XHRcdFx0bmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHt0aGlzLnVybH06ICR7ZXJyb3JfLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yXyk7XG5cdFx0XHRcdHRoaXNbSU5URVJOQUxTXS5lcnJvciA9IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdHJlYW07XG5cdH1cblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHRhc3luYyBmb3JtRGF0YSgpIHtcblx0XHRjb25zdCBjdCA9IHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXG5cdFx0aWYgKGN0LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKSB7XG5cdFx0XHRjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgdGhpcy50ZXh0KCkpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycykge1xuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ybURhdGE7XG5cdFx0fVxuXG5cdFx0Y29uc3Qge3RvRm9ybURhdGF9ID0gYXdhaXQgaW1wb3J0KCcuL3V0aWxzL211bHRpcGFydC1wYXJzZXIuanMnKTtcblx0XHRyZXR1cm4gdG9Gb3JtRGF0YSh0aGlzLmJvZHksIGN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gcmF3IHJlc3BvbnNlIGFzIEJsb2Jcblx0ICpcblx0ICogQHJldHVybiBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBibG9iKCkge1xuXHRcdGNvbnN0IGN0ID0gKHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgfHwgKHRoaXNbSU5URVJOQUxTXS5ib2R5ICYmIHRoaXNbSU5URVJOQUxTXS5ib2R5LnR5cGUpIHx8ICcnO1xuXHRcdGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuYXJyYXlCdWZmZXIoKTtcblxuXHRcdHJldHVybiBuZXcgQmxvYihbYnVmXSwge1xuXHRcdFx0dHlwZTogY3Rcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMganNvblxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBqc29uKCkge1xuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLnRleHQoKTtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyB0ZXh0KCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNvbnN1bWVCb2R5KHRoaXMpO1xuXHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgYnVmZmVyIChub24tc3BlYyBhcGkpXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGJ1ZmZlcigpIHtcblx0XHRyZXR1cm4gY29uc3VtZUJvZHkodGhpcyk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUuYnVmZmVyID0gZGVwcmVjYXRlKEJvZHkucHJvdG90eXBlLmJ1ZmZlciwgJ1BsZWFzZSB1c2UgXFwncmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxcJyBpbnN0ZWFkIG9mIFxcJ3Jlc3BvbnNlLmJ1ZmZlcigpXFwnJywgJ25vZGUtZmV0Y2gjYnVmZmVyJyk7XG5cbi8vIEluIGJyb3dzZXJzLCBhbGwgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvZHkucHJvdG90eXBlLCB7XG5cdGJvZHk6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0Ym9keVVzZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0YXJyYXlCdWZmZXI6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0YmxvYjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRqc29uOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHRleHQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0ZGF0YToge2dldDogZGVwcmVjYXRlKCgpID0+IHt9LFxuXHRcdCdkYXRhIGRvZXNuXFwndCBleGlzdCwgdXNlIGpzb24oKSwgdGV4dCgpLCBhcnJheUJ1ZmZlcigpLCBvciBib2R5IGluc3RlYWQnLFxuXHRcdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXNwb25zZSknKX1cbn0pO1xuXG4vKipcbiAqIENvbnN1bWUgYW5kIGNvbnZlcnQgYW4gZW50aXJlIEJvZHkgdG8gYSBCdWZmZXIuXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNvbnN1bWUtYm9keVxuICpcbiAqIEByZXR1cm4gUHJvbWlzZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGlmIChkYXRhW0lOVEVSTkFMU10uZGlzdHVyYmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2RhdGEudXJsfWApO1xuXHR9XG5cblx0ZGF0YVtJTlRFUk5BTFNdLmRpc3R1cmJlZCA9IHRydWU7XG5cblx0aWYgKGRhdGFbSU5URVJOQUxTXS5lcnJvcikge1xuXHRcdHRocm93IGRhdGFbSU5URVJOQUxTXS5lcnJvcjtcblx0fVxuXG5cdGNvbnN0IHtib2R5fSA9IGRhdGE7XG5cblx0Ly8gQm9keSBpcyBudWxsXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcblx0fVxuXG5cdC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cblx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW1cblx0Ly8gZ2V0IHJlYWR5IHRvIGFjdHVhbGx5IGNvbnN1bWUgdGhlIGJvZHlcblx0Y29uc3QgYWNjdW0gPSBbXTtcblx0bGV0IGFjY3VtQnl0ZXMgPSAwO1xuXG5cdHRyeSB7XG5cdFx0Zm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG5cdFx0XHRpZiAoZGF0YS5zaXplID4gMCAmJiBhY2N1bUJ5dGVzICsgY2h1bmsubGVuZ3RoID4gZGF0YS5zaXplKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEZldGNoRXJyb3IoYGNvbnRlbnQgc2l6ZSBhdCAke2RhdGEudXJsfSBvdmVyIGxpbWl0OiAke2RhdGEuc2l6ZX1gLCAnbWF4LXNpemUnKTtcblx0XHRcdFx0Ym9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cblx0XHRcdGFjY3VtQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXHRcdFx0YWNjdW0ucHVzaChjaHVuayk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGNvbnN0IGVycm9yXyA9IGVycm9yIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgPyBlcnJvciA6IG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKTtcblx0XHR0aHJvdyBlcnJvcl87XG5cdH1cblxuXHRpZiAoYm9keS5yZWFkYWJsZUVuZGVkID09PSB0cnVlIHx8IGJvZHkuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPT09IHRydWUpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGFjY3VtLmV2ZXJ5KGMgPT4gdHlwZW9mIGMgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0XHRyZXR1cm4gQnVmZmVyLmZyb20oYWNjdW0uam9pbignJykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQnVmZmVyLmNvbmNhdChhY2N1bSwgYWNjdW1CeXRlcyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRocm93IG5ldyBGZXRjaEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIEJ1ZmZlciBmcm9tIHJlc3BvbnNlIGJvZHkgZm9yICR7ZGF0YS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYFByZW1hdHVyZSBjbG9zZSBvZiBzZXJ2ZXIgcmVzcG9uc2Ugd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDbG9uZSBib2R5IGdpdmVuIFJlcy9SZXEgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGluc3RhbmNlICAgICAgIFJlc3BvbnNlIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIFN0cmluZyAgaGlnaFdhdGVyTWFyayAgaGlnaFdhdGVyTWFyayBmb3IgYm90aCBQYXNzVGhyb3VnaCBib2R5IHN0cmVhbXNcbiAqIEByZXR1cm4gIE1peGVkXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IChpbnN0YW5jZSwgaGlnaFdhdGVyTWFyaykgPT4ge1xuXHRsZXQgcDE7XG5cdGxldCBwMjtcblx0bGV0IHtib2R5fSA9IGluc3RhbmNlW0lOVEVSTkFMU107XG5cblx0Ly8gRG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIENoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmICgoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgJiYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdC8vIFRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgUGFzc1Rocm91Z2goe2hpZ2hXYXRlck1hcmt9KTtcblx0XHRwMiA9IG5ldyBQYXNzVGhyb3VnaCh7aGlnaFdhdGVyTWFya30pO1xuXHRcdGJvZHkucGlwZShwMSk7XG5cdFx0Ym9keS5waXBlKHAyKTtcblx0XHQvLyBTZXQgaW5zdGFuY2UgYm9keSB0byB0ZWVkIGJvZHkgYW5kIHJldHVybiB0aGUgb3RoZXIgdGVlZCBib2R5XG5cdFx0aW5zdGFuY2VbSU5URVJOQUxTXS5zdHJlYW0gPSBwMTtcblx0XHRib2R5ID0gcDI7XG5cdH1cblxuXHRyZXR1cm4gYm9keTtcbn07XG5cbmNvbnN0IGdldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5ID0gZGVwcmVjYXRlKFxuXHRib2R5ID0+IGJvZHkuZ2V0Qm91bmRhcnkoKSxcblx0J2Zvcm0tZGF0YSBkb2VzblxcJ3QgZm9sbG93IHRoZSBzcGVjIGFuZCByZXF1aXJlcyBzcGVjaWFsIHRyZWF0bWVudC4gVXNlIGFsdGVybmF0aXZlIHBhY2thZ2UnLFxuXHQnaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTE2Nydcbik7XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG9wZXJhdGlvbiBcImV4dHJhY3QgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tIHxvYmplY3R8XCIgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpbnN0YW5jZS5ib2R5IGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHthbnl9IGJvZHkgQW55IG9wdGlvbnMuYm9keSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0Q29udGVudFR5cGUgPSAoYm9keSwgcmVxdWVzdCkgPT4ge1xuXHQvLyBCb2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmluZ1xuXHRpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG5cdFx0cmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCc7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGJsb2Jcblx0aWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnR5cGUgfHwgbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgYSBCdWZmZXIgKEJ1ZmZlciwgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KVxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpIHx8IHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke3JlcXVlc3RbSU5URVJOQUxTXS5ib3VuZGFyeX1gO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0aWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7Ym91bmRhcnk9JHtnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeShib2R5KX1gO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW0gLSBjYW4ndCByZWFsbHkgZG8gbXVjaCBhYm91dCB0aGlzXG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGNvbnN0cnVjdG9yIGRlZmF1bHRzIG90aGVyIHRoaW5ncyB0byBzdHJpbmdcblx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xufTtcblxuLyoqXG4gKiBUaGUgRmV0Y2ggU3RhbmRhcmQgdHJlYXRzIHRoaXMgYXMgaWYgXCJ0b3RhbCBieXRlc1wiIGlzIGEgcHJvcGVydHkgb24gdGhlIGJvZHkuXG4gKiBGb3IgdXMsIHdlIGhhdmUgdG8gZXhwbGljaXRseSBnZXQgaXQgd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIHJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS10b3RhbC1ieXRlc1xuICpcbiAqIEBwYXJhbSB7YW55fSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3RhbEJ5dGVzID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtib2R5fSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblxuXHQvLyBCb2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHQvLyBCb2R5IGlzIEJsb2Jcblx0aWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnNpemU7XG5cdH1cblxuXHQvLyBCb2R5IGlzIEJ1ZmZlclxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkubGVuZ3RoO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0aWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSA/IGJvZHkuZ2V0TGVuZ3RoU3luYygpIDogbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtXG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhIEJvZHkgdG8gYSBOb2RlLmpzIFdyaXRhYmxlU3RyZWFtIChlLmcuIGh0dHAuUmVxdWVzdCkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyZWFtLldyaXRhYmxlfSBkZXN0IFRoZSBzdHJlYW0gdG8gd3JpdGUgdG8uXG4gKiBAcGFyYW0gb2JqLmJvZHkgQm9keSBvYmplY3QgZnJvbSB0aGUgQm9keSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUb1N0cmVhbSA9IGFzeW5jIChkZXN0LCB7Ym9keX0pID0+IHtcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBCb2R5IGlzIG51bGxcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJvZHkgaXMgc3RyZWFtXG5cdFx0YXdhaXQgcGlwZWxpbmUoYm9keSwgZGVzdCk7XG5cdH1cbn07XG4iLCJpbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUgPSAnYWJvcnRlZCcpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0fVxufVxuIiwiZXhwb3J0IGNsYXNzIEZldGNoQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuIiwiXG5pbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGFkZHJlc3M/OiBzdHJpbmcsIGNvZGU6IHN0cmluZywgZGVzdD86IHN0cmluZywgZXJybm86IG51bWJlciwgaW5mbz86IG9iamVjdCwgbWVzc2FnZTogc3RyaW5nLCBwYXRoPzogc3RyaW5nLCBwb3J0PzogbnVtYmVyLCBzeXNjYWxsOiBzdHJpbmd9fSBTeXN0ZW1FcnJvclxuKi9cblxuLyoqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRmV0Y2hCYXNlRXJyb3Ige1xuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlIC0gICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IFt0eXBlXSAtICAgICAgICBFcnJvciB0eXBlIGZvciBtYWNoaW5lXG5cdCAqIEBwYXJhbSAge1N5c3RlbUVycm9yfSBbc3lzdGVtRXJyb3JdIC0gRm9yIE5vZGUuanMgc3lzdGVtIGVycm9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlLCBzeXN0ZW1FcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHR5cGUpO1xuXHRcdC8vIFdoZW4gZXJyLnR5cGUgaXMgYHN5c3RlbWAsIGVyci5lcnJvcmVkU3lzQ2FsbCBjb250YWlucyBzeXN0ZW0gZXJyb3IgYW5kIGVyci5jb2RlIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBjb2RlXG5cdFx0aWYgKHN5c3RlbUVycm9yKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG5cdFx0XHR0aGlzLmNvZGUgPSB0aGlzLmVycm5vID0gc3lzdGVtRXJyb3IuY29kZTtcblx0XHRcdHRoaXMuZXJyb3JlZFN5c0NhbGwgPSBzeXN0ZW1FcnJvci5zeXNjYWxsO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqXG4gKiBIZWFkZXJzLmpzXG4gKlxuICogSGVhZGVycyBjbGFzcyBvZmZlcnMgY29udmVuaWVudCBoZWxwZXJzXG4gKi9cblxuaW1wb3J0IHt0eXBlc30gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBodHRwIGZyb20gJ25vZGU6aHR0cCc7XG5cbi8qIGM4IGlnbm9yZSBuZXh0IDkgKi9cbmNvbnN0IHZhbGlkYXRlSGVhZGVyTmFtZSA9IHR5cGVvZiBodHRwLnZhbGlkYXRlSGVhZGVyTmFtZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdGh0dHAudmFsaWRhdGVIZWFkZXJOYW1lIDpcblx0bmFtZSA9PiB7XG5cdFx0aWYgKCEvXltcXF5gXFwtXFx3ISMkJSYnKisufH5dKyQvLnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSGVhZGVyIG5hbWUgbXVzdCBiZSBhIHZhbGlkIEhUVFAgdG9rZW4gWyR7bmFtZX1dYCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2RlJywge3ZhbHVlOiAnRVJSX0lOVkFMSURfSFRUUF9UT0tFTid9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fTtcblxuLyogYzggaWdub3JlIG5leHQgOSAqL1xuY29uc3QgdmFsaWRhdGVIZWFkZXJWYWx1ZSA9IHR5cGVvZiBodHRwLnZhbGlkYXRlSGVhZGVyVmFsdWUgPT09ICdmdW5jdGlvbicgP1xuXHRodHRwLnZhbGlkYXRlSGVhZGVyVmFsdWUgOlxuXHQobmFtZSwgdmFsdWUpID0+IHtcblx0XHRpZiAoL1teXFx0XFx1MDAyMC1cXHUwMDdFXFx1MDA4MC1cXHUwMEZGXS8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtuYW1lfVwiXWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29kZScsIHt2YWx1ZTogJ0VSUl9JTlZBTElEX0NIQVInfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH07XG5cbi8qKlxuICogQHR5cGVkZWYge0hlYWRlcnMgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgSXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgc3RyaW5nXT4gfCBJdGVyYWJsZTxJdGVyYWJsZTxzdHJpbmc+Pn0gSGVhZGVyc0luaXRcbiAqL1xuXG4vKipcbiAqIFRoaXMgRmV0Y2ggQVBJIGludGVyZmFjZSBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdmFyaW91cyBhY3Rpb25zIG9uIEhUVFAgcmVxdWVzdCBhbmQgcmVzcG9uc2UgaGVhZGVycy5cbiAqIFRoZXNlIGFjdGlvbnMgaW5jbHVkZSByZXRyaWV2aW5nLCBzZXR0aW5nLCBhZGRpbmcgdG8sIGFuZCByZW1vdmluZy5cbiAqIEEgSGVhZGVycyBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgaGVhZGVyIGxpc3QsIHdoaWNoIGlzIGluaXRpYWxseSBlbXB0eSBhbmQgY29uc2lzdHMgb2YgemVybyBvciBtb3JlIG5hbWUgYW5kIHZhbHVlIHBhaXJzLlxuICogWW91IGNhbiBhZGQgdG8gdGhpcyB1c2luZyBtZXRob2RzIGxpa2UgYXBwZW5kKCkgKHNlZSBFeGFtcGxlcy4pXG4gKiBJbiBhbGwgbWV0aG9kcyBvZiB0aGlzIGludGVyZmFjZSwgaGVhZGVyIG5hbWVzIGFyZSBtYXRjaGVkIGJ5IGNhc2UtaW5zZW5zaXRpdmUgYnl0ZSBzZXF1ZW5jZS5cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlcnMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuXHQvKipcblx0ICogSGVhZGVycyBjbGFzc1xuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIZWFkZXJzSW5pdH0gW2luaXRdIC0gUmVzcG9uc2UgaGVhZGVyc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoaW5pdCkge1xuXHRcdC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgaW5pdCBvYmplY3QgaW4gW25hbWUsIHZhbHVlKHMpXVtdXG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXVtdfSAqL1xuXHRcdGxldCByZXN1bHQgPSBbXTtcblx0XHRpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IHJhdyA9IGluaXQucmF3KCk7XG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKHJhdykpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goLi4udmFsdWVzLm1hcCh2YWx1ZSA9PiBbbmFtZSwgdmFsdWVdKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbml0ID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdC8vIE5vIG9wXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcgJiYgIXR5cGVzLmlzQm94ZWRQcmltaXRpdmUoaW5pdCkpIHtcblx0XHRcdGNvbnN0IG1ldGhvZCA9IGluaXRbU3ltYm9sLml0ZXJhdG9yXTtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdGlmIChtZXRob2QgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBSZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cblx0XHRcdFx0cmVzdWx0LnB1c2goLi4uT2JqZWN0LmVudHJpZXMoaW5pdCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdFx0cmVzdWx0ID0gWy4uLmluaXRdXG5cdFx0XHRcdFx0Lm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0dHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IHR5cGVzLmlzQm94ZWRQcmltaXRpdmUocGFpcilcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0Jyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdFx0fSkubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhIG5hbWUvdmFsdWUgdHVwbGUnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdIZWFkZXJzXFwnOiBUaGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9mIHR5cGUgXFwnKHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiBvciByZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4pJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVmFsaWRhdGUgYW5kIGxvd2VyY2FzZVxuXHRcdHJlc3VsdCA9XG5cdFx0XHRyZXN1bHQubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHJlc3VsdC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gW1N0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpLCBTdHJpbmcodmFsdWUpXTtcblx0XHRcdFx0fSkgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cblx0XHRzdXBlcihyZXN1bHQpO1xuXG5cdFx0Ly8gUmV0dXJuaW5nIGEgUHJveHkgdGhhdCB3aWxsIGxvd2VyY2FzZSBrZXkgbmFtZXMsIHZhbGlkYXRlIHBhcmFtZXRlcnMgYW5kIHNvcnQga2V5c1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cblx0XHRyZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcblx0XHRcdGdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKSB7XG5cdFx0XHRcdHN3aXRjaCAocCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XG5cdFx0XHRcdFx0Y2FzZSAnc2V0Jzpcblx0XHRcdFx0XHRcdHJldHVybiAobmFtZSwgdmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtwXS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcodmFsdWUpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRjYXNlICdoYXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldEFsbCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmFtZSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdrZXlzJzpcblx0XHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zb3J0KCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgU2V0KFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5cy5jYWxsKHRhcmdldCkpLmtleXMoKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0LyogYzggaWdub3JlIG5leHQgKi9cblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcblx0fVxuXG5cdGdldChuYW1lKSB7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGxldCB2YWx1ZSA9IHZhbHVlcy5qb2luKCcsICcpO1xuXHRcdGlmICgvXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChuYW1lKSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcgPSB1bmRlZmluZWQpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdFJlZmxlY3QuYXBwbHkoY2FsbGJhY2ssIHRoaXNBcmcsIFt0aGlzLmdldChuYW1lKSwgbmFtZSwgdGhpc10pO1xuXHRcdH1cblx0fVxuXG5cdCogdmFsdWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0eWllbGQgdGhpcy5nZXQobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+fVxuXHQgKi9cblx0KiBlbnRyaWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0eWllbGQgW25hbWUsIHRoaXMuZ2V0KG5hbWUpXTtcblx0XHR9XG5cdH1cblxuXHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTm9kZS1mZXRjaCBub24tc3BlYyBtZXRob2Rcblx0ICogcmV0dXJuaW5nIGFsbCBoZWFkZXJzIGFuZCB0aGVpciB2YWx1ZXMgYXMgYXJyYXlcblx0ICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdPn1cblx0ICovXG5cdHJhdygpIHtcblx0XHRyZXR1cm4gWy4uLnRoaXMua2V5cygpXS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3IgYmV0dGVyIGNvbnNvbGUubG9nKGhlYWRlcnMpIGFuZCBhbHNvIHRvIGNvbnZlcnQgSGVhZGVycyBpbnRvIE5vZGUuanMgUmVxdWVzdCBjb21wYXRpYmxlIGZvcm1hdFxuXHQgKi9cblx0W1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHQvLyBIdHRwLnJlcXVlc3QoKSBvbmx5IHN1cHBvcnRzIHN0cmluZyBhcyBIb3N0IGhlYWRlci5cblx0XHRcdC8vIFRoaXMgaGFjayBtYWtlcyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0XHRcdGlmIChrZXkgPT09ICdob3N0Jykge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzLmxlbmd0aCA+IDEgPyB2YWx1ZXMgOiB2YWx1ZXNbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwge30pO1xuXHR9XG59XG5cbi8qKlxuICogUmUtc2hhcGluZyBvYmplY3QgZm9yIFdlYiBJREwgdGVzdHNcbiAqIE9ubHkgbmVlZCB0byBkbyBpdCBmb3Igb3ZlcnJpZGRlbiBtZXRob2RzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRIZWFkZXJzLnByb3RvdHlwZSxcblx0WydnZXQnLCAnZW50cmllcycsICdmb3JFYWNoJywgJ3ZhbHVlcyddLnJlZHVjZSgocmVzdWx0LCBwcm9wZXJ0eSkgPT4ge1xuXHRcdHJlc3VsdFtwcm9wZXJ0eV0gPSB7ZW51bWVyYWJsZTogdHJ1ZX07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwge30pXG4pO1xuXG4vKipcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gaHR0cC5JbmNvbWluZ01lc3NhZ2UucmF3SGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2VbJ3Jhd0hlYWRlcnMnXX0gaGVhZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJhd0hlYWRlcnMoaGVhZGVycyA9IFtdKSB7XG5cdHJldHVybiBuZXcgSGVhZGVycyhcblx0XHRoZWFkZXJzXG5cdFx0XHQvLyBTcGxpdCBpbnRvIHBhaXJzXG5cdFx0XHQucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcblx0XHRcdFx0aWYgKGluZGV4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCBbXSlcblx0XHRcdC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdCk7XG59XG4iLCIvKipcbiAqIEluZGV4LmpzXG4gKlxuICogYSByZXF1ZXN0IEFQSSBjb21wYXRpYmxlIHdpdGggd2luZG93LmZldGNoXG4gKlxuICogQWxsIHNwZWMgYWxnb3JpdGhtIHN0ZXAgbnVtYmVycyBhcmUgYmFzZWQgb24gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvY29tbWl0LXNuYXBzaG90cy9hZTcxNjgyMmNiM2E2MTg0MzIyNmNkMDkwZWVmYzY1ODk0NDZjMWQyLy5cbiAqL1xuXG5pbXBvcnQgaHR0cCBmcm9tICdub2RlOmh0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ25vZGU6aHR0cHMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnbm9kZTp6bGliJztcbmltcG9ydCBTdHJlYW0sIHtQYXNzVGhyb3VnaCwgcGlwZWxpbmUgYXMgcHVtcH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ25vZGU6YnVmZmVyJztcblxuaW1wb3J0IGRhdGFVcmlUb0J1ZmZlciBmcm9tICdkYXRhLXVyaS10by1idWZmZXInO1xuXG5pbXBvcnQge3dyaXRlVG9TdHJlYW0sIGNsb25lfSBmcm9tICcuL2JvZHkuanMnO1xuaW1wb3J0IFJlc3BvbnNlIGZyb20gJy4vcmVzcG9uc2UuanMnO1xuaW1wb3J0IEhlYWRlcnMsIHtmcm9tUmF3SGVhZGVyc30gZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCBSZXF1ZXN0LCB7Z2V0Tm9kZVJlcXVlc3RPcHRpb25zfSBmcm9tICcuL3JlcXVlc3QuanMnO1xuaW1wb3J0IHtGZXRjaEVycm9yfSBmcm9tICcuL2Vycm9ycy9mZXRjaC1lcnJvci5qcyc7XG5pbXBvcnQge0Fib3J0RXJyb3J9IGZyb20gJy4vZXJyb3JzL2Fib3J0LWVycm9yLmpzJztcbmltcG9ydCB7aXNSZWRpcmVjdH0gZnJvbSAnLi91dGlscy9pcy1yZWRpcmVjdC5qcyc7XG5pbXBvcnQge0Zvcm1EYXRhfSBmcm9tICdmb3JtZGF0YS1wb2x5ZmlsbC9lc20ubWluLmpzJztcbmltcG9ydCB7aXNEb21haW5PclN1YmRvbWFpbiwgaXNTYW1lUHJvdG9jb2x9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcn0gZnJvbSAnLi91dGlscy9yZWZlcnJlci5qcyc7XG5pbXBvcnQge1xuXHRCbG9iLFxuXHRGaWxlLFxuXHRmaWxlRnJvbVN5bmMsXG5cdGZpbGVGcm9tLFxuXHRibG9iRnJvbVN5bmMsXG5cdGJsb2JGcm9tXG59IGZyb20gJ2ZldGNoLWJsb2IvZnJvbS5qcyc7XG5cbmV4cG9ydCB7Rm9ybURhdGEsIEhlYWRlcnMsIFJlcXVlc3QsIFJlc3BvbnNlLCBGZXRjaEVycm9yLCBBYm9ydEVycm9yLCBpc1JlZGlyZWN0fTtcbmV4cG9ydCB7QmxvYiwgRmlsZSwgZmlsZUZyb21TeW5jLCBmaWxlRnJvbSwgYmxvYkZyb21TeW5jLCBibG9iRnJvbX07XG5cbmNvbnN0IHN1cHBvcnRlZFNjaGVtYXMgPSBuZXcgU2V0KFsnZGF0YTonLCAnaHR0cDonLCAnaHR0cHM6J10pO1xuXG4vKipcbiAqIEZldGNoIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtICAge3N0cmluZyB8IFVSTCB8IGltcG9ydCgnLi9yZXF1ZXN0JykuZGVmYXVsdH0gdXJsIC0gQWJzb2x1dGUgdXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHsqfSBbb3B0aW9uc19dIC0gRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAge1Byb21pc2U8aW1wb3J0KCcuL3Jlc3BvbnNlJykuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9uc18pIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQvLyBCdWlsZCByZXF1ZXN0IG9iamVjdFxuXHRcdGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIG9wdGlvbnNfKTtcblx0XHRjb25zdCB7cGFyc2VkVVJMLCBvcHRpb25zfSA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblx0XHRpZiAoIXN1cHBvcnRlZFNjaGVtYXMuaGFzKHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYG5vZGUtZmV0Y2ggY2Fubm90IGxvYWQgJHt1cmx9LiBVUkwgc2NoZW1lIFwiJHtwYXJzZWRVUkwucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyl9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcblx0XHR9XG5cblx0XHRpZiAocGFyc2VkVVJMLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gZGF0YVVyaVRvQnVmZmVyKHJlcXVlc3QudXJsKTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEsIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IGRhdGEudHlwZUZ1bGx9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXcmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdFx0Y29uc3Qgc2VuZCA9IChwYXJzZWRVUkwucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0O1xuXHRcdGNvbnN0IHtzaWduYWx9ID0gcmVxdWVzdDtcblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgYWJvcnQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicpO1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdHJlcXVlc3QuYm9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlLmJvZHkuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cdFx0fTtcblxuXHRcdGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWJvcnRBbmRGaW5hbGl6ZSA9ICgpID0+IHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHQvLyBTZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXF1ZXN0XyA9IHNlbmQocGFyc2VkVVJMLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG5cdFx0XHRyZXF1ZXN0Xy5hYm9ydCgpO1xuXHRcdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVxdWVzdF8ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGZhaWxlZCwgcmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdF8sIGVycm9yID0+IHtcblx0XHRcdGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5ib2R5KSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAxOCAqL1xuXHRcdGlmIChwcm9jZXNzLnZlcnNpb24gPCAndjE0Jykge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXF1ZXN0Xy5vbignc29ja2V0JywgcyA9PiB7XG5cdFx0XHRcdGxldCBlbmRlZFdpdGhFdmVudHNDb3VudDtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRlbmRlZFdpdGhFdmVudHNDb3VudCA9IHMuX2V2ZW50c0NvdW50O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgaGFkRXJyb3IgPT4ge1xuXHRcdFx0XHRcdC8vIGlmIGVuZCBoYXBwZW5lZCBiZWZvcmUgY2xvc2UgYnV0IHRoZSBzb2NrZXQgZGlkbid0IGVtaXQgYW4gZXJyb3IsIGRvIGl0IG5vd1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZSAmJiBlbmRlZFdpdGhFdmVudHNDb3VudCA8IHMuX2V2ZW50c0NvdW50ICYmICFoYWRFcnJvcikge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdFx0ZXJyb3IuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Xy5vbigncmVzcG9uc2UnLCByZXNwb25zZV8gPT4ge1xuXHRcdFx0cmVxdWVzdF8uc2V0VGltZW91dCgwKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBmcm9tUmF3SGVhZGVycyhyZXNwb25zZV8ucmF3SGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoaXNSZWRpcmVjdChyZXNwb25zZV8uc3RhdHVzQ29kZSkpIHtcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxuXHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcblx0XHRcdFx0bGV0IGxvY2F0aW9uVVJMID0gbnVsbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgaGVyZSBjYW4gb25seSBiZSBpbnZhbGlkIFVSTCBpbiBMb2NhdGlvbjogaGVhZGVyXG5cdFx0XHRcdFx0Ly8gZG8gbm90IHRocm93IHdoZW4gb3B0aW9ucy5yZWRpcmVjdCA9PSBtYW51YWxcblx0XHRcdFx0XHQvLyBsZXQgdGhlIHVzZXIgZXh0cmFjdCB0aGUgZXJyb3JuZW91cyByZWRpcmVjdCBVUkxcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsICdpbnZhbGlkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZvbGxvdyc6IHtcblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAyXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA1XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC5jb3VudGVyID49IHJlcXVlc3QuZm9sbG93KSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbWF4aW11bSByZWRpcmVjdCByZWFjaGVkIGF0OiAke3JlcXVlc3QudXJsfWAsICdtYXgtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDYgKGNvdW50ZXIgaW5jcmVtZW50KVxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IFJlcXVlc3Qgb2JqZWN0LlxuXHRcdFx0XHRcdFx0Y29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG5cdFx0XHRcdFx0XHRcdGZvbGxvdzogcmVxdWVzdC5mb2xsb3csXG5cdFx0XHRcdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlciArIDEsXG5cdFx0XHRcdFx0XHRcdGFnZW50OiByZXF1ZXN0LmFnZW50LFxuXHRcdFx0XHRcdFx0XHRjb21wcmVzczogcmVxdWVzdC5jb21wcmVzcyxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRcdFx0XHRcdFx0Ym9keTogY2xvbmUocmVxdWVzdCksXG5cdFx0XHRcdFx0XHRcdHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG5cdFx0XHRcdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0XHRcdFx0cmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG5cdFx0XHRcdFx0XHRcdHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIGZvcndhcmRpbmcgc2Vuc2l0aXZlIGhlYWRlcnMgbGlrZSBcIkF1dGhvcml6YXRpb25cIixcblx0XHRcdFx0XHRcdC8vIFwiV1dXLUF1dGhlbnRpY2F0ZVwiLCBhbmQgXCJDb29raWVcIiB0byB1bnRydXN0ZWQgdGFyZ2V0cyxcblx0XHRcdFx0XHRcdC8vIGhlYWRlcnMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW5cblx0XHRcdFx0XHRcdC8vIHRoYXQgaXMgbm90IGEgc3ViZG9tYWluIG1hdGNoIG9yIGV4YWN0IG1hdGNoIG9mIHRoZSBpbml0aWFsIGRvbWFpbi5cblx0XHRcdFx0XHRcdC8vIEZvciBleGFtcGxlLCBhIHJlZGlyZWN0IGZyb20gXCJmb28uY29tXCIgdG8gZWl0aGVyIFwiZm9vLmNvbVwiIG9yIFwic3ViLmZvby5jb21cIlxuXHRcdFx0XHRcdFx0Ly8gd2lsbCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVycywgYnV0IGEgcmVkaXJlY3QgdG8gXCJiYXIuY29tXCIgd2lsbCBub3QuXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXJzIHdpbGwgYWxzbyBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW4gdXNpbmdcblx0XHRcdFx0XHRcdC8vIGEgZGlmZmVyZW50IHByb3RvY29sLiBGb3IgZXhhbXBsZSwgYSByZWRpcmVjdCBmcm9tIFwiaHR0cHM6Ly9mb28uY29tXCIgdG8gXCJodHRwOi8vZm9vLmNvbVwiXG5cdFx0XHRcdFx0XHQvLyB3aWxsIG5vdCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVyc1xuXHRcdFx0XHRcdFx0aWYgKCFpc0RvbWFpbk9yU3ViZG9tYWluKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkgfHwgIWlzU2FtZVByb3RvY29sKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIFsnYXV0aG9yaXphdGlvbicsICd3d3ctYXV0aGVudGljYXRlJywgJ2Nvb2tpZScsICdjb29raWUyJ10pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLmRlbGV0ZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgOVxuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlXy5zdGF0dXNDb2RlICE9PSAzMDMgJiYgcmVxdWVzdC5ib2R5ICYmIG9wdGlvbnNfLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKCdDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbScsICd1bnN1cHBvcnRlZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8ICgocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNFxuXHRcdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2VSZWZlcnJlclBvbGljeSA9IHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGhlYWRlcnMpO1xuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPSByZXNwb25zZVJlZmVycmVyUG9saWN5O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTVcblx0XHRcdFx0XHRcdHJlc29sdmUoZmV0Y2gobmV3IFJlcXVlc3QobG9jYXRpb25VUkwsIHJlcXVlc3RPcHRpb25zKSkpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKGBSZWRpcmVjdCBvcHRpb24gJyR7cmVxdWVzdC5yZWRpcmVjdH0nIGlzIG5vdCBhIHZhbGlkIHZhbHVlIG9mIFJlcXVlc3RSZWRpcmVjdGApKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmVwYXJlIHJlc3BvbnNlXG5cdFx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYm9keSA9IHB1bXAocmVzcG9uc2VfLCBuZXcgUGFzc1Rocm91Z2goKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yOTM3NlxuXHRcdFx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRcdFx0aWYgKHByb2Nlc3MudmVyc2lvbiA8ICd2MTIuMTAnKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbignYWJvcnRlZCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXNwb25zZU9wdGlvbnMgPSB7XG5cdFx0XHRcdHVybDogcmVxdWVzdC51cmwsXG5cdFx0XHRcdHN0YXR1czogcmVzcG9uc2VfLnN0YXR1c0NvZGUsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlc3BvbnNlXy5zdGF0dXNNZXNzYWdlLFxuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlcixcblx0XHRcdFx0aGlnaFdhdGVyTWFyazogcmVxdWVzdC5oaWdoV2F0ZXJNYXJrXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuM1xuXHRcdFx0Y29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUVuY29kaW5nJyk7XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS40OiBoYW5kbGUgY29udGVudCBjb2RpbmdzXG5cblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcblx0XHRcdC8vIDEuIGNvbXByZXNzaW9uIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0XHRcdC8vIDIuIEhFQUQgcmVxdWVzdFxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcblx0XHRcdC8vIDQuIG5vIGNvbnRlbnQgcmVzcG9uc2UgKDIwNClcblx0XHRcdC8vIDUuIGNvbnRlbnQgbm90IG1vZGlmaWVkIHJlc3BvbnNlICgzMDQpXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgTm9kZSB2Nitcblx0XHRcdC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuXHRcdFx0Ly8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG5cdFx0XHQvLyBieSBjb21tb24gYnJvd3NlcnMuXG5cdFx0XHQvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuXHRcdFx0Y29uc3QgemxpYk9wdGlvbnMgPSB7XG5cdFx0XHRcdGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcblx0XHRcdFx0ZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGb3IgZ3ppcFxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdnemlwJyB8fCBjb2RpbmdzID09PSAneC1nemlwJykge1xuXHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucyksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGRlZmxhdGVcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gcHVtcChyZXNwb25zZV8sIG5ldyBQYXNzVGhyb3VnaCgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3NTE5ODI4XG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUluZmxhdGUoKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym9keSA9IHB1bXAoYm9keSwgemxpYi5jcmVhdGVJbmZsYXRlUmF3KCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gU29tZSBvbGQgSUlTIHNlcnZlcnMgcmV0dXJuIHplcm8tbGVuZ3RoIE9LIGRlZmxhdGUgcmVzcG9uc2VzLCBzb1xuXHRcdFx0XHRcdC8vICdkYXRhJyBpcyBuZXZlciBlbWl0dGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9wdWxsLzkwM1xuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBiclxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdicicpIHtcblx0XHRcdFx0Ym9keSA9IHB1bXAoYm9keSwgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHR9KTtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCkuY2F0Y2gocmVqZWN0KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IEJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHRsZXQgcHJldmlvdXNDaHVuaztcblxuXHRyZXF1ZXN0Lm9uKCdyZXNwb25zZScsIHJlc3BvbnNlID0+IHtcblx0XHRjb25zdCB7aGVhZGVyc30gPSByZXNwb25zZTtcblx0XHRpc0NodW5rZWRUcmFuc2ZlciA9IGhlYWRlcnNbJ3RyYW5zZmVyLWVuY29kaW5nJ10gPT09ICdjaHVua2VkJyAmJiAhaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblx0fSk7XG5cblx0cmVxdWVzdC5vbignc29ja2V0Jywgc29ja2V0ID0+IHtcblx0XHRjb25zdCBvblNvY2tldENsb3NlID0gKCkgPT4ge1xuXHRcdFx0aWYgKGlzQ2h1bmtlZFRyYW5zZmVyICYmICFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25EYXRhID0gYnVmID0+IHtcblx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gQnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC01KSwgTEFTVF9DSFVOSykgPT09IDA7XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBmaW5hbCAwLWxlbmd0aCBjaHVuayBhbmQgZW5kIG9mIG1lc3NhZ2UgY29kZSBhcmUgaW4gc2VwYXJhdGUgcGFja2V0c1xuXHRcdFx0aWYgKCFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCAmJiBwcmV2aW91c0NodW5rKSB7XG5cdFx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gKFxuXHRcdFx0XHRcdEJ1ZmZlci5jb21wYXJlKHByZXZpb3VzQ2h1bmsuc2xpY2UoLTMpLCBMQVNUX0NIVU5LLnNsaWNlKDAsIDMpKSA9PT0gMCAmJlxuXHRcdFx0XHRcdEJ1ZmZlci5jb21wYXJlKGJ1Zi5zbGljZSgtMiksIExBU1RfQ0hVTksuc2xpY2UoMykpID09PSAwXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZpb3VzQ2h1bmsgPSBidWY7XG5cdFx0fTtcblxuXHRcdHNvY2tldC5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0c29ja2V0Lm9uKCdkYXRhJywgb25EYXRhKTtcblxuXHRcdHJlcXVlc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9KTtcblx0fSk7XG59XG4iLCIvKipcbiAqIFJlcXVlc3QuanNcbiAqXG4gKiBSZXF1ZXN0IGNsYXNzIGNvbnRhaW5zIHNlcnZlciBvbmx5IG9wdGlvbnNcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmltcG9ydCB7Zm9ybWF0IGFzIGZvcm1hdFVybH0gZnJvbSAnbm9kZTp1cmwnO1xuaW1wb3J0IHtkZXByZWNhdGV9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgSGVhZGVycyBmcm9tICcuL2hlYWRlcnMuanMnO1xuaW1wb3J0IEJvZHksIHtjbG9uZSwgZXh0cmFjdENvbnRlbnRUeXBlLCBnZXRUb3RhbEJ5dGVzfSBmcm9tICcuL2JvZHkuanMnO1xuaW1wb3J0IHtpc0Fib3J0U2lnbmFsfSBmcm9tICcuL3V0aWxzL2lzLmpzJztcbmltcG9ydCB7Z2V0U2VhcmNofSBmcm9tICcuL3V0aWxzL2dldC1zZWFyY2guanMnO1xuaW1wb3J0IHtcblx0dmFsaWRhdGVSZWZlcnJlclBvbGljeSwgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciwgREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1lcbn0gZnJvbSAnLi91dGlscy9yZWZlcnJlci5qcyc7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAgeyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZXF1ZXN0ID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3RbSU5URVJOQUxTXSA9PT0gJ29iamVjdCdcblx0KTtcbn07XG5cbmNvbnN0IGRvQmFkRGF0YVdhcm4gPSBkZXByZWNhdGUoKCkgPT4ge30sXG5cdCcuZGF0YSBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0SW5pdCBwcm9wZXJ0eSwgdXNlIC5ib2R5IGluc3RlYWQnLFxuXHQnaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTAwMCAocmVxdWVzdCknKTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNsYXNzXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXQgIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgIGluaXQgICBDdXN0b20gb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXF1ZXN0IGV4dGVuZHMgQm9keSB7XG5cdGNvbnN0cnVjdG9yKGlucHV0LCBpbml0ID0ge30pIHtcblx0XHRsZXQgcGFyc2VkVVJMO1xuXG5cdFx0Ly8gTm9ybWFsaXplIGlucHV0IGFuZCBmb3JjZSBVUkwgdG8gYmUgZW5jb2RlZCBhcyBVVEYtOCAoaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMjQ1KVxuXHRcdGlmIChpc1JlcXVlc3QoaW5wdXQpKSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LnVybCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQpO1xuXHRcdFx0aW5wdXQgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAocGFyc2VkVVJMLnVzZXJuYW1lICE9PSAnJyB8fCBwYXJzZWRVUkwucGFzc3dvcmQgIT09ICcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BhcnNlZFVSTH0gaXMgYW4gdXJsIHdpdGggZW1iZWRkZWQgY3JlZGVudGlhbHMuYCk7XG5cdFx0fVxuXG5cdFx0bGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCAnR0VUJztcblx0XHRpZiAoL14oZGVsZXRlfGdldHxoZWFkfG9wdGlvbnN8cG9zdHxwdXQpJC9pLnRlc3QobWV0aG9kKSkge1xuXHRcdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1JlcXVlc3QoaW5pdCkgJiYgJ2RhdGEnIGluIGluaXQpIHtcblx0XHRcdGRvQmFkRGF0YVdhcm4oKTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0aWYgKChpbml0LmJvZHkgIT0gbnVsbCB8fCAoaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsKSkgJiZcblx0XHRcdChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5Jyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5wdXRCb2R5ID0gaW5pdC5ib2R5ID9cblx0XHRcdGluaXQuYm9keSA6XG5cdFx0XHQoaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsID9cblx0XHRcdFx0Y2xvbmUoaW5wdXQpIDpcblx0XHRcdFx0bnVsbCk7XG5cblx0XHRzdXBlcihpbnB1dEJvZHksIHtcblx0XHRcdHNpemU6IGluaXQuc2l6ZSB8fCBpbnB1dC5zaXplIHx8IDBcblx0XHR9KTtcblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMgfHwgaW5wdXQuaGVhZGVycyB8fCB7fSk7XG5cblx0XHRpZiAoaW5wdXRCb2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGlucHV0Qm9keSwgdGhpcyk7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgc2lnbmFsID0gaXNSZXF1ZXN0KGlucHV0KSA/XG5cdFx0XHRpbnB1dC5zaWduYWwgOlxuXHRcdFx0bnVsbDtcblx0XHRpZiAoJ3NpZ25hbCcgaW4gaW5pdCkge1xuXHRcdFx0c2lnbmFsID0gaW5pdC5zaWduYWw7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmIChzaWduYWwgIT0gbnVsbCAmJiAhaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCBvciBFdmVudFRhcmdldCcpO1xuXHRcdH1cblxuXHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjFcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0bGV0IHJlZmVycmVyID0gaW5pdC5yZWZlcnJlciA9PSBudWxsID8gaW5wdXQucmVmZXJyZXIgOiBpbml0LnJlZmVycmVyO1xuXHRcdGlmIChyZWZlcnJlciA9PT0gJycpIHtcblx0XHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjJcblx0XHRcdHJlZmVycmVyID0gJ25vLXJlZmVycmVyJztcblx0XHR9IGVsc2UgaWYgKHJlZmVycmVyKSB7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4zLjEsIDE1LjMuMlxuXHRcdFx0Y29uc3QgcGFyc2VkUmVmZXJyZXIgPSBuZXcgVVJMKHJlZmVycmVyKTtcblx0XHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjMuMywgMTUuMy40XG5cdFx0XHRyZWZlcnJlciA9IC9eYWJvdXQ6KFxcL1xcLyk/Y2xpZW50JC8udGVzdChwYXJzZWRSZWZlcnJlcikgPyAnY2xpZW50JyA6IHBhcnNlZFJlZmVycmVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWZlcnJlciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHRyZWRpcmVjdDogaW5pdC5yZWRpcmVjdCB8fCBpbnB1dC5yZWRpcmVjdCB8fCAnZm9sbG93Jyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRwYXJzZWRVUkwsXG5cdFx0XHRzaWduYWwsXG5cdFx0XHRyZWZlcnJlclxuXHRcdH07XG5cblx0XHQvLyBOb2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IDIwIDogaW5wdXQuZm9sbG93KSA6IGluaXQuZm9sbG93O1xuXHRcdHRoaXMuY29tcHJlc3MgPSBpbml0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyAoaW5wdXQuY29tcHJlc3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnB1dC5jb21wcmVzcykgOiBpbml0LmNvbXByZXNzO1xuXHRcdHRoaXMuY291bnRlciA9IGluaXQuY291bnRlciB8fCBpbnB1dC5jb3VudGVyIHx8IDA7XG5cdFx0dGhpcy5hZ2VudCA9IGluaXQuYWdlbnQgfHwgaW5wdXQuYWdlbnQ7XG5cdFx0dGhpcy5oaWdoV2F0ZXJNYXJrID0gaW5pdC5oaWdoV2F0ZXJNYXJrIHx8IGlucHV0LmhpZ2hXYXRlck1hcmsgfHwgMTYzODQ7XG5cdFx0dGhpcy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBpbml0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBpbnB1dC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgZmFsc2U7XG5cblx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNi5cblx0XHQvLyBEZWZhdWx0IGlzIGVtcHR5IHN0cmluZyBwZXIgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1yZWZlcnJlci1wb2xpY3lcblx0XHR0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBpbnB1dC5yZWZlcnJlclBvbGljeSB8fCAnJztcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXHRnZXQgbWV0aG9kKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ubWV0aG9kO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIGZvcm1hdFVybCh0aGlzW0lOVEVSTkFMU10ucGFyc2VkVVJMKTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7SGVhZGVyc30gKi9cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ucmVkaXJlY3Q7XG5cdH1cblxuXHQvKiogQHJldHVybnMge0Fib3J0U2lnbmFsfSAqL1xuXHRnZXQgc2lnbmFsKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc2lnbmFsO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0LXJlZmVycmVyXG5cdGdldCByZWZlcnJlcigpIHtcblx0XHRpZiAodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyID09PSAnbm8tcmVmZXJyZXInKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcblx0XHRcdHJldHVybiAnYWJvdXQ6Y2xpZW50Jztcblx0XHR9XG5cblx0XHRpZiAodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdGdldCByZWZlcnJlclBvbGljeSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyUG9saWN5O1xuXHR9XG5cblx0c2V0IHJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG5cdFx0dGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyUG9saWN5ID0gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhpcyByZXF1ZXN0XG5cdCAqXG5cdCAqIEByZXR1cm4gIFJlcXVlc3Rcblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1JlcXVlc3QnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG5cdG1ldGhvZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9LFxuXHRzaWduYWw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVmZXJyZXI6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVmZXJyZXJQb2xpY3k6IHtlbnVtZXJhYmxlOiB0cnVlfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIFJlcXVlc3QgdG8gTm9kZS5qcyBodHRwIHJlcXVlc3Qgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3QgLSBBIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4gVGhlIG9wdGlvbnMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBodHRwLnJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3QgPT4ge1xuXHRjb25zdCB7cGFyc2VkVVJMfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTXS5oZWFkZXJzKTtcblxuXHQvLyBGZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PT0gbnVsbCAmJiAvXihwb3N0fHB1dCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5ib2R5ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0Ly8gU2V0IENvbnRlbnQtTGVuZ3RoIGlmIHRvdGFsQnl0ZXMgaXMgYSBudW1iZXIgKHRoYXQgaXMgbm90IE5hTilcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4odG90YWxCeXRlcykpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjZcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgdG8gdGhlXG5cdC8vID4gZGVmYXVsdCByZWZlcnJlciBwb2xpY3kuXG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBERUZBVUxUX1JFRkVSUkVSX1BPTElDWTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjdcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgc2V0IHJlcXVlc3QncyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nXG5cdC8vID4gZGV0ZXJtaW5lIHJlcXVlc3QncyByZWZlcnJlci5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgJiYgcmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuXHRcdHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdCk7XG5cdH0gZWxzZSB7XG5cdFx0cmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyID0gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIDQuNS4gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoLCBzdGVwIDYuOVxuXHQvLyA+IElmIGh0dHBSZXF1ZXN0J3MgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kIGBSZWZlcmVyYC9odHRwUmVxdWVzdCdzIHJlZmVycmVyLCBzZXJpYWxpemVkXG5cdC8vID4gIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGh0dHBSZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG5cdGlmIChyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcblx0XHRoZWFkZXJzLnNldCgnUmVmZXJlcicsIHJlcXVlc3QucmVmZXJyZXIpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xMVxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcblx0XHRoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdub2RlLWZldGNoJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjE1XG5cdGlmIChyZXF1ZXN0LmNvbXByZXNzICYmICFoZWFkZXJzLmhhcygnQWNjZXB0LUVuY29kaW5nJykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUsIGJyJyk7XG5cdH1cblxuXHRsZXQge2FnZW50fSA9IHJlcXVlc3Q7XG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCA0LjJcblx0Ly8gY2h1bmtlZCBlbmNvZGluZyBpcyBoYW5kbGVkIGJ5IE5vZGUuanNcblxuXHRjb25zdCBzZWFyY2ggPSBnZXRTZWFyY2gocGFyc2VkVVJMKTtcblxuXHQvLyBQYXNzIHRoZSBmdWxsIFVSTCBkaXJlY3RseSB0byByZXF1ZXN0KCksIGJ1dCBvdmVyd3JpdGUgdGhlIGZvbGxvd2luZ1xuXHQvLyBvcHRpb25zOlxuXHRjb25zdCBvcHRpb25zID0ge1xuXHRcdC8vIE92ZXJ3cml0ZSBzZWFyY2ggdG8gcmV0YWluIHRyYWlsaW5nID8gKGlzc3VlICM3NzYpXG5cdFx0cGF0aDogcGFyc2VkVVJMLnBhdGhuYW1lICsgc2VhcmNoLFxuXHRcdC8vIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgbm90IGV4cHJlc3NlZCBpbiB0aGUgVVJMXG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRoZWFkZXJzOiBoZWFkZXJzW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCksXG5cdFx0aW5zZWN1cmVIVFRQUGFyc2VyOiByZXF1ZXN0Lmluc2VjdXJlSFRUUFBhcnNlcixcblx0XHRhZ2VudFxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0LyoqIEB0eXBlIHtVUkx9ICovXG5cdFx0cGFyc2VkVVJMLFxuXHRcdG9wdGlvbnNcblx0fTtcbn07XG4iLCIvKipcbiAqIFJlc3BvbnNlLmpzXG4gKlxuICogUmVzcG9uc2UgY2xhc3MgcHJvdmlkZXMgY29udGVudCBkZWNvZGluZ1xuICovXG5cbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGV9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzUmVkaXJlY3R9IGZyb20gJy4vdXRpbHMvaXMtcmVkaXJlY3QuanMnO1xuXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ1Jlc3BvbnNlIGludGVybmFscycpO1xuXG4vKipcbiAqIFJlc3BvbnNlIGNsYXNzXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2UtY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBTdHJlYW0gIGJvZHkgIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICAgT2JqZWN0ICBvcHRzICBSZXNwb25zZSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3BvbnNlIGV4dGVuZHMgQm9keSB7XG5cdGNvbnN0cnVjdG9yKGJvZHkgPSBudWxsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihib2R5LCBvcHRpb25zKTtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXEsIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cdFx0Y29uc3Qgc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgIT0gbnVsbCA/IG9wdGlvbnMuc3RhdHVzIDogMjAwO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZiAoYm9keSAhPT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShib2R5LCB0aGlzKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdHR5cGU6ICdkZWZhdWx0Jyxcblx0XHRcdHVybDogb3B0aW9ucy51cmwsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgfHwgJycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y291bnRlcjogb3B0aW9ucy5jb3VudGVyLFxuXHRcdFx0aGlnaFdhdGVyTWFyazogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrXG5cdFx0fTtcblx0fVxuXG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10udHlwZTtcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmwgfHwgJyc7XG5cdH1cblxuXHRnZXQgc3RhdHVzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIHByb3BlcnR5IHJlcHJlc2VudGluZyBpZiB0aGUgcmVxdWVzdCBlbmRlZCBub3JtYWxseVxuXHQgKi9cblx0Z2V0IG9rKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzIDwgMzAwO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5jb3VudGVyID4gMDtcblx0fVxuXG5cdGdldCBzdGF0dXNUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGlnaFdhdGVyTWFyaztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlc3BvbnNlXG5cdCAqXG5cdCAqIEByZXR1cm4gIFJlc3BvbnNlXG5cdCAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGNsb25lKHRoaXMsIHRoaXMuaGlnaFdhdGVyTWFyayksIHtcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0b2s6IHRoaXMub2ssXG5cdFx0XHRyZWRpcmVjdGVkOiB0aGlzLnJlZGlyZWN0ZWQsXG5cdFx0XHRzaXplOiB0aGlzLnNpemUsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiB0aGlzLmhpZ2hXYXRlck1hcmtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgIFRoZSBVUkwgdGhhdCB0aGUgbmV3IHJlc3BvbnNlIGlzIHRvIG9yaWdpbmF0ZSBmcm9tLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIEFuIG9wdGlvbmFsIHN0YXR1cyBjb2RlIGZvciB0aGUgcmVzcG9uc2UgKGUuZy4sIDMwMi4pXG5cdCAqIEByZXR1cm5zIHtSZXNwb25zZX0gICAgQSBSZXNwb25zZSBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgcmVkaXJlY3QodXJsLCBzdGF0dXMgPSAzMDIpIHtcblx0XHRpZiAoIWlzUmVkaXJlY3Qoc3RhdHVzKSkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcblx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0bG9jYXRpb246IG5ldyBVUkwodXJsKS50b1N0cmluZygpXG5cdFx0XHR9LFxuXHRcdFx0c3RhdHVzXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgZXJyb3IoKSB7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcblx0XHRyZXNwb25zZVtJTlRFUk5BTFNdLnR5cGUgPSAnZXJyb3InO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdHN0YXRpYyBqc29uKGRhdGEgPSB1bmRlZmluZWQsIGluaXQgPSB7fSkge1xuXHRcdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblxuXHRcdGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgJiYgaW5pdC5oZWFkZXJzKTtcblxuXHRcdGlmICghaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpKSB7XG5cdFx0XHRoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcblx0XHRcdC4uLmluaXQsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXNwb25zZSc7XG5cdH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHR5cGU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1czoge2VudW1lcmFibGU6IHRydWV9LFxuXHRvazoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdGVkOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1c1RleHQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9XG59KTtcbiIsImV4cG9ydCBjb25zdCBnZXRTZWFyY2ggPSBwYXJzZWRVUkwgPT4ge1xuXHRpZiAocGFyc2VkVVJMLnNlYXJjaCkge1xuXHRcdHJldHVybiBwYXJzZWRVUkwuc2VhcmNoO1xuXHR9XG5cblx0Y29uc3QgbGFzdE9mZnNldCA9IHBhcnNlZFVSTC5ocmVmLmxlbmd0aCAtIDE7XG5cdGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09ICcjJyA/ICcjJyA6ICcnKTtcblx0cmV0dXJuIHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXQgLSBoYXNoLmxlbmd0aF0gPT09ICc/JyA/ICc/JyA6ICcnO1xufTtcbiIsImNvbnN0IHJlZGlyZWN0U3RhdHVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcblxuLyoqXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBTdGF0dXMgY29kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUmVkaXJlY3QgPSBjb2RlID0+IHtcblx0cmV0dXJuIHJlZGlyZWN0U3RhdHVzLmhhcyhjb2RlKTtcbn07XG4iLCIvKipcbiAqIElzLmpzXG4gKlxuICogT2JqZWN0IHR5cGUgY2hlY2tzLlxuICovXG5cbmNvbnN0IE5BTUUgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKiByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzI5NiNpc3N1ZWNvbW1lbnQtMzA3NTk4MTQzXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1VSTFNlYXJjaFBhcmFtZXRlcnMgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zb3J0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0b2JqZWN0W05BTUVdID09PSAnVVJMU2VhcmNoUGFyYW1zJ1xuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqZWN0YCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmxvYiA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0b2JqZWN0ICYmXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC50eXBlID09PSAnc3RyaW5nJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtOQU1FXSlcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0Fib3J0U2lnbmFsID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiAoXG5cdFx0XHRvYmplY3RbTkFNRV0gPT09ICdBYm9ydFNpZ25hbCcgfHxcblx0XHRcdG9iamVjdFtOQU1FXSA9PT0gJ0V2ZW50VGFyZ2V0J1xuXHRcdClcblx0KTtcbn07XG5cbi8qKlxuICogaXNEb21haW5PclN1YmRvbWFpbiByZXBvcnRzIHdoZXRoZXIgc3ViIGlzIGEgc3ViZG9tYWluIChvciBleGFjdCBtYXRjaCkgb2ZcbiAqIHRoZSBwYXJlbnQgZG9tYWluLlxuICpcbiAqIEJvdGggZG9tYWlucyBtdXN0IGFscmVhZHkgYmUgaW4gY2Fub25pY2FsIGZvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IG9yaWdpbmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IGRlc3RpbmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RvbWFpbk9yU3ViZG9tYWluID0gKGRlc3RpbmF0aW9uLCBvcmlnaW5hbCkgPT4ge1xuXHRjb25zdCBvcmlnID0gbmV3IFVSTChvcmlnaW5hbCkuaG9zdG5hbWU7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnLmVuZHNXaXRoKGAuJHtkZXN0fWApO1xufTtcblxuLyoqXG4gKiBpc1NhbWVQcm90b2NvbCByZXBvcnRzIHdoZXRoZXIgdGhlIHR3byBwcm92aWRlZCBVUkxzIHVzZSB0aGUgc2FtZSBwcm90b2NvbC5cbiAqXG4gKiBCb3RoIGRvbWFpbnMgbXVzdCBhbHJlYWR5IGJlIGluIGNhbm9uaWNhbCBmb3JtLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBvcmlnaW5hbFxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBkZXN0aW5hdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNTYW1lUHJvdG9jb2wgPSAoZGVzdGluYXRpb24sIG9yaWdpbmFsKSA9PiB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5wcm90b2NvbDtcblx0Y29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcbiIsImltcG9ydCB7aXNJUH0gZnJvbSAnbm9kZTpuZXQnO1xuXG4vKipcbiAqIEBleHRlcm5hbCBVUkxcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkx8VVJMfVxuICovXG5cbi8qKlxuICogQG1vZHVsZSB1dGlscy9yZWZlcnJlclxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmx8UmVmZXJyZXIgUG9saWN5IMKnOC40LiBTdHJpcCB1cmwgZm9yIHVzZSBhcyBhIHJlZmVycmVyfVxuICogQHBhcmFtIHtzdHJpbmd9IFVSTFxuICogQHBhcmFtIHtib29sZWFufSBbb3JpZ2luT25seT1mYWxzZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIodXJsLCBvcmlnaW5Pbmx5ID0gZmFsc2UpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIG51bGwsIHJldHVybiBubyByZWZlcnJlci5cblx0aWYgKHVybCA9PSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHR1cmwgPSBuZXcgVVJMKHVybCk7XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0aWYgKC9eKGFib3V0fGJsb2J8ZGF0YSk6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHQvLyAzLiBTZXQgdXJsJ3MgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cblx0dXJsLnVzZXJuYW1lID0gJyc7XG5cblx0Ly8gNC4gU2V0IHVybCdzIHBhc3N3b3JkIHRvIG51bGwuXG5cdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHBhc3N3b3JkIGJlaW5nIGBcIm51bGxcImAuXG5cdHVybC5wYXNzd29yZCA9ICcnO1xuXG5cdC8vIDUuIFNldCB1cmwncyBmcmFnbWVudCB0byBudWxsLlxuXHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBmcmFnbWVudCBiZWluZyBgXCIjbnVsbFwiYC5cblx0dXJsLmhhc2ggPSAnJztcblxuXHQvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuXHRpZiAob3JpZ2luT25seSkge1xuXHRcdC8vIDYuMS4gU2V0IHVybCdzIHBhdGggdG8gbnVsbC5cblx0XHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBwYXRoIGJlaW5nIGBcIi9udWxsXCJgLlxuXHRcdHVybC5wYXRobmFtZSA9ICcnO1xuXG5cdFx0Ly8gNi4yLiBTZXQgdXJsJ3MgcXVlcnkgdG8gbnVsbC5cblx0XHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBxdWVyeSBiZWluZyBgXCI/bnVsbFwiYC5cblx0XHR1cmwuc2VhcmNoID0gJyc7XG5cdH1cblxuXHQvLyA3LiBSZXR1cm4gdXJsLlxuXHRyZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNlbnVtZGVmLXJlZmVycmVycG9saWN5fGVudW0gUmVmZXJyZXJQb2xpY3l9XG4gKi9cbmV4cG9ydCBjb25zdCBSZWZlcnJlclBvbGljeSA9IG5ldyBTZXQoW1xuXHQnJyxcblx0J25vLXJlZmVycmVyJyxcblx0J25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcblx0J3NhbWUtb3JpZ2luJyxcblx0J29yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luJyxcblx0J29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3Vuc2FmZS11cmwnXG5dKTtcblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGVmYXVsdC1yZWZlcnJlci1wb2xpY3l8ZGVmYXVsdCByZWZlcnJlciBwb2xpY3l9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFRkVSUkVSX1BPTElDWSA9ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJztcblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXN8UmVmZXJyZXIgUG9saWN5IMKnMy4gUmVmZXJyZXIgUG9saWNpZXN9XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmZXJyZXJQb2xpY3lcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJlZmVycmVyUG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG5cdGlmICghUmVmZXJyZXJQb2xpY3kuaGFzKHJlZmVycmVyUG9saWN5KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cmVmZXJyZXJQb2xpY3l9YCk7XG5cdH1cblxuXHRyZXR1cm4gcmVmZXJyZXJQb2xpY3k7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zZWN1cmUtY29udGV4dHMvI2lzLW9yaWdpbi10cnVzdHdvcnRoeXxSZWZlcnJlciBQb2xpY3kgwqczLjIuIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT99XG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gdXJsXG4gKiBAcmV0dXJucyBgdHJ1ZWA6IFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIiwgYGZhbHNlYDogXCJOb3QgVHJ1c3R3b3J0aHlcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCkge1xuXHQvLyAxLiBJZiBvcmlnaW4gaXMgYW4gb3BhcXVlIG9yaWdpbiwgcmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBhcHBsaWNhYmxlXG5cblx0Ly8gMi4gQXNzZXJ0OiBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4uXG5cdC8vIE5vdCBmb3IgaW1wbGVtZW50YXRpb25zXG5cblx0Ly8gMy4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGlzIGVpdGhlciBcImh0dHBzXCIgb3IgXCJ3c3NcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKC9eKGh0dHB8d3MpczokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDQuIElmIG9yaWdpbidzIGhvc3QgY29tcG9uZW50IG1hdGNoZXMgb25lIG9mIHRoZSBDSURSIG5vdGF0aW9ucyAxMjcuMC4wLjAvOCBvciA6OjEvMTI4IFtSRkM0NjMyXSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Y29uc3QgaG9zdElwID0gdXJsLmhvc3QucmVwbGFjZSgvKF5cXFspfChdJCkvZywgJycpO1xuXHRjb25zdCBob3N0SVBWZXJzaW9uID0gaXNJUChob3N0SXApO1xuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA0ICYmIC9eMTI3XFwuLy50ZXN0KGhvc3RJcCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA2ICYmIC9eKCgoMCs6KXs3fSl8KDo6KDArOil7MCw2fSkpMCoxJC8udGVzdChob3N0SXApKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA1LiBJZiBvcmlnaW4ncyBob3N0IGNvbXBvbmVudCBpcyBcImxvY2FsaG9zdFwiIG9yIGZhbGxzIHdpdGhpbiBcIi5sb2NhbGhvc3RcIiwgYW5kIHRoZSB1c2VyIGFnZW50IGNvbmZvcm1zIHRvIHRoZSBuYW1lIHJlc29sdXRpb24gcnVsZXMgaW4gW2xldC1sb2NhbGhvc3QtYmUtbG9jYWxob3N0XSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gV2UgYXJlIHJldHVybmluZyBGQUxTRSBoZXJlIGJlY2F1c2Ugd2UgY2Fubm90IGVuc3VyZSBjb25mb3JtYW5jZSB0b1xuXHQvLyBsZXQtbG9jYWxob3N0LWJlLWxvYWxob3N0IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtd2VzdC1sZXQtbG9jYWxob3N0LWJlLWxvY2FsaG9zdClcblx0aWYgKHVybC5ob3N0ID09PSAnbG9jYWxob3N0JyB8fCB1cmwuaG9zdC5lbmRzV2l0aCgnLmxvY2FsaG9zdCcpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gNi4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGNvbXBvbmVudCBpcyBmaWxlLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZmlsZTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA3LiBJZiBvcmlnaW4ncyBzY2hlbWUgY29tcG9uZW50IGlzIG9uZSB3aGljaCB0aGUgdXNlciBhZ2VudCBjb25zaWRlcnMgdG8gYmUgYXV0aGVudGljYXRlZCwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IHN1cHBvcnRlZFxuXG5cdC8vIDguIElmIG9yaWdpbiBoYXMgYmVlbiBjb25maWd1cmVkIGFzIGEgdHJ1c3R3b3J0aHkgb3JpZ2luLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3Qgc3VwcG9ydGVkXG5cblx0Ly8gOS4gUmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXNlY3VyZS1jb250ZXh0cy8jaXMtdXJsLXRydXN0d29ydGh5fFJlZmVycmVyIFBvbGljeSDCpzMuMy4gSXMgdXJsIHBvdGVudGlhbGx5IHRydXN0d29ydGh5P31cbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSB1cmxcbiAqIEByZXR1cm5zIGB0cnVlYDogXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLCBgZmFsc2VgOiBcIk5vdCBUcnVzdHdvcnRoeVwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsKSB7XG5cdC8vIDEuIElmIHVybCBpcyBcImFib3V0OmJsYW5rXCIgb3IgXCJhYm91dDpzcmNkb2NcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKC9eYWJvdXQ6KGJsYW5rfHNyY2RvYykkLy50ZXN0KHVybCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDIuIElmIHVybCdzIHNjaGVtZSBpcyBcImRhdGFcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKHVybC5wcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gTm90ZTogVGhlIG9yaWdpbiBvZiBibG9iOiBhbmQgZmlsZXN5c3RlbTogVVJMcyBpcyB0aGUgb3JpZ2luIG9mIHRoZSBjb250ZXh0IGluIHdoaWNoIHRoZXkgd2VyZVxuXHQvLyBjcmVhdGVkLiBUaGVyZWZvcmUsIGJsb2JzIGNyZWF0ZWQgaW4gYSB0cnVzdHdvcnRoeSBvcmlnaW4gd2lsbCB0aGVtc2VsdmVzIGJlIHBvdGVudGlhbGx5XG5cdC8vIHRydXN0d29ydGh5LlxuXHRpZiAoL14oYmxvYnxmaWxlc3lzdGVtKTokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyDCpzMuMiBJcyBvcmlnaW4gcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/IG9uIHVybCdzIG9yaWdpbi5cblx0cmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSByZWZlcnJlclVSTCB0byBlbmZvcmNlIGFueSBleHRyYSBzZWN1cml0eSBwb2xpY3kgY29uc2lkZXJhdGlvbnMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn0sIHN0ZXAgN1xuICogQGNhbGxiYWNrIG1vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlclVSTENhbGxiYWNrXG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gcmVmZXJyZXJVUkxcbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IG1vZGlmaWVkIHJlZmVycmVyVVJMXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcmVmZXJyZXJPcmlnaW4gdG8gZW5mb3JjZSBhbnkgZXh0cmEgc2VjdXJpdHkgcG9saWN5IGNvbnNpZGVyYXRpb25zLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlcnxSZWZlcnJlciBQb2xpY3kgwqc4LjMuIERldGVybWluZSByZXF1ZXN0J3MgUmVmZXJyZXJ9LCBzdGVwIDdcbiAqIEBjYWxsYmFjayBtb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJPcmlnaW5DYWxsYmFja1xuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHJlZmVycmVyT3JpZ2luXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBtb2RpZmllZCByZWZlcnJlck9yaWdpblxuICovXG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlcnxSZWZlcnJlciBQb2xpY3kgwqc4LjMuIERldGVybWluZSByZXF1ZXN0J3MgUmVmZXJyZXJ9XG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0ge21vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlclVSTENhbGxiYWNrfSBvLnJlZmVycmVyVVJMQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyT3JpZ2luQ2FsbGJhY2t9IG8ucmVmZXJyZXJPcmlnaW5DYWxsYmFja1xuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gUmVxdWVzdCdzIHJlZmVycmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QsIHtyZWZlcnJlclVSTENhbGxiYWNrLCByZWZlcnJlck9yaWdpbkNhbGxiYWNrfSA9IHt9KSB7XG5cdC8vIFRoZXJlIGFyZSAyIG5vdGVzIGluIHRoZSBzcGVjaWZpY2F0aW9uIGFib3V0IGludmFsaWQgcHJlLWNvbmRpdGlvbnMuICBXZSByZXR1cm4gbnVsbCwgaGVyZSwgZm9yXG5cdC8vIHRoZXNlIGNhc2VzOlxuXHQvLyA+IE5vdGU6IElmIHJlcXVlc3QncyByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzIGFsZ29yaXRobS5cblx0Ly8gPiBOb3RlOiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzXG5cdC8vID4gYWxnb3JpdGhtLlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJyB8fCByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gMS4gTGV0IHBvbGljeSBiZSByZXF1ZXN0J3MgYXNzb2NpYXRlZCByZWZlcnJlciBwb2xpY3kuXG5cdGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3k7XG5cblx0Ly8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3QncyBjbGllbnQuXG5cdC8vIG5vdCBhcHBsaWNhYmxlIHRvIG5vZGUuanNcblxuXHQvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdCdzIHJlZmVycmVyOlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2Fib3V0OmNsaWVudCcpIHtcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIFwiYSBVUkxcIjogTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3QncyByZWZlcnJlci5cblx0Y29uc3QgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyO1xuXG5cdC8vIDQuIExldCByZXF1ZXN0J3MgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLlxuXHRsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlKTtcblxuXHQvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLCB3aXRoIHRoZVxuXHQvLyAgICBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuXHRsZXQgcmVmZXJyZXJPcmlnaW4gPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlLCB0cnVlKTtcblxuXHQvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gNDA5Niwgc2V0XG5cdC8vICAgIHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuXHRpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpbjtcblx0fVxuXG5cdC8vIDcuIFRoZSB1c2VyIGFnZW50IE1BWSBhbHRlciByZWZlcnJlclVSTCBvciByZWZlcnJlck9yaWdpbiBhdCB0aGlzIHBvaW50IHRvIGVuZm9yY2UgYXJiaXRyYXJ5XG5cdC8vICAgIHBvbGljeSBjb25zaWRlcmF0aW9ucyBpbiB0aGUgaW50ZXJlc3RzIG9mIG1pbmltaXppbmcgZGF0YSBsZWFrYWdlLiBGb3IgZXhhbXBsZSwgdGhlIHVzZXJcblx0Ly8gICAgYWdlbnQgY291bGQgc3RyaXAgdGhlIFVSTCBkb3duIHRvIGFuIG9yaWdpbiwgbW9kaWZ5IGl0cyBob3N0LCByZXBsYWNlIGl0IHdpdGggYW4gZW1wdHlcblx0Ly8gICAgc3RyaW5nLCBldGMuXG5cdGlmIChyZWZlcnJlclVSTENhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlclVSTENhbGxiYWNrKHJlZmVycmVyVVJMKTtcblx0fVxuXG5cdGlmIChyZWZlcnJlck9yaWdpbkNhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJPcmlnaW4gPSByZWZlcnJlck9yaWdpbkNhbGxiYWNrKHJlZmVycmVyT3JpZ2luKTtcblx0fVxuXG5cdC8vIDguRXhlY3V0ZSB0aGUgc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG5cdGNvbnN0IGN1cnJlbnRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcblxuXHRzd2l0Y2ggKHBvbGljeSkge1xuXHRcdGNhc2UgJ25vLXJlZmVycmVyJzpcblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luJzpcblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ3Vuc2FmZS11cmwnOlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0Y2FzZSAnc3RyaWN0LW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luLnRvU3RyaW5nKCk7XG5cblx0XHRjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAnc2FtZS1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN0J3MgY3VycmVudCBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuXG5cdFx0XHQvLyAgICByZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiBubyByZWZlcnJlci5cblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cG9saWN5fWApO1xuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3BhcnNlLXJlZmVycmVyLXBvbGljeS1mcm9tLWhlYWRlcnxSZWZlcnJlciBQb2xpY3kgwqc4LjEuIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyfVxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzIFJlc3BvbnNlIGhlYWRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHBvbGljeVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoaGVhZGVycykge1xuXHQvLyAxLiBMZXQgcG9saWN5LXRva2VucyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuIGBSZWZlcnJlci1Qb2xpY3lgXG5cdC8vICAgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG5cdGNvbnN0IHBvbGljeVRva2VucyA9IChoZWFkZXJzLmdldCgncmVmZXJyZXItcG9saWN5JykgfHwgJycpLnNwbGl0KC9bLFxcc10rLyk7XG5cblx0Ly8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRsZXQgcG9saWN5ID0gJyc7XG5cblx0Ly8gMy4gRm9yIGVhY2ggdG9rZW4gaW4gcG9saWN5LXRva2VucywgaWYgdG9rZW4gaXMgYSByZWZlcnJlciBwb2xpY3kgYW5kIHRva2VuIGlzIG5vdCB0aGUgZW1wdHlcblx0Ly8gICAgc3RyaW5nLCB0aGVuIHNldCBwb2xpY3kgdG8gdG9rZW4uXG5cdC8vIE5vdGU6IFRoaXMgYWxnb3JpdGhtIGxvb3BzIG92ZXIgbXVsdGlwbGUgcG9saWN5IHZhbHVlcyB0byBhbGxvdyBkZXBsb3ltZW50IG9mIG5ldyBwb2xpY3lcblx0Ly8gdmFsdWVzIHdpdGggZmFsbGJhY2tzIGZvciBvbGRlciB1c2VyIGFnZW50cywgYXMgZGVzY3JpYmVkIGluIMKnIDExLjEgVW5rbm93biBQb2xpY3kgVmFsdWVzLlxuXHRmb3IgKGNvbnN0IHRva2VuIG9mIHBvbGljeVRva2Vucykge1xuXHRcdGlmICh0b2tlbiAmJiBSZWZlcnJlclBvbGljeS5oYXModG9rZW4pKSB7XG5cdFx0XHRwb2xpY3kgPSB0b2tlbjtcblx0XHR9XG5cdH1cblxuXHQvLyA0LiBSZXR1cm4gcG9saWN5LlxuXHRyZXR1cm4gcG9saWN5O1xufVxuIl0sIm5hbWVzIjpbIkFib3J0U2lnbmFsIiwiZXZlbnRUYXJnZXRTaGltIiwiRXZlbnRUYXJnZXQiLCJjb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsImFib3J0ZWQiLCJhYm9ydGVkRmxhZ3MiLCJnZXQiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZSIsInByb3RvdHlwZSIsImNyZWF0ZUFib3J0U2lnbmFsIiwic2lnbmFsIiwiT2JqZWN0IiwiY3JlYXRlIiwiY2FsbCIsInNldCIsImFib3J0U2lnbmFsIiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJXZWFrTWFwIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWxzIiwiZ2V0U2lnbmFsIiwiYWJvcnQiLCJjb250cm9sbGVyIiwicHJpdmF0ZURhdGEiLCJ3cmFwcGVycyIsInBkIiwiZXZlbnQiLCJyZXR2IiwiY29uc29sZSIsImFzc2VydCIsInNldENhbmNlbEZsYWciLCJkYXRhIiwicGFzc2l2ZUxpc3RlbmVyIiwiZXJyb3IiLCJjYW5jZWxhYmxlIiwiY2FuY2VsZWQiLCJwcmV2ZW50RGVmYXVsdCIsIkV2ZW50IiwiZXZlbnRUYXJnZXQiLCJldmVudFBoYXNlIiwiY3VycmVudFRhcmdldCIsInN0b3BwZWQiLCJpbW1lZGlhdGVTdG9wcGVkIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImtleXMiLCJpIiwibGVuZ3RoIiwia2V5IiwiZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yIiwidGFyZ2V0IiwiY29tcG9zZWRQYXRoIiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYnViYmxlcyIsIkJvb2xlYW4iLCJkZWZhdWx0UHJldmVudGVkIiwiY29tcG9zZWQiLCJzcmNFbGVtZW50IiwiY2FuY2VsQnViYmxlIiwicmV0dXJuVmFsdWUiLCJpbml0RXZlbnQiLCJ3cml0YWJsZSIsIndpbmRvdyIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lQ2FsbERlc2NyaXB0b3IiLCJhcHBseSIsImFyZ3VtZW50cyIsImRlZmluZVdyYXBwZXIiLCJCYXNlRXZlbnQiLCJwcm90byIsIkN1c3RvbUV2ZW50IiwiZGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzRnVuYyIsImdldFdyYXBwZXIiLCJ3cmFwcGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJ3cmFwRXZlbnQiLCJXcmFwcGVyIiwiaXNTdG9wcGVkIiwic2V0RXZlbnRQaGFzZSIsInNldEN1cnJlbnRUYXJnZXQiLCJzZXRQYXNzaXZlTGlzdGVuZXIiLCJsaXN0ZW5lcnNNYXAiLCJDQVBUVVJFIiwiQlVCQkxFIiwiQVRUUklCVVRFIiwiaXNPYmplY3QiLCJ4IiwiZ2V0TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yIiwiZXZlbnROYW1lIiwibm9kZSIsImxpc3RlbmVyVHlwZSIsImxpc3RlbmVyIiwibmV4dCIsInByZXYiLCJkZWxldGUiLCJuZXdOb2RlIiwicGFzc2l2ZSIsIm9uY2UiLCJldmVudFRhcmdldFByb3RvdHlwZSIsImRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0IiwiZXZlbnROYW1lcyIsIkN1c3RvbUV2ZW50VGFyZ2V0IiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5IiwidHlwZXMiLCJhZGRFdmVudExpc3RlbmVyIiwib3B0aW9ucyIsIm9wdGlvbnNJc09iaiIsImNhcHR1cmUiLCJ1bmRlZmluZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid3JhcHBlZEV2ZW50IiwiZXJyIiwiaGFuZGxlRXZlbnQiLCJnbG9iYWxUaGlzIiwiRE9NRXhjZXB0aW9uIiwiTWVzc2FnZUNoYW5uZWwiLCJyZXF1aXJlIiwicG9ydCIsInBvcnQxIiwiYWIiLCJBcnJheUJ1ZmZlciIsInBvc3RNZXNzYWdlIiwibmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJTeW1ib2xQb2x5ZmlsbCIsIml0ZXJhdG9yIiwiZGVzY3JpcHRpb24iLCJub29wIiwiZ2V0R2xvYmFscyIsInNlbGYiLCJnbG9iYWwiLCJnbG9iYWxzIiwidHlwZUlzT2JqZWN0IiwicmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uIiwib3JpZ2luYWxQcm9taXNlIiwiUHJvbWlzZSIsIm9yaWdpbmFsUHJvbWlzZVRoZW4iLCJ0aGVuIiwib3JpZ2luYWxQcm9taXNlUmVzb2x2ZSIsInJlc29sdmUiLCJiaW5kIiwib3JpZ2luYWxQcm9taXNlUmVqZWN0IiwicmVqZWN0IiwibmV3UHJvbWlzZSIsImV4ZWN1dG9yIiwicHJvbWlzZVJlc29sdmVkV2l0aCIsInByb21pc2VSZWplY3RlZFdpdGgiLCJyZWFzb24iLCJQZXJmb3JtUHJvbWlzZVRoZW4iLCJwcm9taXNlIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwidXBvblByb21pc2UiLCJ1cG9uRnVsZmlsbG1lbnQiLCJ1cG9uUmVqZWN0aW9uIiwidHJhbnNmb3JtUHJvbWlzZVdpdGgiLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwic2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsUXVldWVNaWNyb3Rhc2siLCJyZXNvbHZlZFByb21pc2UiLCJmbiIsInJlZmxlY3RDYWxsIiwiRiIsIlYiLCJhcmdzIiwiRnVuY3Rpb24iLCJwcm9taXNlQ2FsbCIsIlFVRVVFX01BWF9BUlJBWV9TSVpFIiwiU2ltcGxlUXVldWUiLCJfY3Vyc29yIiwiX3NpemUiLCJfZnJvbnQiLCJfZWxlbWVudHMiLCJfbmV4dCIsIl9iYWNrIiwicHVzaCIsImVsZW1lbnQiLCJvbGRCYWNrIiwibmV3QmFjayIsInNoaWZ0Iiwib2xkRnJvbnQiLCJuZXdGcm9udCIsIm9sZEN1cnNvciIsIm5ld0N1cnNvciIsImVsZW1lbnRzIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwicGVlayIsImZyb250IiwiY3Vyc29yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSIsInJlYWRlciIsInN0cmVhbSIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiX3N0b3JlZEVycm9yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsIiwiUmVhZGFibGVTdHJlYW1DYW5jZWwiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsInJlYWRlckxvY2tFeGNlcHRpb24iLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJBYm9ydFN0ZXBzIiwiRXJyb3JTdGVwcyIsIkNhbmNlbFN0ZXBzIiwiUHVsbFN0ZXBzIiwiTnVtYmVySXNGaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGhUcnVuYyIsIk1hdGgiLCJ0cnVuYyIsInYiLCJjZWlsIiwiZmxvb3IiLCJpc0RpY3Rpb25hcnkiLCJhc3NlcnREaWN0aW9uYXJ5Iiwib2JqIiwiY29udGV4dCIsImFzc2VydEZ1bmN0aW9uIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCIsInBvc2l0aW9uIiwiYXNzZXJ0UmVxdWlyZWRGaWVsZCIsImZpZWxkIiwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZSIsImNlbnNvck5lZ2F0aXZlWmVybyIsImludGVnZXJQYXJ0IiwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXNzZXJ0UmVhZGFibGVTdHJlYW0iLCJJc1JlYWRhYmxlU3RyZWFtIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QiLCJyZWFkUmVxdWVzdCIsIl9yZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCIsImNodW5rIiwiZG9uZSIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCIsImNsb3NlZCIsImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiY2FuY2VsIiwicmVhZCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvclN0ZXBzIiwiZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQiLCJyZWxlYXNlTG9jayIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCIsInByZXZlbnRDYW5jZWwiLCJfb25nb2luZ1Byb21pc2UiLCJfaXNGaW5pc2hlZCIsIl9wcmV2ZW50Q2FuY2VsIiwibmV4dFN0ZXBzIiwiX25leHRTdGVwcyIsInJldHVybiIsInJldHVyblN0ZXBzIiwiX3JldHVyblN0ZXBzIiwicmVzdWx0IiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJpbXBsIiwiX2EiLCJOdW1iZXJJc05hTiIsImlzTmFOIiwiQ3JlYXRlQXJyYXlGcm9tTGlzdCIsInNsaWNlIiwiQ29weURhdGFCbG9ja0J5dGVzIiwiZGVzdCIsImRlc3RPZmZzZXQiLCJzcmMiLCJzcmNPZmZzZXQiLCJuIiwiVWludDhBcnJheSIsIlRyYW5zZmVyQXJyYXlCdWZmZXIiLCJPIiwiSXNEZXRhY2hlZEJ1ZmZlciIsIkFycmF5QnVmZmVyU2xpY2UiLCJidWZmZXIiLCJiZWdpbiIsImVuZCIsIklzTm9uTmVnYXRpdmVOdW1iZXIiLCJDbG9uZUFzVWludDhBcnJheSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiRGVxdWV1ZVZhbHVlIiwiY29udGFpbmVyIiwicGFpciIsIl9xdWV1ZSIsIl9xdWV1ZVRvdGFsU2l6ZSIsInNpemUiLCJFbnF1ZXVlVmFsdWVXaXRoU2l6ZSIsIkluZmluaXR5IiwiUmFuZ2VFcnJvciIsIlBlZWtRdWV1ZVZhbHVlIiwiUmVzZXRRdWV1ZSIsIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJ2aWV3IiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uIiwiX3ZpZXciLCJyZXNwb25kIiwiYnl0ZXNXcml0dGVuIiwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQiLCJyZXNwb25kV2l0aE5ld1ZpZXciLCJpc1ZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5b2JSZXF1ZXN0IiwiSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0IiwiZGVzaXJlZFNpemUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJjbG9zZSIsIl9jbG9zZVJlcXVlc3RlZCIsInN0YXRlIiwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UiLCJlbnF1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zIiwiX2NhbmNlbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJlbnRyeSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckUiLCJwdWxsSW50b0Rlc2NyaXB0b3IiLCJidWZmZXJCeXRlTGVuZ3RoIiwiYnl0ZXNGaWxsZWQiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsInJlYWRlclR5cGUiLCJfcGVuZGluZ1B1bGxJbnRvcyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkIiwic2hvdWxkUHVsbCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIl9wdWxsaW5nIiwiX3B1bGxBZ2FpbiIsInB1bGxQcm9taXNlIiwiX3B1bGxBbGdvcml0aG0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvciIsImZpbGxlZFZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUiLCJjdXJyZW50QWxpZ25lZEJ5dGVzIiwibWF4Qnl0ZXNUb0NvcHkiLCJtaW4iLCJtYXhCeXRlc0ZpbGxlZCIsIm1heEFsaWduZWRCeXRlcyIsInRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmciLCJyZWFkeSIsInF1ZXVlIiwiaGVhZE9mUXVldWUiLCJieXRlc1RvQ29weSIsImRlc3RTdGFydCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJfYnlvYlJlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvIiwicmVhZEludG9SZXF1ZXN0IiwiRGF0YVZpZXciLCJCWVRFU19QRVJfRUxFTUVOVCIsImN0b3IiLCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdCIsImVtcHR5VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZSIsImZpcnN0RGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlIiwicmVtYWluZGVyU2l6ZSIsInJlbWFpbmRlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwiLCJfc3RhcnRlZCIsImZpcnN0UGVuZGluZ1B1bGxJbnRvIiwidHJhbnNmZXJyZWRCdWZmZXIiLCJ0cmFuc2ZlcnJlZFZpZXciLCJSZWFkYWJsZVN0cmVhbUVycm9yIiwiU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiX3N0cmF0ZWd5SFdNIiwidmlld0J5dGVMZW5ndGgiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJzdGFydEFsZ29yaXRobSIsInB1bGxBbGdvcml0aG0iLCJjYW5jZWxBbGdvcml0aG0iLCJoaWdoV2F0ZXJNYXJrIiwic3RhcnRSZXN1bHQiLCJyIiwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UiLCJ1bmRlcmx5aW5nQnl0ZVNvdXJjZSIsInN0YXJ0IiwicHVsbCIsInJlcXVlc3QiLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiX3JlYWRJbnRvUmVxdWVzdHMiLCJJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsImJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCIsIkV4dHJhY3RIaWdoV2F0ZXJNYXJrIiwic3RyYXRlZ3kiLCJkZWZhdWx0SFdNIiwiRXh0cmFjdFNpemVBbGdvcml0aG0iLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IiwiaW5pdCIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplIiwiY29udmVydFVuZGVybHlpbmdTaW5rIiwib3JpZ2luYWwiLCJ3cml0ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2siLCJhc3NlcnRXcml0YWJsZVN0cmVhbSIsIklzV3JpdGFibGVTdHJlYW0iLCJpc0Fib3J0U2lnbmFsIiwic3VwcG9ydHNBYm9ydENvbnRyb2xsZXIiLCJjcmVhdGVBYm9ydENvbnRyb2xsZXIiLCJXcml0YWJsZVN0cmVhbSIsInJhd1VuZGVybHlpbmdTaW5rIiwicmF3U3RyYXRlZ3kiLCJ1bmRlcmx5aW5nU2luayIsIkluaXRpYWxpemVXcml0YWJsZVN0cmVhbSIsInNpemVBbGdvcml0aG0iLCJTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsiLCJsb2NrZWQiLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJJc1dyaXRhYmxlU3RyZWFtTG9ja2VkIiwiV3JpdGFibGVTdHJlYW1BYm9ydCIsIldyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0IiwiV3JpdGFibGVTdHJlYW1DbG9zZSIsImdldFdyaXRlciIsIkFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJDcmVhdGVXcml0YWJsZVN0cmVhbSIsIndyaXRlQWxnb3JpdGhtIiwiY2xvc2VBbGdvcml0aG0iLCJhYm9ydEFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJfd3JpdGVyIiwiX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciIsIl93cml0ZVJlcXVlc3RzIiwiX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IiwiX2Nsb3NlUmVxdWVzdCIsIl9pbkZsaWdodENsb3NlUmVxdWVzdCIsIl9wZW5kaW5nQWJvcnRSZXF1ZXN0IiwiX2JhY2twcmVzc3VyZSIsIl9hYm9ydFJlYXNvbiIsIl9hYm9ydENvbnRyb2xsZXIiLCJfcHJvbWlzZSIsIndhc0FscmVhZHlFcnJvcmluZyIsIl9yZXNvbHZlIiwiX3JlamVjdCIsIl9yZWFzb24iLCJfd2FzQWxyZWFkeUVycm9yaW5nIiwiV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nIiwiY2xvc2VSZXF1ZXN0Iiwid3JpdGVyIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UiLCJXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdCIsIndyaXRlUmVxdWVzdCIsIldyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24iLCJXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQiLCJXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0Iiwic3RvcmVkRXJyb3IiLCJXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkIiwiYWJvcnRSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yIiwiV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0IiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3QiLCJXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZSIsImJhY2twcmVzc3VyZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCIsIl9vd25lcldyaXRhYmxlU3RyZWFtIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsIklzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbiIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplIiwiX3JlYWR5UHJvbWlzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0IiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkIiwiX2Nsb3NlZFByb21pc2VTdGF0ZSIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwiX3JlYWR5UHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJyZWxlYXNlZEVycm9yIiwiY2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZSIsImNsb3NlU2VudGluZWwiLCJhYm9ydFJlYXNvbiIsIklzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyIiwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsIl9hYm9ydEFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJfc3RyYXRlZ3lTaXplQWxnb3JpdGhtIiwiX3dyaXRlQWxnb3JpdGhtIiwiX2Nsb3NlQWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZSIsInN0YXJ0UHJvbWlzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZCIsImNodW5rU2l6ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCIsImVucXVldWVFIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUiLCJzaW5rQ2xvc2VQcm9taXNlIiwic2lua1dyaXRlUHJvbWlzZSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfcmVhZHlQcm9taXNlX3Jlc29sdmUiLCJfcmVhZHlQcm9taXNlX3JlamVjdCIsIk5hdGl2ZURPTUV4Y2VwdGlvbiIsImlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IiLCJjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiRE9NRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbVBpcGVUbyIsInNvdXJjZSIsInByZXZlbnRDbG9zZSIsInByZXZlbnRBYm9ydCIsInNodXR0aW5nRG93biIsImN1cnJlbnRXcml0ZSIsImFjdGlvbnMiLCJzaHV0ZG93bldpdGhBY3Rpb24iLCJhbGwiLCJtYXAiLCJhY3Rpb24iLCJwaXBlTG9vcCIsInJlc29sdmVMb29wIiwicmVqZWN0TG9vcCIsInBpcGVTdGVwIiwicmVzb2x2ZVJlYWQiLCJyZWplY3RSZWFkIiwiaXNPckJlY29tZXNFcnJvcmVkIiwic2h1dGRvd24iLCJpc09yQmVjb21lc0Nsb3NlZCIsImRlc3RDbG9zZWQiLCJ3YWl0Rm9yV3JpdGVzVG9GaW5pc2giLCJvbGRDdXJyZW50V3JpdGUiLCJvcmlnaW5hbElzRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiZG9UaGVSZXN0IiwiZmluYWxpemUiLCJuZXdFcnJvciIsImlzRXJyb3IiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UiLCJ1bmRlcmx5aW5nU291cmNlIiwiUmVhZGFibGVTdHJlYW1UZWUiLCJjbG9uZUZvckJyYW5jaDIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1UZWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUiLCJyZWFkaW5nIiwicmVhZEFnYWluIiwiY2FuY2VsZWQxIiwiY2FuY2VsZWQyIiwicmVhc29uMSIsInJlYXNvbjIiLCJicmFuY2gxIiwiYnJhbmNoMiIsInJlc29sdmVDYW5jZWxQcm9taXNlIiwiY2FuY2VsUHJvbWlzZSIsImNodW5rMSIsImNodW5rMiIsImNhbmNlbDFBbGdvcml0aG0iLCJjb21wb3NpdGVSZWFzb24iLCJjYW5jZWxSZXN1bHQiLCJjYW5jZWwyQWxnb3JpdGhtIiwiQ3JlYXRlUmVhZGFibGVTdHJlYW0iLCJyZWFkQWdhaW5Gb3JCcmFuY2gxIiwicmVhZEFnYWluRm9yQnJhbmNoMiIsImZvcndhcmRSZWFkZXJFcnJvciIsInRoaXNSZWFkZXIiLCJwdWxsV2l0aERlZmF1bHRSZWFkZXIiLCJjbG9uZUUiLCJwdWxsMUFsZ29yaXRobSIsInB1bGwyQWxnb3JpdGhtIiwicHVsbFdpdGhCWU9CUmVhZGVyIiwiZm9yQnJhbmNoMiIsImJ5b2JCcmFuY2giLCJvdGhlckJyYW5jaCIsImJ5b2JDYW5jZWxlZCIsIm90aGVyQ2FuY2VsZWQiLCJjbG9uZWRDaHVuayIsIkNyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbSIsImNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayIsImNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUiLCJjb252ZXJ0UmVhZGVyT3B0aW9ucyIsIm1vZGUiLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlIiwiY29udmVydEl0ZXJhdG9yT3B0aW9ucyIsImNvbnZlcnRQaXBlT3B0aW9ucyIsImFzc2VydEFib3J0U2lnbmFsIiwiY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInJhd1VuZGVybHlpbmdTb3VyY2UiLCJJbml0aWFsaXplUmVhZGFibGVTdHJlYW0iLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJnZXRSZWFkZXIiLCJyYXdPcHRpb25zIiwicGlwZVRocm91Z2giLCJyYXdUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJwaXBlVG8iLCJkZXN0aW5hdGlvbiIsInRlZSIsImJyYW5jaGVzIiwidmFsdWVzIiwiYXN5bmNJdGVyYXRvciIsInNvdXJjZUNhbmNlbFByb21pc2UiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCIsImJ5dGVMZW5ndGhTaXplRnVuY3Rpb24iLCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb3VudFNpemVGdW5jdGlvbiIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb252ZXJ0VHJhbnNmb3JtZXIiLCJmbHVzaCIsInJlYWRhYmxlVHlwZSIsIndyaXRhYmxlVHlwZSIsImNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2siLCJUcmFuc2Zvcm1TdHJlYW0iLCJyYXdUcmFuc2Zvcm1lciIsInJhd1dyaXRhYmxlU3RyYXRlZ3kiLCJyYXdSZWFkYWJsZVN0cmF0ZWd5Iiwid3JpdGFibGVTdHJhdGVneSIsInJlYWRhYmxlU3RyYXRlZ3kiLCJ0cmFuc2Zvcm1lciIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsInJlYWRhYmxlU2l6ZUFsZ29yaXRobSIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsIndyaXRhYmxlU2l6ZUFsZ29yaXRobSIsInN0YXJ0UHJvbWlzZV9yZXNvbHZlIiwiSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSIsIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIiLCJfdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciIsIklzVHJhbnNmb3JtU3RyZWFtIiwiX3JlYWRhYmxlIiwiX3dyaXRhYmxlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlIiwiVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlIiwiVHJhbnNmb3JtU3RyZWFtRXJyb3IiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsInJlYWRhYmxlQ29udHJvbGxlciIsIl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsInRlcm1pbmF0ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsInRyYW5zZm9ybUFsZ29yaXRobSIsImZsdXNoQWxnb3JpdGhtIiwiX3RyYW5zZm9ybUFsZ29yaXRobSIsIl9mbHVzaEFsZ29yaXRobSIsInRyYW5zZm9ybVJlc3VsdEUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Qcm9taXNlIiwiYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsImZsdXNoUHJvbWlzZSIsImRhdGFVcmlUb0J1ZmZlciIsInVyaSIsInRlc3QiLCJyZXBsYWNlIiwiZmlyc3RDb21tYSIsImluZGV4T2YiLCJtZXRhIiwic3Vic3RyaW5nIiwic3BsaXQiLCJjaGFyc2V0IiwiYmFzZTY0IiwidHlwZUZ1bGwiLCJlbmNvZGluZyIsInVuZXNjYXBlIiwiQnVmZmVyIiwiZnJvbSIsIkJsb2IiLCJfRmlsZSIsIkZpbGUiLCJsYXN0TW9kaWZpZWQiLCJmaWxlQml0cyIsImZpbGVOYW1lIiwiU3RyaW5nIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJzdGF0U3luYyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJwcm9taXNlcyIsImZzIiwiYmFzZW5hbWUiLCJzdGF0IiwiYmxvYkZyb21TeW5jIiwicGF0aCIsImZyb21CbG9iIiwiYmxvYkZyb20iLCJmaWxlRnJvbSIsImZyb21GaWxlIiwiZmlsZUZyb21TeW5jIiwiQmxvYkRhdGFJdGVtIiwibXRpbWVNcyIsIlBPT0xfU0laRSIsInRvSXRlcmF0b3IiLCJwYXJ0cyIsImNsb25lIiwicGFydCIsImIiLCJhcnJheUJ1ZmZlciIsIl9CbG9iIiwiZW5kaW5ncyIsImJsb2JQYXJ0cyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInRleHQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJzdHIiLCJkZWNvZGUiLCJvZmZzZXQiLCJpdCIsImN0cmwiLCJyZWxhdGl2ZVN0YXJ0IiwibWF4IiwicmVsYXRpdmVFbmQiLCJzcGFuIiwiYWRkZWQiLCJzdWJhcnJheSIsImJsb2IiLCJ0b0xvd2VyQ2FzZSIsIkMiLCJ0IiwiaCIsInJhbmRvbSIsIm0iLCJmIiwiYSIsImMiLCJGb3JtRGF0YSIsImQiLCJlbnRyaWVzIiwibyIsInNvbWUiLCJhcHBlbmQiLCJmaWx0ZXIiLCJsIiwiZ2V0QWxsIiwiaGFzIiwiZm9ybURhdGFUb0Jsb2IiLCJCIiwicGFkU3RhcnQiLCJwIiwiZmV0Y2giLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwiVEVOX01FR0FCWVRFUyIsInVybCIsImRlZmF1bHQiLCJreSIsIkhUVFBFcnJvciIsIlRpbWVvdXRFcnJvciIsIlN0cmVhbSIsIlBhc3NUaHJvdWdoIiwiZGVwcmVjYXRlIiwicHJvbWlzaWZ5IiwiRmV0Y2hFcnJvciIsIkZldGNoQmFzZUVycm9yIiwiaXNCbG9iIiwiaXNVUkxTZWFyY2hQYXJhbWV0ZXJzIiwicGlwZWxpbmUiLCJJTlRFUk5BTFMiLCJCb2R5IiwiYm9keSIsImJvdW5kYXJ5IiwidG9TdHJpbmciLCJpc0J1ZmZlciIsImlzQW55QXJyYXlCdWZmZXIiLCJSZWFkYWJsZSIsImRpc3R1cmJlZCIsIm9uIiwiZXJyb3JfIiwiYm9keVVzZWQiLCJjb25zdW1lQm9keSIsImZvcm1EYXRhIiwiY3QiLCJoZWFkZXJzIiwic3RhcnRzV2l0aCIsInBhcmFtZXRlcnMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b0Zvcm1EYXRhIiwiYnVmIiwianNvbiIsIkpTT04iLCJwYXJzZSIsImFsbG9jIiwiYWNjdW0iLCJhY2N1bUJ5dGVzIiwiZGVzdHJveSIsInJlYWRhYmxlRW5kZWQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZGVkIiwiZXZlcnkiLCJqb2luIiwiY29uY2F0IiwiaW5zdGFuY2UiLCJwMSIsInAyIiwiZ2V0Qm91bmRhcnkiLCJwaXBlIiwiZ2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsIkFib3J0RXJyb3IiLCJzeXN0ZW1FcnJvciIsImNvZGUiLCJlcnJubyIsImVycm9yZWRTeXNDYWxsIiwic3lzY2FsbCIsImh0dHAiLCJ2YWxpZGF0ZUhlYWRlck5hbWUiLCJ2YWxpZGF0ZUhlYWRlclZhbHVlIiwicmF3IiwiaXNCb3hlZFByaW1pdGl2ZSIsIm1ldGhvZCIsIlByb3h5IiwicmVjZWl2ZXIiLCJzb3J0IiwiU2V0IiwiUmVmbGVjdCIsInRoaXNBcmciLCJyZWR1Y2UiLCJmb3IiLCJwcm9wZXJ0eSIsImZyb21SYXdIZWFkZXJzIiwiaW5kZXgiLCJhcnJheSIsImh0dHBzIiwiemxpYiIsInB1bXAiLCJnZXROb2RlUmVxdWVzdE9wdGlvbnMiLCJpc1JlZGlyZWN0IiwiaXNEb21haW5PclN1YmRvbWFpbiIsImlzU2FtZVByb3RvY29sIiwicGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIiLCJzdXBwb3J0ZWRTY2hlbWFzIiwib3B0aW9uc18iLCJwYXJzZWRVUkwiLCJwcm90b2NvbCIsInJlc3BvbnNlIiwic2VuZCIsImVtaXQiLCJhYm9ydEFuZEZpbmFsaXplIiwicmVxdWVzdF8iLCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwicyIsImVuZGVkV2l0aEV2ZW50c0NvdW50IiwicHJlcGVuZExpc3RlbmVyIiwiX2V2ZW50c0NvdW50IiwiaGFkRXJyb3IiLCJyZXNwb25zZV8iLCJzZXRUaW1lb3V0IiwicmF3SGVhZGVycyIsInN0YXR1c0NvZGUiLCJsb2NhdGlvbiIsImxvY2F0aW9uVVJMIiwiVVJMIiwicmVkaXJlY3QiLCJjb3VudGVyIiwiZm9sbG93IiwicmVxdWVzdE9wdGlvbnMiLCJhZ2VudCIsImNvbXByZXNzIiwicmVmZXJyZXIiLCJyZWZlcnJlclBvbGljeSIsInJlc3BvbnNlUmVmZXJyZXJQb2xpY3kiLCJyZXNwb25zZU9wdGlvbnMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3RhdHVzTWVzc2FnZSIsImNvZGluZ3MiLCJ6bGliT3B0aW9ucyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwiY2F0Y2giLCJlcnJvckNhbGxiYWNrIiwiTEFTVF9DSFVOSyIsImlzQ2h1bmtlZFRyYW5zZmVyIiwicHJvcGVyTGFzdENodW5rUmVjZWl2ZWQiLCJwcmV2aW91c0NodW5rIiwic29ja2V0Iiwib25Tb2NrZXRDbG9zZSIsIm9uRGF0YSIsImNvbXBhcmUiLCJyZW1vdmVMaXN0ZW5lciIsImZvcm1hdCIsImZvcm1hdFVybCIsImdldFNlYXJjaCIsInZhbGlkYXRlUmVmZXJyZXJQb2xpY3kiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwiREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1kiLCJpc1JlcXVlc3QiLCJkb0JhZERhdGFXYXJuIiwiaW5wdXQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwidG9VcHBlckNhc2UiLCJpbnB1dEJvZHkiLCJjb250ZW50VHlwZSIsInBhcnNlZFJlZmVycmVyIiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiY29udGVudExlbmd0aFZhbHVlIiwidG90YWxCeXRlcyIsInNlYXJjaCIsInBhdGhuYW1lIiwib2siLCJyZWRpcmVjdGVkIiwic3RyaW5naWZ5IiwibGFzdE9mZnNldCIsImhyZWYiLCJoYXNoIiwicmVkaXJlY3RTdGF0dXMiLCJOQU1FIiwib3JpZyIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJpc0lQIiwic3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlciIsIm9yaWdpbk9ubHkiLCJSZWZlcnJlclBvbGljeSIsImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImhvc3RJcCIsImhvc3QiLCJob3N0SVBWZXJzaW9uIiwiaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5IiwicmVmZXJyZXJVUkxDYWxsYmFjayIsInJlZmVycmVyT3JpZ2luQ2FsbGJhY2siLCJwb2xpY3kiLCJyZWZlcnJlclNvdXJjZSIsInJlZmVycmVyVVJMIiwicmVmZXJyZXJPcmlnaW4iLCJjdXJyZW50VVJMIiwib3JpZ2luIiwicG9saWN5VG9rZW5zIiwidG9rZW4iXSwic291cmNlUm9vdCI6IiJ9